<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chenggr.github.io</id>
    <title>chenggr&apos;s blog</title>
    <updated>2022-06-02T02:40:54.090Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chenggr.github.io"/>
    <link rel="self" href="https://chenggr.github.io/atom.xml"/>
    <subtitle>一个记录与分享的地方~</subtitle>
    <logo>https://chenggr.github.io/images/avatar.png</logo>
    <icon>https://chenggr.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, chenggr&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[interview questions 2]]></title>
        <id>https://chenggr.github.io/post/gin/</id>
        <link href="https://chenggr.github.io/post/gin/">
        </link>
        <updated>2022-04-07T08:52:35.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>interview questions 2 for zhouzhe</p>
</blockquote>
<p>JSONP  含义<br>
根据浏览器同源策略，所谓同源就是协议、主机、端口号都相同时成为同源。a 域的js不能直接访问 b域名的信息，但是script 标签的src属性可以跨域引用文件，jsonp是请求之后后台包装好一段json，并且把数据放在一个callback函数，返回一个js文件，动态引入这个文件，下载完成js之后，会去调用这个callback,通过这样访问数据。</p>
<p>JSONP有什么用<br>
由于同源从略的限制，XMLHttpRequest只允许请求前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后再服务端输出JSON数据并执行回调函数，从而解决跨域数据请求</p>
<p>Vue  传值方法(6种)<br>
属性传值  $refs  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">知</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">值</mi><mo>(</mo><mi mathvariant="normal">广</mi><mi mathvariant="normal">播</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">值</mi><mo>)</mo><mi mathvariant="normal">本</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">路</mi><mi mathvariant="normal">由</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">关</mi><mi mathvariant="normal">系</mi><mi mathvariant="normal">分</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">三</mi><mi mathvariant="normal">种</mi><mo>:</mo><mi mathvariant="normal">父</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">、</mi><mi mathvariant="normal">兄</mi><mi mathvariant="normal">弟</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">、</mi><mi mathvariant="normal">无</mi><mi mathvariant="normal">关</mi><mi mathvariant="normal">系</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">类</mi><mi mathvariant="normal">型</mi><mo>:</mo><mi mathvariant="normal">固</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">绑</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">属</mi><mi mathvariant="normal">性</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">本</mi><mi mathvariant="normal">类</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">象</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">给</mi><mi mathvariant="normal">父</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">：</mi></mrow><annotation encoding="application/x-tex">parent  通知传值(广播传值)  本地传值  路由传值
组件关系分为三种 : 父子组件、兄弟组件、无关系组件
可传值类型 :  固定值  绑定属性  方法  本类对象
子组件传给父组件：</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">知</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">值</span><span class="mopen">(</span><span class="mord cjk_fallback">广</span><span class="mord cjk_fallback">播</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">值</span><span class="mclose">)</span><span class="mord cjk_fallback">本</span><span class="mord cjk_fallback">地</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">路</span><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">关</span><span class="mord cjk_fallback">系</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">三</span><span class="mord cjk_fallback">种</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">、</span><span class="mord cjk_fallback">兄</span><span class="mord cjk_fallback">弟</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">、</span><span class="mord cjk_fallback">无</span><span class="mord cjk_fallback">关</span><span class="mord cjk_fallback">系</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">类</span><span class="mord cjk_fallback">型</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">固</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">绑</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">属</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">本</span><span class="mord cjk_fallback">类</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">象</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">给</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">：</span></span></span></span>emit方法传递参数<br>
父传子：（绑定动态属性，子通过props传递）<br>
父获取子：（调用子组件的时候调用一个ref，在父组件中通过this.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>f</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">属</mi><mi mathvariant="normal">性</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">）</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">获</mi><mi mathvariant="normal">取</mi><mi mathvariant="normal">父</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">过</mi></mrow><annotation encoding="application/x-tex">refs.header.属性/.方法）
子获取父：（子通过</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">.</span><span class="mord cjk_fallback">属</span><span class="mord cjk_fallback">性</span><span class="mord">/</span><span class="mord">.</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">获</span><span class="mord cjk_fallback">取</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span></span></span></span>parent获取父组件的数据和方法，子中使用this.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>X</mi><mi>X</mi><mi mathvariant="normal">）</mi><mi mathvariant="normal">非</mi><mi mathvariant="normal">父</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">递</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">兄</mi><mi mathvariant="normal">弟</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">值</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>B</mi><mi>u</mi><mi>s</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">创</mi><mi mathvariant="normal">建</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">事</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">心</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">相</mi><mi mathvariant="normal">当</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">转</mi><mi mathvariant="normal">站</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">它</mi><mi mathvariant="normal">来</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">递</mi><mi mathvariant="normal">事</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">和</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">收</mi><mi mathvariant="normal">事</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">项</mi><mi mathvariant="normal">目</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">较</mi><mi mathvariant="normal">小</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">较</mi><mi mathvariant="normal">合</mi><mi mathvariant="normal">适</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">虽</mi><mi mathvariant="normal">然</mi><mi mathvariant="normal">也</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">少</mi><mi mathvariant="normal">人</mi><mi mathvariant="normal">推</mi><mi mathvariant="normal">荐</mi><mi mathvariant="normal">直</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">用</mi><mi>V</mi><mi>U</mi><mi>E</mi><mi>X</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">具</mi><mi mathvariant="normal">体</mi><mi mathvariant="normal">来</mi><mi mathvariant="normal">说</mi><mi mathvariant="normal">看</mi><mi mathvariant="normal">需</mi><mi mathvariant="normal">求</mi><mi mathvariant="normal">咯</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">技</mi><mi mathvariant="normal">术</mi><mi mathvariant="normal">只</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">手</mi><mi mathvariant="normal">段</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">目</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">达</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">才</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">王</mi><mi mathvariant="normal">道</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">）</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">知</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">只</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">基</mi><mi mathvariant="normal">本</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">类</mi><mi mathvariant="normal">型</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">新</mi><mi mathvariant="normal">建</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi>j</mi><mi>s</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">然</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">引</mi><mi mathvariant="normal">入</mi><mi>v</mi><mi>u</mi><mi>e</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">化</mi><mi>v</mi><mi>u</mi><mi>e</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">暴</mi><mi mathvariant="normal">露</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">广</mi><mi mathvariant="normal">播</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">引</mi><mi mathvariant="normal">入</mi><mi mathvariant="normal">刚</mi><mi mathvariant="normal">才</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">过</mi><mi>V</mi><mi>u</mi><mi>e</mi><mi>E</mi><mi>m</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">parent.XX）
非父子组件间的数据传递，兄弟组件传值
eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道。）
通知传值：只传基本数据类型，不能传方法。新建一个js文件 然后引入vue 实例化vue 最后暴露这个实例，在要广播的地方引入刚才定义的实例，通过 VueEmit.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">非</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">递</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">兄</span><span class="mord cjk_fallback">弟</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">值</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">创</span><span class="mord cjk_fallback">建</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">事</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">心</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">相</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">转</span><span class="mord cjk_fallback">站</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">递</span><span class="mord cjk_fallback">事</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">和</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">事</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">项</span><span class="mord cjk_fallback">目</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">较</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">较</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">适</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">虽</span><span class="mord cjk_fallback">然</span><span class="mord cjk_fallback">也</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">少</span><span class="mord cjk_fallback">人</span><span class="mord cjk_fallback">推</span><span class="mord cjk_fallback">荐</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">用</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">具</span><span class="mord cjk_fallback">体</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">说</span><span class="mord cjk_fallback">看</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">求</span><span class="mord cjk_fallback">咯</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">技</span><span class="mord cjk_fallback">术</span><span class="mord cjk_fallback">只</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">手</span><span class="mord cjk_fallback">段</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">目</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">达</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">才</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">王</span><span class="mord cjk_fallback">道</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">知</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">只</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">基</span><span class="mord cjk_fallback">本</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">类</span><span class="mord cjk_fallback">型</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">建</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">然</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">入</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">化</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">暴</span><span class="mord cjk_fallback">露</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">广</span><span class="mord cjk_fallback">播</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">地</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">刚</span><span class="mord cjk_fallback">才</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">义</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord">.</span></span></span></span>emit('名称','数据')传播数据，在接收收数据的地方通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>n</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">收</mi><mi mathvariant="normal">广</mi><mi mathvariant="normal">播</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi>V</mi><mi>u</mi><mi>e</mi><mi>E</mi><mi>m</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">on接收广播的数据VueEmit.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">广</span><span class="mord cjk_fallback">播</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord">.</span></span></span></span>on('名称',function(){}<br>
本地传值：localStorage： String(可通过JSON进行json数据与String之间的转化)<br>
Vuex:方法、数据、异步方法<br>
路由传值 ：父组件push使用this.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi>p</mi><mi>u</mi><mi>s</mi><mi>h</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">获</mi><mi mathvariant="normal">取</mi><mi mathvariant="normal">参</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">是</mi><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">router.push，在子组件中获取参数时是this.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">获</span><span class="mord cjk_fallback">取</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">是</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord">.</span></span></span></span>route.params</p>
<p>VueX（状态管理器---数据传递）<br>
Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。<br>
state, getters, mutations, actions, modules。（5大属性）<br>
　　1. state：vuex的基本数据，用来存储变量<br>
　　 2. geeter：从基本数据(state)派生的数据，相当于state的计算属性<br>
　　 3. mutation：提交更新数据的方法，必须是同步的(如果需要异步使用action)。每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。<br>
　　 回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，提交载荷作为第二个参数。<br>
　　 4. action：和mutation的功能大致相同，不同之处在于 ==》1. Action 提交的是 mutation，而不是直接变更状态。 2. Action 可以包含任意异步操作。<br>
　　  5. modules：模块化vuex，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。</p>
<p>一般中大型单页应用，如果需要考虑如何更好地在组件外部管理状态，就使用vuex<br>
状态管理包含三点：state，驱动应用的数据源<br>
view，以声明方式将 state 映射到视图<br>
actions，响应在 view 上的用户输入导致的状态变化<br>
使用及数据传递：vuex文件夹里新建一个store.js---安装-- -store.js 中引入vue、vuex 引入vuex 并且use---定义数据 state在vuex中用于存储数据---定义方法 mutations里边放的是方法,方法主要用于改变state里边的数据---实例化 vuex---对外暴露---在需要用的地方引入---注册store ，放在methods,data同级---使用vuex<br>
使用数据： this.$store.state.count<br>
调用方法： this.$store.commit('incCount')</p>
<p>在Vue组件中获得Vuex属性、我们可以通过Vue的Computed获得Vuex的state</p>
<p>Vue生命周期钩子函数<br>
应用场景：<br>
beforeCreate 可以在此时加一些loading效果，在created时进行移除<br>
created 需要异步请求数据的方法可以在此时执行，完成数据的初始化<br>
mounted 当需要操作dom的时候执行，可以配合$.nextTick 使用进行单一事件对数据的更新后更新dom<br>
updated 当数据更新需要做统一业务处理的时候使用</p>
<p>Vue双向绑定原理<br>
VUE实现双向数据绑定的原理就是利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。它接收三个参数，要操作的对象，要定义或修改的对象属性名，属性描述符。重点就是最后的属性描述符。属性描述符是一个对象，主要有两种形式：数据描述符和存取描述符。这两种对象只能选择一种使用，不能混合两种描述符的属性同时使用。上面说的get和set就是属于存取描述符对象的属性。</p>
<p>前端优化方案<br>
内容优化 减少HTTP请求数（合并多个CSS文件和js文件，使用 data：URL scheme在实际的页面嵌入图像数据 )，合理设置HTTP缓存等）<br>
减少DNS查找：最理想的方法就是将所有的内容资源都放在同一个域<br>
避免重定向：在定义链接地址的href属性的时候，尽量使用最完整直接的地址<br>
使用Ajax缓存：ajax缓存只对GET方式的请求有效<br>
避免404：把缺少的网页文件恢复到正确的位置，重新设置网络服务<br>
懒加载组件：懒加载的主要目的是优化前端性能，减少请求数或延迟请求数（纯粹的延迟加载，使用setTimeOut或者setInterval 进行加载延迟，条件加载，符合某些条件，或者触发了某些事件才开始异步下载，可视区加载，即仅加载可以看到的区域，监控滚动条实现）<br>
预加载组件：预加载是牺牲前端性能，换取用户体验，使用户的操作得到最快的反映，仅使用JavaScript实现预加载；使用Ajax实现预加载。 懒加载的主要目的是优化前端性能，减少请求数或延迟请求数<br>
减少DOM元素数量：减少不必要的内容，如果数据量大，可以考虑分页，或者按需加载</p>
<p>服务器优化：对Ajax请求使用GET方法，使用内容分发网络（CDN）：把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度<br>
Cookie优化：减小Cookie大小，针对Web组件使用域名无关的Cookie<br>
Css优化：避免使用CSS表达式，使用<link>来代替@import，将CSS代码放在HTML页面的顶部<br>
javascript优化 :时间委托减少循环绑定事件, onclick，onmouseover，onmouseout(冒泡原理)<br>
图像优化: 尝试把GIF格式转换成PNG格式，看看是否节省空间,精灵图等</p>
<p>Es6<br>
1.变量声明：let表示声明局部变量，而const表示声明常量（不可更改）<br>
2.模板字符串：将表达式嵌入字符串中进行拼接。用${}来界定，ES6反引号(``)直接搞定<br>
3.箭头函数：箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =&gt;，紧接着是函数体（不需要 function 关键字来创建函数，省略 return 关键字，继承当前上下文的 this 关键字）当你的函数有且仅有一个参数的时候，是可以省略掉括号的。当你函数返回有且仅有一个表达式的时候可以省略{} 和 return）<br>
4. 对象和数组解构、函数的参数默认值、class类、二进制和八进制字面量<br>
5. for...of 和 for...in：（for...of 用于遍历一个迭代器，如数组，for...in 用来遍历对象中的属性）<br>
6.Promise</p>
<p>This的指向（4种）<br>
1.如果是一般函数,this指向全局对象window<br>
2.在严格模式下&quot;use strict&quot;,为undefined<br>
3.对象的方法里调用,this指向调用该方法的对象<br>
4.构造函数里的this,指向创建出来的实例.<br>
定时器中的this，指向的是window<br>
元素绑定事件，事件触发后，执行的函数中的this，指向的是当前元素<br>
函数调用时如果绑定了bind，那么函数中的this指向了bind中绑定的元素<br>
对象中的方法，该方法被哪个对象调用了，那么方法中的this就指向该对象</p>
<p>bind、call、apply 改变 this 的指向<br>
bind 和 call 、apply 的区别：bind 返回的是一个新的函数，并未立即执行原函数。call、apply 会立即执行原函数。<br>
call 和 apply 的区别：call 的参数需要一个个写上，apply 的参数是一个数组。<br>
优先级：（显式绑定：call、apply、bind、new）（隐式绑定：根据调用关系确定 this 指向）（new 绑定的优先级比 bind 绑定高）（箭头函数的优先级比 call、apply 高）</p>
<p>Promise<br>
Promise是异步编程的一种解决方案<br>
用途：1.用于异步计算<br>
2. 可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果<br>
3. 以在对象之间传递和操作promise，帮助我们处理队列。<br>
方法：<br>
1.then方法：then方法返回的是一个新的promise实例<br>
2.catch方法：catch方法是在promise发生错误时的回调<br>
3.finally方法：finally方法指定无论最后promise最后状态如何都会执行的函数<br>
4.all方法：all方法用于将多个实例包装成一个新的promise实例<br>
5.race方法：race方法同样是将多个实例包装成一个新的实例<br>
6.reject方法：reject方法会返回一个新的实例，状态为rejected。回调函数立即执行<br>
7.try方法：在实际开发中遇到无法区分函数是同步还是异步操作时，但是还想用promise来处理，可以使用try方法<br>
8.resolve方法：将现有对象转为promise对象，它的参数分为四种（1、参数是一个promise实例；如果参数是promise实例，则不作修改，原样返回。2、参数是一个thenable对象，是指由then方法的对象；该方法会将这个对象转为promise对象，然后立即执行then方法 。3、如果不是具有then方法的对象或者根本不是对象；如果参数是一个原始值，或者是一个不具有then方法的对象，则promise。resolve方法返回一个新的promise对象，状态为resolved。4、不带有任何参数；如果不带有任何参数会直接返回一个resolved状态的promise对象。）<br>
9.allSettled方法：allSettled方法接收一组promise实例作为参数，包装成一个新的实例<br>
10.any方法：接收一组promise实例作为参数，只要有一个变为fulfilled状态，包装的实例就会变成fulfilled状态，如果所有的参数都变成rejected状态，就会变成rejected状态。</p>
<p>Promise对象只有三种状态：异步操作“未完成”（pending），异步操作“已完成”（resolved，又称fulfilled），异步操作“失败”（rejected）<br>
Promise对象有两个特点：1.对象的状态不受外界影响<br>
2.一旦状态改变，就不会再变，任何时候都可以得到这个结果<br>
使用注意事项：<br>
1.Promise构造函数内的同步代码立即执行<br>
2.回调函数参数resolve异步执行, 将结果作为参数传给then方法中的回调函数<br>
3. resolve只有第一次执行有效,状态不能二次改变<br>
4. then和catch如果有return, 返回的是一个全新的promise对象, 可以链式调用<br>
5. Promise构造函数只会执行一次, promise实例会保存resolve的状态,以后这个实例每次调用then都是返回一个这个状态, 若链式调用then,下一个则会打印undefined, res没有值...<br>
6. then中返回任意一个非 promise 的值都会被包裹成 promise 对象<br>
7. .then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环<br>
8. .then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透<br>
9. .then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。.catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。</p>
<pre><code>JS继承	
</code></pre>
<p>原型链继承（利用原型让一个引用类型继承另外一个引用类型的属性和方法）<br>
不足之处：①创建实例时不能传递参数。②所有属性都被实例共享<br>
1.prototype: 这是一个属性，在javascript中的每一个函数都会有一个prototype属性，普通的对象是没有这个属性的。构造函数的prototype属性的属性值就是该构造函数而创建的实例的原型。<br>
2.2. <strong>proto</strong>: 每一个JavaScript对象（除了null）都具有的一个属性，叫 <strong>proto</strong>,这个属性会指向该对象的原型<br>
3.3. constructor: 每一个原型都有一个constructor属性指向关联的构造函数。</p>
<p>借用构造函数继承:<br>
使用.call()和.apply()将父类构造函数引入子类函数，使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类<br>
(优点：可以传递参数，避免了引用类型共享<br>
缺点：方法都在构造函数中定义，每次创建实例都会创建一遍方法)</p>
<p>组合继承: 将原型链继承和构造函数继承这两种模式的优点组合在一起，通过调用父类构造，继承父类的属性并保留传参，然后通过将父类实例作为子类原型，实现函数复用。<br>
优点：融合了原型继承和构造函数继承，是JavaScript中常用的设计模式。<br>
缺点：调用两次父构造函数</p>
<p>原型式继承: 用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理,直接将某个对象直接赋值给构造函数的原型。</p>
<p>寄生式继承: 创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回构造函数。(就像给原型式继承外面套了个壳子，然后return出来)</p>
<p>寄生组合式继承: 通过借用构造函数传递参数和寄生模式实现继承属性，通过原型链的混成形式来继承方法，在函数中用apply或者call引入另一个构造函数，可传参。<br>
开发人员普遍认为寄生组合式继承是最理想的继承范式</p>
<p>JS闭包<br>
闭包是指有权访问另外一个函数作用域中的变量的函数(能够读取其他函数内部变量的函数)<br>
创建闭包最常见的方式函数作为返回值<br>
闭包的作用: <br>
1.让我们在全局作用域中访问局部变量<br>
2.让局部变量一直驻留在计算机的内存中	<br>
3.正常函数执行完毕后,里面声明的变量被垃圾回收处理掉,但是闭包可以让作用域里的变量,在函数执行完之后依旧保持没有被垃圾回收处理掉<br>
特性：<br>
①函数嵌套函数<br>
②函数内部可以引用函数外部的参数和变量<br>
③参数和变量不会被垃圾回收机制回收<br>
④</p>
<p>J S 跨域 （同源指 协议+域名+端口 三者相同）<br>
跨域解决方案<br>
1、 通过jsonp跨域<br>
2、 document.domain + iframe跨域（此方案仅限主域相同，子域不同的跨域应用场景）<br>
3、 location.hash + iframe（location.hash来进行传值）<br>
4、 window.name + iframe跨域<br>
5、 postMessage跨域<br>
6、 跨域资源共享（CORS）<br>
7、 nginx代理跨域<br>
8、 nodejs中间件代理跨域<br>
9、 WebSocket协议跨域<br>
10、动态创建script（因为script标签不受同源策略的限制）</p>
<p>单页面、多页面应用的区别<br>
单页面应用<br>
一个项目中只有一个完整的html页面，其他的都是部分的html片段组成。页面跳转只是局部刷新，不会重新加载全部资源。片段之间的切换快，比较容易实现转场动画。<br>
多页面应用<br>
一个项目是由多个完整的html页面组成，页面跳转所有的资源都要重新加载，页面之间的切换会出现卡顿空白的问题，不容易实现切换动画等。</p>
<p>vue-router有哪几种导航钩子？(路由守卫)<br>
第一种：是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。<br>
第二种：组件内的钩子 beforeRouteEnter、 beforeRouteUpdate、 beforeRouteLeave<br>
第三种：单独路由独享组件beforeEnter</p>
<p>vue组件的功能<br>
1.能够把页面抽象成多个相对独立的模块<br>
2.实现代码重用，提高开发效率和代码质量，使得代码易于维护<br>
Vue组件封装过程<br>
● 首先，使用Vue.extend()创建一个组件<br>
● 然后，使用Vue.component()方法注册组件<br>
● 接着，如果子组件需要数据，可以在props中接受定义<br>
● 最后，子组件修改好数据之后，想把数据传递给父组件，可以使用emit()方法</p>
<p>从输入URL到浏览器显示页面发生了什么</p>
<ol>
<li>输入网址</li>
<li>游览器查找域名的IP地址（DSN请求）</li>
<li>建立TCP链接（三次握手----客户端发送一个带有SYN标志的数据包给服务端，服务端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后客户端再回传一个带ACK标志的数据包，代表握手结束，连接成功）</li>
<li>游览器向WEB服务器发起Http请求（请求方法URI协议/版本、请求头(Request Header)、请求正文）</li>
<li>服务器端处理</li>
<li>关闭TCP链接（4次握手）</li>
<li>游览器解析资源</li>
<li>游览器布局渲染</li>
</ol>
<p>webpack可以看做是模块打包工具：它将各种静态资源（比如：JavaScript 文件，图片文件，样式文件等）视为模块，它能够对这些模块进行解析优化和转换等操作，最后将它们打包在一起，打包后的文件可用于在浏览器中使用。<br>
webpack优势<br>
webpack能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等，而且还具有以下几点优势：<br>
1.webpack 是以 commonJS 的形式来书写脚本的，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移<br>
2.能被模块化的不仅仅是 JS 了<br>
3.扩展性强，具有强大的插件（Plugin）接口，使用起来比较灵活，特别是支持热插拔的功能很实用<br>
4.可以将代码切割成不同的块（chunk），每个块包含一个或多个模块，块可以按需被异步加载，降低了初始化时间</p>
<p>H5 本地存储<br>
本地存储localstorage    本地存储sessionstorage<br>
离线缓存（application cache）  Web SQL IndexedDB<br>
本质区别：<br>
1、cookie：是网站为了标识用户身份而存储在本地终端上的数据（通常经过加密），数据始终在同源的http请求中携带（即使不需要），即会在浏览器和服务器间来回传递。<br>
2、sessionStorage和localStorage不会自动把数据发给服务器。<br>
存储大小：<br>
1、cookie数据一般不能超过4K。<br>
2、sessionStorage和localStorage一般可达5M左右。<br>
有效期限：<br>
1、cookie如果不设置期限，一般在浏览器关闭后就失效（自动删除）。<br>
2、sessionStorage也会在浏览器绘画窗口关闭后失效。<br>
3、localStorage没有过期时限，即使关闭浏览器或者重启电脑也不会失效（除非你手动删除）</p>
<p>函数防抖<br>
1.定义<br>
在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时；典型的案例就是输入搜索：输入结束后n秒才进行搜索请求，n秒内又输入的内容，就重新计时。<br>
2.实现原理<br>
函数防抖的基本思想是设置一个定时器，在指定时间间隔内运行代码时清楚上一次的定时器，并设置另一个定时器，知道函数请求停止并超过时间间隔才会执行。<br>
3.使用场景<br>
文本框输入搜索（连续输入时避免多次请求接口）</p>
<p>函数节流<br>
1.定义<br>
规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效； 典型的案例就是鼠标不断点击触发，规定在n秒内多次点击只有一次生效。<br>
2.实现原理<br>
其原理是用时间戳来判断是否已到回调该执行时间，记录上次执行的时间戳，然后每次触发 scroll 事件执行回调，回调中判断当前时间戳距离上次执行时间戳的间隔是否已经到达 规定时间段，如果是，则执行，并更新上次执行的时间戳，<br>
3.使用场景<br>
resize、scroll、mousemove等事件触发监听</p>
<p>link和@import区别<br>
1.从属关系区别<br>
@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。<br>
2.加载顺序区别<br>
加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。<br>
3.兼容性区别<br>
@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。<br>
4.DOM可控性区别<br>
可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。</p>
<p>团体项目协作<br>
切图自动压缩功能. 服务器在国内天然更快,<br>
权限管理:成员、团队权限分级和管理，保证了设计稿的准确性和安全性<br>
支持 Axure 等文档在线展示和共享: 还支持 Word / Excel / PPT / PDF 在线预览和共享<br>
支持手机上和微信中预览、操作和分享等</p>
<p>浅拷贝与深拷贝<br>
深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的<br>
浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。<br>
但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。<br>
深拷贝 : (JSON.parse(JSON.stringify())---- 递归方法)<br>
浅拷贝 : (Object.assign()、、Array.prototype.concat())</p>
<p>VUE----key的作用：<br>
1、元素的唯一性，diff方法中提高了匹配元素index的性能。有key时遍历key-index对象（快），无key时遍历旧Vnode（慢）。<br>
2、在元素list一直变化的情况下，key值设置唯一时，能很精确找到/找不到变更元素，key不唯一时，不能精确找到要匹配的元素。但对于是原地复用元素还是重新创建元素没有直接影响，只要新旧两个Vnode满足sameVnode，就会复用已有元素。</p>
<p>Git</p>
<p>keep-alive<br>
 keep-alive用来缓存组件,避免多次加载相应的组件,减少性能消耗，通过设置了keep-alive，可以简单理解为从页面1跳转到页面2后，然后后退到页面1，只会加载缓存中之前已经渲染好的页面1，而不会再次重新加载页面1，及不会再触发页面一种的created等类似的钩子函数，除非自己重新刷新该页面1。</p>
<p>vue的路由实现hash模式 和 history模式<br>
hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用 window.location.hash 读取。特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面<br>
history模式：history采用HTML5的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更</p>
<p>路由对象<br>
一个路由对象表示当前激活路由的状态信息，包含当前URL解析的信息，还有Url匹配到的路由记录<br>
路由对象是不可变的，每次成功的导航后都会产生一个新对象<br>
路由出现的多个地方：<br>
1.在组件内，即this.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal"> </mi><mi mathvariant="normal"> </mi><mn>2.</mn><mi mathvariant="normal">在</mi></mrow><annotation encoding="application/x-tex">route  
2.在</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord"> </span><span class="mord"> </span><span class="mord">2</span><span class="mord">.</span><span class="mord cjk_fallback">在</span></span></span></span>route观察者回调中<br>
3.route.match(location)的返回值</p>
<p>路由跳转<br>
编程式（ js跳转）this.$router.push()<br>
声明式（标签跳转）<router-link to=" "></router-link></p>
<p>v-if 和 v-show 区别<br>
相同点：都能实现元素的显示和隐藏<br>
不同点：<br>
1.v-if是真正的条件渲染，而v-show只是控制元素的dispaly属性，当需要做频繁切换显示隐藏时，推荐使用v-show，如果只是做一次，使用v-if；<br>
2.v-if能使用template，而v-show不能使用<br>
3.v-if有配套的v-else和v-else-if使用，而v-show没有</p>
<p>计算属性和 methods 有什么区别？<br>
--&gt;总结：computed计算属性的缓存原理在我们处理大量数据的时候使用可以大大提高效率，不必在数据没有发生改变的时候重新获取数据的值，可直接获取到结果，并且只执行绑定依赖的方法。methods里方法在依赖的值改变后，只有设置触发才会重新执行methods里相关的方法。<br>
计算属性方法调用不用加();methods需要；<br>
执行机制<br>
computed里的方法在初始化执行过后，只要任何值有更新，那么所有在computed计算属性里和其相关的值都会更新。<br>
methods只有在调用的时候才会执行对应的方法，不会自动同步数据。<br>
computed计算属性跟methods在内部的函数写起来没有什么区别，只是在调用的时候不一样</p>
<p>vue 中怎么操作 dom 元素(refs)<br>
vue 中怎么获取父组件的内容(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo>)</mo><mi>v</mi><mi>u</mi><mi>e</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">父</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">怎</mi><mi mathvariant="normal">么</mi><mi mathvariant="normal">调</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mo>(</mo></mrow><annotation encoding="application/x-tex">root)
vue 中父组件怎么调用子组件的方法(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">怎</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">调</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mopen">(</span></span></span></span>refs 选中子组件，直接调用方法名)<br>
当页面应用程序刷新之后怎么保证数据还是存在的？你怎么缓存页面数据(sessionStorage,localStorage)</p>
<p>vue-cli 工程技术集合介绍<br>
1.构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？<br>
vue.js：vue-cli工程的核心，主要特点是 双向数据绑定 和 组件系统。<br>
vue-router：vue官方推荐使用的路由框架。<br>
vuex：专为 Vue.js 应用项目开发的状态管理器，主要用于维护vue组件间共用的一些 变量 和 方法。<br>
axios（ 或者 fetch 、ajax ）：用于发起 GET 、或 POST 等 http请求，基于 Promise 设计。<br>
vuex等：一个专为vue设计的移动端UI组件库。创建一个emit.js文件，用于vue事件机制的管理。<br>
webpack：模块加载和vue-cli工程打包器</p>
<p>JS对象的属性检测<br>
Attr(attribute) in object：检测共有和私有<br>
hasOwnProperty：检测私有属性<br>
路由模式切换代码：<br>
export default new Router({<br>
//路由模式：hash(默认)，history模式<br>
    mode: 'history',<br>
//修改路由高亮样式，默认值为'router-link-active'<br>
    linkActiveClass: 'active'<br>
对于MVVM的了解?<br>
MVVM 是 Model-View-ViewModel的缩写,<br>
Model代表数据模型,View代表UI组件，ViewModel监听数据模型的改变和控制视图行为、处理用户交互，MVVM架构下Model和View本是没有直接联系的，ViewModel通过双向绑定,把View和Model连接了起来。<br>
双向绑定的原理？<br>
vue实现数据双向绑定主要采用的是：数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。<br>
常用的指令有哪些？<br>
在项目中如果我要进行判断我会使用 v-if，如果我需要遍历我会使用v-for，如果我需要绑定事件我会使用v-on，我会使用v-cloak 解决屏幕闪动，如果我需要让数据只绑定一次不进行更新我会使用v-once，如果我需要动态绑定一个或者多个特性我会使用v-bind<br>
v-if和v-show的区别？<br>
v-if：判断是否加载（渲染）；v-show：控制是否显影（display）</p>
<p>常用的修饰符？<br>
.trim          //清楚首位空白字符<br>
.stop              //阻止单击事件冒泡<br>
.prevent        //提交事件不再重新加载页面,<br>
.capture        //添加事件侦听器时使用事件捕获模式<br>
.self              //只当事件在该元素本身时触发回调（在其子元素上不触发）<br>
.once             //只触发一次事件<br>
...</p>
<p>在vue中我们用什么来监听数据的变化?<br>
Watch<br>
计算属性与方法、监听属性的比较?<br>
计算属性和方法: 页面只要重新渲染，方法都会执行一次，而计算属性只有在它的相关依赖发生改变时才会重新求值<br>
计算属性和监听属性:计算属性和监听属性相似都是在相关以来发生改变时才会重新求值, 当我有一些数据需要随着其它数据变动而变动时，我们很容易滥用watch,通常更好的做法是使用计算属性而不是命令式的 watch 回调<br>
什么是虚拟DOM,它和真实DOM相比优势在哪?<br>
虚拟DOM是描述真实DOM的js对象<br>
它的优势在于减少重排重绘,提升了计算机的性能<br>
对keep-alive的了解?<br>
keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。<br>
在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。<br>
include - 字符串或正则表达式。只有名称匹配的组件会被缓存。<br>
exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。<br>
max - 数字。最多可以缓存多少组件实例。<br>
(面试官可能会换个问法:我们如果将某个列表类组件内容滑动到第100条位置，然后我们在切换到一个组件后再次切换回到该组件，要让该组件的位置状态依旧保持在第100条列表处,我们需要怎么做)<br>
什么是单页面,它的优缺点是什么?<br>
概念：只有一个html页面，所以跳转的方式是组件之间的切换<br>
优点：跳转流畅；组件化开发；组件可复用；开发便捷<br>
缺点: 首屏加载过慢；seo优化不好; 不支持低版本的浏览器，最低只支持到IE9<br>
Vue-router的钩子函数? (路由守卫可由相应的函数实现)<br>
路由钩子函数有三种：<br>
1 : 全局钩子： beforeEach、 afterEach<br>
2 : 单个路由里面的钩子：  beforeEnter<br>
3 : 组件路由：beforeRouteEnter、 beforeRouteUpdate、 beforeRouteLeave</p>
<h2 id="怎么定义-vue-router-的动态路由-怎么获取传过来的值在-router-目录下的-indexjs-文件中对-path-属性加上-id使用-router-对象的-paramsid-获取-vue-router-的params和query传参的使用和区别query使用name来引入也可以传参使用path也可以而使用params传参只能使用name进行引入简单来说明一下router和route的区别router-是路由操作对象只写对象route-路由信息对象只读对象vuejs的两个核心是什么1数据驱动2组件系统localstorage和sessionstorage区别sessionstorage不在不同的浏览器窗口中共享即使是同一个页面localstorage-在所有同源窗口中都是共享的localstorage生命周期是永久这意味着除非用户显示在浏览器提供的ui上清除localstorage信息否则这些信息将永远存在-sessionstorage生命周期为当前窗口或标签页一旦窗口或标签页被永久关闭了那么所有通过sessionstorage存储的数据也就被清空了-v-for中key值的作用1高效的更新虚拟dom2区分虚拟dom中的节点hash模式和history模式hash模式在浏览器中符号以及后面的字符称之为hash用windowlocationhash读取history模式-history采用html5的新特性且提供了两个新方法pushstatereplacestate可以对浏览器历史记录栈进行修改以及popstate事件可监听到状态变更git的用法如果实在不会怎么办那就说对git的用法不太熟悉一般使用tortoisegitajax的使用1创建xmlhttprequest对象2创建一个新的http连接并指定该http请求的方法-url及验证信息3设置对异步传输对象状态监听4发送http请求5获取异步调用返回的数据6使用javascript和dom实现局部刷新">怎么定义 vue-router 的动态路由? 怎么获取传过来的值?<br>
在 router 目录下的 index.js 文件中，对 path 属性加上 /:id，使用 router 对象的 params.id 获取。<br>
Vue Router 的params和query传参的使用和区别?<br>
query使用name来引入也可以传参，使用path也可以,而使用params传参只能使用name进行引入<br>
简单来说明一下<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">和</mi></mrow><annotation encoding="application/x-tex">router和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord cjk_fallback">和</span></span></span></span>route的区别<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo>:</mo><mi mathvariant="normal">是</mi><mi mathvariant="normal">路</mi><mi mathvariant="normal">由</mi><mi mathvariant="normal">操</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">象</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">只</mi><mi mathvariant="normal">写</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">象</mi></mrow><annotation encoding="application/x-tex">router : 是路由操作对象，只写对象
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">路</span><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">操</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">象</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">只</span><span class="mord cjk_fallback">写</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">象</span></span></span></span>route : 路由信息对象，只读对象<br>
Vue.js的两个核心是什么?<br>
1.数据驱动2.组件系统<br>
localStorage和sessionStorage区别?<br>
sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的<br>
localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。<br>
sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了。<br>
v-for中key值的作用?<br>
1)高效的更新虚拟DOM<br>
2)区分虚拟DOM中的节点<br>
hash模式和history模式<br>
hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取<br>
history模式: history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件可监听到状态变更<br>
git的用法如果实在不会怎么办?<br>
那就说对git的用法不太熟悉,一般使用TortoiseGit<br>
Ajax的使用<br>
(1)创建<code>XMLHttpRequest</code>对象<br>
(2)创建一个新的<code>HTTP</code>连接,并指定该<code>HTTP</code>请求的方法、<code>URL</code>及验证信息.<br>
(3)设置对异步传输对象状态监听<br>
(4)发送<code>HTTP</code>请求.<br>
(5)获取异步调用返回的数据.<br>
(6)使用JavaScript和DOM实现局部刷新.</h2>
<p>1.localStorage的大小一般为5M 永久有效，除非你进行手动删除 不参与服务器端的通信。<br>
sessionStorage的大小一般为5M 在当前会话下有效，关闭页面或者浏览器时会被清空 不参与服务器端的通信。<br>
cookies的大小一般为4K 在设置的有效之前有效，当超过有效期便会失效 参与服务器端通信，每次都会携带http的头信息中<br>
es6的语义化标签:Header Footer Nav Article Aside Time Mark<br>
HTML语义化的理解：指对文本内容的结构化（内容语义化），选择合乎语义的标签（代码语义化），便于开发者阅读，维护和写出更优雅的代码的同时，让浏览器的爬虫和辅助技术更好的解析。<br>
2.Localstorage<br>
3.渐进增强:针对低版本浏览器进行构建页面,保证最基本的功能,然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的效果体验.<br>
优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
<p>4.Sass的优点:Sass的有点对于我来说我所用的觉得最突出的就是嵌套和变量 让我觉得非常方便和代码更明了<br>
事件委托就是把原本需要绑定的事件委托给父元素，让父元素负责事件监听。原理是DOM元素的事件冒泡， 减少注册时间,节省内存<br>
5.Jsonp cros proxy （协议域名端口相同，同源政策）<br>
Vue的优点<br>
1.只专注于视图层的轻量级的框架<br>
2.数据的双向绑定 优点是减少了dom操作<br>
3.组件化 和 响应式设计<br>
4.实现数据与结构的分离 高效轻便 易于浏览器的加载速度</p>
<ol start="10">
<li>
<p>监听可以监听除data以外的其他函数，计算只能计算data里的数据</p>
</li>
<li>
<p>GET把参数包含在URL中，POST通过request body传递参数<br>
GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
</li>
</ol>
<p>常用浏览器的内核:<br>
IE:trident内核;<br>
Firefox:gecko内核<br>
Safari:webkit内核<br>
Opera:以前是presto,现在改用Blink<br>
Chrome:Blink<br>
常见的兼容性问题<br>
1)不同了浏览器的标签的内边距和外边距有差异, 在公共样式写*{margin:0;padding:0}来解决；<br>
2）块级元素float后会存在横向margin的情况，(IE6显示比设置大),在float的元素上加overflow:hidden来解决<br>
3)设置较小高度的时候(10px以下),在IE6 IE7中高度超过了设置高度,给超过设置高度的标签上加overflow:hidden<br>
3. HTML5 为什什么只需要写 <!DOCTYPE HTML>？HTML5有哪些新特性、移 除了了那些元素？如何处理理HTML5新标签的浏览器器兼容问题？如何区分 HTML 和HTML5？</p>
<!DOCTYPE HTML>可以告知浏览器以何种规范解析页面,
<p>H5的新特性1)语义标签例如<nav><footer><header>等;2)视频和音频<audio><video>3)canvas绘图4)getlocation获取位置等<br>
移除了basefont,big,center,frame等<br>
可以从文档类型声明上来区分;可以从结构语义上来区分;</p>
<p>css引入的方式有<br>
外部样式 link<br>
外部导入 import<br>
内部样式 <style></style><br>
行内样式 <div style=""></div><br>
Link和@import的区别:<br>
1：link是XHTML标签,@import属于CSS<br>
2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。<br>
3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。<br>
4：link支持使用Javascript控制DOM去改变样式；而@import不支持。</p>
<p>CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和 important哪个优先级高?<br>
选择器:Id选择器,类选择器,标签选择器,相邻选择器,子选择器,后代选择器,伪类选择器等<br>
可继承的属性:font-size,font-family,color等<br>
优先级按照就近原则,样式定义最近优先,而载入的样式则以最后载入的为准.<br>
!important优先级高<br>
6. web标准：结构(html)+表现(css)+行为(js)<br>
7. 基本语句构成是:选择器{属性:值;属性:值}<br>
8. string object number function boolean undefined<br>
强制类型的转换:parseInt paresFloat Number()<br>
隐式类型的转换: ==<br>
split()是将字符串切割成数组,而join()则是将数据转换为字符串<br>
11. get请求会把参数包含在URL中,而post则通过request body传参,另外get请求会产生一个TCP数据包,而post则会产生两个TCP数据包<br>
12. 我一般用JSON.parse()<br>
13. 如何进行网站性能优化<br>
　　content方向：<br>
　1. 减少HTTP请求：合并文件、CSS精灵、inline Image<br>
　　2. 减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询<br>
　　3. 避免重定向：多余的中间访问<br>
　　4. 使Ajax可缓存<br>
　　5. 非必须组件延迟加载<br>
　　6. 未来所需组件预加载<br>
　　7. 减少DOM元素数量<br>
　　8. 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量<br>
　　9. 减少iframe数量<br>
　　10. 减少404页面<br>
　　Server方面<br>
　1. 使用CDN<br>
　　2. 添加Expires或者Cache-Control响应头<br>
　　3. 对组件使用Gzip压缩<br>
　　4. 配置ETag<br>
　　5. Flush Buffer Early<br>
　　6. Ajax使用GET进行请求<br>
　　7. 避免空src的img标签<br>
　　Cookie方面<br>
　　1. 减小cookie大小<br>
　　2. 引入资源的域名不要包含cookie<br>
　　css方面<br>
　　1. 将样式表放到页面顶部<br>
　　2. 不使用CSS表达式<br>
　　3. 使用不使用@import<br>
　　4. 不使用IE的Filter<br>
　　Javascript方面<br>
　1. 将脚本放到页面底部<br>
　　2. 将javascript和css从外部引入<br>
　　3. 压缩javascript和css<br>
　　4. 删除不需要的脚本<br>
　　5. 减少DOM访问<br>
　　6. 合理设计事件监听器<br>
　　图片方面</p>
<ol>
<li>优化图片：根据实际颜色需要选择色深、压缩<br>
　　2. 优化css精灵<br>
　　3. 不要在HTML中拉伸图片<br>
　　4. 保证favicon.ico小并且可缓存</li>
<li>vue + webpack 前端性能优化<br>
#优化一：vue-router路由懒加载:  vue 是单页面应用，使用webpcak打包后的文件很大，会使进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。运用懒加载后，就可以按需加载页面，提高用户体验。<br>
#优化二: 用image-webpack-loader 来压缩图片<br>
#优化三: 打包后的js过大，将js打包多个文件<br>
#优化四：去掉不必要的插件，按需引入<br>
#优化五：gzip压缩<br>
#优化六：服务器缓存<br>
this的四种指向<br>
a.如果是一般函数,this指向全局对象window;<br>
b.在严格模式下&quot;use strict&quot;,为undefined.<br>
c.对象的方法里调用,this指向调用该方法的对象.<br>
d.构造函数里的this,指向创建出来的实例.</li>
<li>ajax常见的状态码<br>
1XX 信息性状态码 服务器正在处理请求<br>
2XX 成功状态码   请求已正常处理完毕<br>
3XX 重定向状态码 需要进行额外操作以完成请求<br>
4XX 客户端错误状态码 客户端原因导致服务器无法处理请求<br>
5XX 服务端状态码  服务器原因导致处理请求出错</li>
<li>严格模式 有什么 特点 ? （3-4条）<br>
1.严格模式下不可以使用with（）<br>
2.严格模式下，变量必须声明<br>
3.严格模式下，this默认是undefined<br>
4.严格模式下，为只读变量和不可扩展对象赋值会报错<br>
5.严格模式下，函数的形参不可以同名<br>
6.严格模式下，不可以使用caller和arguments的属性，会报错</li>
</ol>
<p>data(){return } 为什么要return<br>
不使用return包裹的数据会在项目的全局可见,会造成变量污染;使用return包裹后数据中变量只在当前组件中生效,不会影响其他组件<br>
chrome49跨域<br>
49之前在属性页面中的目标输入框里加上   --disable-web-security <br>
49之后:<br>
1.在电脑上新建一个目录，例如：C:\MyChromeDevUserData<br>
2.在属性页面中的目标输入框里加上   --disable-web-security --user-data-dir=C:\MyChromeDevUserData，--user-data-dir的值就是刚才新建的目录。<br>
3.点击应用和确定后关闭属性页面，并打开chrome浏览器。<br>
http和https的区别:<br>
https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。<br>
http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>
http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>
http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。<br>
真数组和伪数组的区别?<br>
真数组能使用数组的拓展方法,伪数组不行;<br>
真数组的长度是可变的,伪数组的不行<br>
伪数组转真数组：<br>
1var newArr=[].slice.call(obj)<br>
2var newArr=Array.from(obj),ES6的新语法<br>
3var newArr=[...obj]<br>
Ui库和自己写的代码冲突的时候<br>
增加权重,<br>
在UI库底层样式去改样式</p>
<p>节流和防抖?<br>
函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时    (点赞,获取验证码)<br>
函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数     (滚动条事件)<br>
Vue的生命周期<br>
beforeCreate : 实例组件刚创建,元素DOM和数据还没有初始化<br>
created:数据data已经初始化完成,方法可以调用,但是DOM未渲染<br>
beforeMount:DOM未完成挂载,数据也未完成初始化<br>
mounted:数据和DOM都挂载完成<br>
beforeUpdate: 页面数据改变触发,但是数据还是原来的数据<br>
Updated:页面数据改变触发,数据是更新之后的数据<br>
beforeDestroy:组件销毁之前执行,可以在这里面清楚定时器<br>
Destroyed:个人感觉跟beforeDestroy<br>
position的值， relative和absolute分别是相对于谁进行定位的？<br>
§ absolute :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。<br>
§ fixed （老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。<br>
§ relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。<br>
§ static 默认值。没有定位，元素出现在正常的流中<br>
§ sticky 生成粘性定位的元素，容器的位置根据正常文档流计算得出<br>
-------------------------------------------------------------------------------------------自定义组件的方法<br>
答：第一步：在components目录新建你的组件文件（smithButton.vue），script一定要export default {<br>
第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’<br>
第三步：注入到vue的子组件的components属性上面,components:{smithButton}<br>
第四步：在template视图view中使用，<smith-button>  </smith-button><br>
问题有：smithButton命名，使用的时候则smith-button。<br>
实现垂直定位居中的方法?<br>
1.已知宽高<br>
a)子元素绝对定位 上下左右0+margin auto<br>
b)子元素绝对定位 上下50% margin-top -高度的一半 margin-left -宽度的一半<br>
2.未知宽高<br>
a)子元素相对定位 左上50% transform：translate（-50%，-50%）<br>
b)父元素 display：flex justify-content:center align-items:center<br>
c)父元素 display: table-cell text-align:center vertical-align:middle<br>
Jq的自定义方法?<br>
jQuery.fn.extend(object);    给jQuery对象添加方法<br>
jQuery.extend(object);     为扩展jQuery类本身.为类添加新的方法。<br>
vue中自定义指令?<br>
Vue自定义指令和组件一样存在着全局注册和局部注册两种方式。先来看看注册全局指令的方式，通过 Vue.directive( id, [definition] ) 方式注册全局指令，第二个参数可以是对象数据，也可以是一个指令函数。<br>
注：使用指令时必须在指名名称前加前缀v-，即v-指令名称<br>
1.钩子函数<br>
一个指令定义对象可以提供如下几个钩子函数 (均为可选)：<br>
bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。<br>
inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。<br>
update：被绑定元素所在模板更新时调用，但是可能发生在其子 VNode 更新之前。<br>
componentUpdated：被绑定元素所在模板完成一次更新周期时调用。<br>
unbind：只调用一次，指令与元素解绑时调用。<br>
项目中图片优化?<br>
小的图片用精灵图,大的有专门的图片服务器<br>
当数据发生变化的时候，VUE怎么更新节点？<br>
Vue采用的是虚拟DOM进行局部刷新，更新节点的过程中采用了diff算法，diff的过程就是调用patch函数，比较新旧节点，一边比对一边给真实DOM打补丁。<br>
Amd,cmd,commonjs,es6对比<br>
1)AMD-异步模块定义 是RequireJS在推广过程中对模块定义的规范化产出是一个概念,依赖前置,在参数里面引入js文件<br>
2)Cmd-是同步模块定义 是SeaJS在推广过程中对模块定义的规范化产出,依赖就近,什么时候用什么时候require<br>
3)CommonJS是通过module.exports定义的,在前端浏览器里面并不支持,module.exports通过node.js后端使用的,<br>
4)ES6特性,模块化—export/import对模块导出导入<br>
export和export default区别:1在一个文件或模块中，export可以有多个，export default仅有一个2 export 导出对象引入时需要用{}而export default<br>
null和undefined的区别:<br>
null标示没有对象,即标示这里不应该有值;undefined表示缺少值,即本来应该有值但是没有被定义<br>
闭包?<br>
闭包就是函数套函数<br>
用处:1可以读取到函数内部的变量,2让变量始终保持在内存中<br>
坏处:1 滥用闭包可能导致内存泄漏,<br>
原型链?<br>
对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。<br>
深拷贝和浅拷贝?<br>
浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。<br>
深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象<br>
浅拷贝的实现方式有:object.assign()(obj只有一层时是深拷贝)、Array.prototype.concat()<br>
深拷贝的实现方式有:json.parse(json.stringfy())、手写递归方法(其原理是遍历数组和对象直到里面都是基本的数据类型,然后再去复制,就完成了深拷贝)<br>
div+css布局有什么优点?<br>
(1)可以实现html结构和css表现分离,使html文档结构更清晰、可读性高、加载速度更快<br>
(2)提高了样式表的复用性和设计的灵活性<br>
(3)浏览器会缓存静态文件如css文件,有利于提高网站的性能和SEO评估<br>
(4)提高代码的可维护性<br>
继承?<br>
自己有的用自己的 自己没有的找别人要<br>
1构造函数的 原型(prototype)</p>
<p>2普通对象      内部原型(构造原型)(<strong>proto</strong>)</p>
<ol start="3">
<li>
<p>普通函数      指向继承(call/apply)  他们的区别主要是第二个参数 call接的是参数列表而apply接的是参数数组</p>
</li>
<li>
<p>es5对象继承   创造继承 (Object.create)</p>
</li>
<li>
<p>es6类的继承   继承(延生)(class  extends)</p>
</li>
</ol>
<p>json和jsonp?<br>
json是一种数据格式,而jsonp是解决跨域的一种方法<br>
npm和yarn的区别?<br>
npm是按照队列去执行（上一个没安装完，下一个就5等着）<br>
yarn  并行安装（同步执行所有的）和离线模式（如果之前安装过，可以在缓存里面读取），速度会快一些<br>
开启动画加速?<br>
当我们用到动画的时候,如果用 top left这样的会触发浏览器的重绘,这时候我们使用transform:translate()来代替就会避免了浏览器的重绘,提高了性能达到加速的效果<br>
常见的css和js的兼容?<br>
Css兼容:<br>
1.hack:让css代码兼容IE浏览器，呈现出和其他厂商浏览器相同的UI界面。1)属性名前缀 #color:red IE6 <em>color:red IE7 2)浏览器前缀 -webkit- (safari Chrome) -moz- (Firefox) -ms- (IE) -o- (Opera)<br>
2.内外边距不同,</em>{margin:0;padding:0}<br>
3.浮动有横向marign的时候ie产生的比设置的大 , 给浮动的元素加display:inline<br>
4.设置较小高度的时候(一般小于10px),在IE6 IE7会超出设置高度,在超出的标签设置overflow:hidden<br>
JS兼容:<br>
1.滚动条 在Chrome中默认滚动条是body的可以通过body.scrolltop来取,而火狐等浏览器认为滚动条是HTML的<br>
var st=document.body.scrollTop || document.documentElement.scrollTop<br>
2.监听addEventListener(事件名，处理函数，布尔值:布尔值为false则为冒泡,true则为捕获) IE: attachEvent(事件名，处理函数)<br>
3.移除监听 removeEventListener(事件名,处理函数) IE:detachEvent(事件名,处理函数)<br>
4.阻止冒泡 W3C: event:stopPropagation() IE 678 :event:cancelBubble=true<br>
Vue中的template是什么?<br>
template是模板占位符,可以帮助我们包裹元素<br>
动态组件和异步组件?<br>
动态组件使用is来切换不同的组件,而异步组件类似于路由的按需加载,用的时候import,<br>
Eg:<br>
响应式设计和自适应设计?<br>
响应式设计（RWD）：建立一个网页，通过CSS Media Query，Content - Based Breakpoint等技术来改变网页的大小适应不同分辨率的屏幕<br>
自适应设计（AWD）：为不同类别的设备建立不同的网页，检测到设备分辨率大小后调用相应的网页。<br>
nth-of-type和nth-child区别?<br>
:nth-of-type(n) : 在同一父元素下, 同类子元素第n个<br>
:nth-child(n) : 在同一父元素下，所有子元素第n个<br>
理解和使用Promise.all和Promise.race?<br>
Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。<br>
Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS Web API]]></title>
        <id>https://chenggr.github.io/post/js-web-api/</id>
        <link href="https://chenggr.github.io/post/js-web-api/">
        </link>
        <updated>2022-03-22T06:50:47.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>JS Web API notes</p>
</blockquote>
<p>JS基础知识，规定语法（ECMA 262 标准）<br>
JS Web API，网页操作的API（W3C 标准）</p>
<ul>
<li>DOM</li>
<li>BOM</li>
<li>事件绑定</li>
<li>ajax</li>
<li>存储</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[javascript basic knowledge notes]]></title>
        <id>https://chenggr.github.io/post/javascript-notes/</id>
        <link href="https://chenggr.github.io/post/javascript-notes/">
        </link>
        <updated>2022-03-10T07:18:33.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>js基本知识笔记</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>js基本知识笔记</p>
</blockquote>
<!--more-->
<h1 id="常见值类型">常见值类型</h1>
<pre><code class="language-javascript">let a // undefined
const s = 'abc'
const n = 100
const b = true
const s = Symbol('s')
</code></pre>
<h1 id="常见引用类型">常见引用类型</h1>
<pre><code class="language-javascript">const obj = { x: 100 }
const arr = ['a', 'b', 'c']

const n = null // 特殊引用类型，指针指向为空的地址 

// 特殊应用类型，但不用于存储数据，所以没有“拷贝、复制函数”这一说
function fn() {}
</code></pre>
<h1 id="值类型和引用类型的区别">值类型和引用类型的区别</h1>
<pre><code class="language-javascript">const obj1 = { x: 100, y:200 }
const obj2 = obj1
let x1 = obj1.x
obj2.x = 101
x1 = 102
console.log(obj1.x)   // { x: 101 }
</code></pre>
<h1 id="typeof">typeof</h1>
<pre><code class="language-javascript">let a                           typeof a // 'undefined'
const str = 'abc'               typeof str // 'string'
const n = 100                   typeof n // 'number'
const b = true                  typeof b // 'boolean'
const s = Symbol('s')           typeof s // 'symbol' 
</code></pre>
<pre><code class="language-javascript">// 能判断函数
typeof console.log              // 'function'
typeof function () {}           // 'function'

// 能识别引用类型（不能再继续识别）
typeof null             // 'object'
typeof ['a', 'b']       // 'object'
typeof { x: 100 }       // 'object'
</code></pre>
<h1 id="深拷贝">深拷贝</h1>
<pre><code class="language-javascript">/**
 * 深拷贝
 */

const obj1 = {
    age: 20,
    name: 'xxx',
    address: {
        city: 'beijing'
    },
    arr: ['a', 'b', 'c']
}

const obj2 = deepClone(obj1)
obj2.address.city = 'shanghai'
obj2.arr[0] = 'a1'
console.log(obj1.address.city)
console.log(obj1.arr[0])

/**
 * 深拷贝
 * @param {Object} obj 要拷贝的对象
 */
function deepClone(obj = {}) {
    if (typeof obj !== 'object' || obj == null) {
        // obj 是 null ，或者不是对象和数组，直接返回
        return obj
    }

    // 初始化返回结果
    let result
    if (obj instanceof Array) {
        result = []
    } else {
        result = {}
    }

    for (let key in obj) {
        // 保证 key 不是原型的属性
        if (obj.hasOwnProperty(key)) {
            // 递归调用！！！
            result[key] = deepClone(obj[key])
        }
    }

    // 返回结果
    return result
}
</code></pre>
<h1 id="原型和原型链">原型和原型链</h1>
<pre><code class="language-javascript">// 父类
class People {
    constructor(name) {
        this.name = name
    }
    eat() {
        console.log(`${this.name} eat something`)
    }
}

// 子类
class Student extends People {
    constructor(name, number) {
        super(name)
        this.number = number
    }
    sayHi() {
        console.log(`姓名 ${this.name} 学号 ${this.number}`)
    }
}

// 子类
class Teacher extends People {
    constructor(name, major) {
        super(name)
        this.major = major
    }
    teach() {
        console.log(`${this.name} 教授 ${this.major}`)
    }
}

// 实例
const xialuo = new Student('夏洛', 100)
console.log(xialuo.name)
console.log(xialuo.number)
xialuo.sayHi()
xialuo.eat()

// 实例
const wanglaoshi = new Teacher('王老师', '语文')
console.log(wanglaoshi.name)
console.log(wanglaoshi.major)
wanglaoshi.teach()
wanglaoshi.eat()
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://chenggr.github.io/post-images/1646897786563.jpg" alt="" loading="lazy"></figure>
<h2 id="原型关系">原型关系</h2>
<pre><code>- 每个 class 都有显示原型 prototype
- 每个实例都有隐式原型 __proto__
- 实例的 __proto__ 指向对应 class 的 prototype
</code></pre>
<h2 id="基于原型的执行规则">基于原型的执行规则</h2>
<pre><code>- 获取属性 xialuo.name 或执行方法 xialuo.sayhi() 时
- 先在自身属性和方法寻找
- 如果找不到则自动 __proto__ 中查找
</code></pre>
<h2 id="原型链">原型链</h2>
<pre><code class="language-javascript">console.log( Student.prototype.__proto__ )
console.log( People.prototype )
console.log( People.prototype === Student.prototype.__proto__ )
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://chenggr.github.io/post-images/1646898516562.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://chenggr.github.io/post-images/1646898904237.jpg" alt="" loading="lazy"></figure>
<h1 id="作用域和闭包">作用域和闭包</h1>
<h2 id="作用域和自由变">作用域和自由变</h2>
<pre><code class="language-javascript">// 自由变量
当前作用域没有定义的变量，但是使用了，需去查找
</code></pre>
<pre><code class="language-javascript">let i, a;
for (i = 0; i &lt; 10; i++) {
  a = document.createElement(&quot;a&quot;);
  a.innerHTML = i + &quot;&lt;br&gt;&quot;;
  a.addEventListener(&quot;click&quot;, function (e) {
    e.preventDefault();
    alert(i);
  });
  document.body.appendChild(a);
}
// 10
</code></pre>
<h2 id="闭包">闭包</h2>
<blockquote>
<p>在函数定义的地方，向上级作用域查找</p>
</blockquote>
<pre><code class="language-javascript">// 函数作为返回值
function create() {
    const a = 100
    return function () {
        console.log(a)
    }
}

const fn = create()
const a = 200
fn() // 100

// 函数作为参数被传递
function print(fn) {
    const a = 200
    fn()
}
const a = 100
function fn() {
    console.log(a)
}
print(fn) // 100

// 所有的自由变量的查找，是在函数定义的地方，向上级作用域查找
// 不是在执行的地方！！！
</code></pre>
<h2 id="this">this</h2>
<p>this在执行的时候确定的</p>
<ul>
<li>作为普通函数</li>
<li>使用call apply bind</li>
<li>作为对象方法被调用</li>
<li>在 class 方法中调用</li>
<li>箭头函数</li>
</ul>
<pre><code class="language-javascript">function fn1() {
    console.log(this)
}
fn1()   // window

fn1.call({ x: 100 }) // { x: 100 }

const fn2 = fn1.bind({ x: 200 })
fn2()   // { x: 200 }
</code></pre>
<pre><code class="language-javascript">const zhangsan = {
    name: '张三',
    sayHi() {
        // this 即当前对象
        console.log(this)
    },
    wait() {
        setTimeout(function() {
            // this === window
            console.log(this)
        })
    }
}
const zhangsan = {
    name: '张三',
    sayHi() {
        // this 即当前对象
        console.log(this)
    },
    waitAgain() {
        setTimeout(() =&gt; {
            // this 即当前对象
            console.log(this)
        })
    }
}
</code></pre>
<pre><code class="language-javascript">class People {
    constructor(name) {
        this.name = name
        this.age = 20
    }
    sayHi() {
        console.log(this)
    }
}
const zhangsan = new People('张三‘)
zhangsan.sayHi()    // zhangsan 对象
</code></pre>
<h2 id="手写bind">手写bind</h2>
<pre><code class="language-javascript">// 模拟 bind
Function.prototype.bind1 = function () {
    // 将参数拆解为数组
    const args = Array.prototype.slice.call(arguments)

    // 获取 this（数组第一项）
    const t = args.shift()

    // fn1.bind(...) 中的 fn1
    const self = this

    // 返回一个函数
    return function () {
        return self.apply(t, args)
    }
}

function fn1(a, b, c) {
    console.log('this', this)
    console.log(a, b, c)
    return 'this is fn1'
}

const fn2 = fn1.bind1({x: 100}, 10, 20, 30)
const res = fn2()
console.log(res)
</code></pre>
<h2 id="闭包的应用">闭包的应用</h2>
<pre><code class="language-javascript">// 闭包隐藏数据，只提供 API
function createCache() {
    const data = {} // 闭包中的数据，被隐藏，不被外界访问
    return {
        set: function (key, val) {
            data[key] = val
        },
        get: function (key) {
            return data[key]
        }
    }
}

const c = createCache()
c.set('a', 100)
console.log( c.get('a') )
</code></pre>
<h1 id="异步和单线程">异步和单线程</h1>
<ul>
<li>异步和同步的区别</li>
<li>异步的应用场景：网络请求&amp;定时任务</li>
<li>Promise 解决 callback hell</li>
</ul>
<pre><code class="language-javascript">function loadImg(src) {
    const p = new Promise(
        (resolve, reject) =&gt; {
            const img = document.createElement('img')
            img.onload = () =&gt; {
                resolve(img)
            }
            img.onerror = () =&gt; {
                const err = new Error(`图片加载失败 ${src}`)
                reject(err)
            }
            img.src = src
        }
    )
    return p
}

const url1 = 'https://img.mukewang.com/5a9fc8070001a82402060220-140-140.jpg'
const url2 = 'https://img3.mukewang.com/5a9fc8070001a82402060220-100-100.jpg'

loadImg(url1).then(img1 =&gt; {
    console.log(img1.width)
    return img1 // 普通对象
}).then(img1 =&gt; {
    console.log(img1.height)
    return loadImg(url2) // promise 实例
}).then(img2 =&gt; {
    console.log(img2.width)
    return img2
}).then(img2 =&gt; {
    console.log(img2.height)
}).catch(ex =&gt; console.error(ex))

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[interview questions]]></title>
        <id>https://chenggr.github.io/post/interview-questions/</id>
        <link href="https://chenggr.github.io/post/interview-questions/">
        </link>
        <updated>2022-03-10T02:57:41.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>Summary of interview questions for Han Qi</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>Summary of interview questions for Han Qi</p>
</blockquote>
<!--more-->
<h1 id="vue">VUE</h1>
<h4 id="vue的生命周期是什么"><strong>vue的生命周期是什么</strong></h4>
<pre><code>vue每个组件都是独立的，每个组件都有一个属于它的生命周期，从一个组件创建、数据初始化、挂载、更新、销毁，这就是一个组件所谓的生命周期。
beforeCreate() 在实例创建之间执行，数据未加载状态
created() 在实例创建、数据加载后，能初始化数据，dom渲染之前执行
beforeMount() 虚拟dom已创建完成，在数据渲染前最后一次更改数据
mounted() 页面、数据渲染完成，真实dom挂载完成
beforeUpadate() 重新渲染之前触发
updated() 数据已经更改完成，dom 也重新 render 完成,更改数据会陷入死循环
beforeDestory() 和 destoryed() 前者是销毁前执行（实例仍然完全可用），后者则是销毁后执行
</code></pre>
<h4 id="为什么要有生命周期">为什么要有生命周期</h4>
<pre><code>因为：VUE中MVVM思想、虚拟DOM等机制
所以：需要钩子函数/生命周期，从而方便开发、提升性能等
</code></pre>
<h4 id="你说下vue路由模式有几种">你说下vue路由模式有几种？</h4>
<pre><code>常用路由模式有2个，分别为hash和history  直接修改路由构造函数加个mode键即可
准备说有3个，hash/history用于客户端，abstract用户服务端
</code></pre>
<h4 id="你说下vue路由原理">你说下vue路由原理？</h4>
<pre><code>vue路由是基于SPA单页面应用思想去开发的
利用BOM API 来使用
hash模式    通过 BOM  location对象的hash属性来改变路由
history模式   通过BOM history对象的pushState属性来改变路由
</code></pre>
<h4 id="那你说下什么是单页面应用spa优缺点如何选择">那你说下什么是单页面应用SPA优缺点，如何选择</h4>
<pre><code>SPA优点：1.切换速度快、减少HTTP请求、便于加特效
2.前后端分离便于后期扩展
3.转场动画，也就是一个页面切换另一个页面  transition
缺点：1. 不利于seo优化
	2. 初次加载耗时（注：这时候可能问vue首屏加载慢如何解决 见优化部分答案）SPA缺点：不利于SEO优化（就是百度可以搜到你）
MPA多页面的好处
概念：有多个页面，跳转方式是页面之间的跳转
优点：首屏加载快；seo优化好
缺点：跳转较慢；相对复杂，没有实现前后端分离
如何选择
根据项目需求，老板没有明确说直接用vue脚手架创建框架就行，
但是老板说需要seo优化则通过：Vue.js 服务器端渲染（nuxt.js）
</code></pre>
<h4 id="声明式导航和">声明式导航和</h4>
<pre><code>写法不一样,声明式导航是写在组件的template中,通过router-link来触发,
编程式导航写在js函数中,通过this.$router.push(xxx)来触发路径
</code></pre>
<h4 id="vuex是什么怎么使用哪种功能场景使用它">vuex是什么？怎么使用？哪种功能场景使用它？</h4>
<pre><code>就是用来存放所有组件数据的仓库,也就是组件状态管理工具
state:存储数据；
mutations:更新数据的方法；
actions:调用mutations方法，更新state数据；
getters:对state中的数据进行预处理；
vuex 的作用
￼
实现所有组件相互通信，数据共享
组件之间需要相互通信时，例如购物车购买数量、登录信息等
什么是计算属性和侦听器
￼
计算属性：普通方法的升级版，有缓存
怎么用：在data同级定义computed对象来声明计算属性、调用不加小括号
侦听器：用来监控模型数据变化
 怎么用：在data同级定义watch对象声明侦听器、方法名就是data中的键、不能调用
 如何选：
  1 事件 和 封装减少视图代码冗余便于后期维护 先用普通方法
  2 上述多次执行耗时 计算属性优化
3 当需要监控模型数据改变 使用侦听器。例如：搜索、全选全不选等等
什么是混入
￼
是什么：vue中提供的解决组件代码冗余的技术，可以提起相同的普通方法、模型数据等
怎么用：Vue.mixin 或 mixins键来定义
实战用：后期项目的跳转、返回上一页、提示信息等等
什么是vue组件
￼
是什么：用来代替传统HTML的一种解决方案、里面还是HTML、JS、CSS
好处：倡导模块化、便于后期相互调用、从而减少代码冗余、方便维护
怎么用： Vue.component(组件名，{template, methods, data, ....})
组件通信工作流
￼
父传子： 子组件通过 props 属性，绑定父组件数据，实现双方通信
子传父：    将父组件的事件在子组件中通过 $emit 触发
兄弟  ：1 创建bus总线 全局仓库 
        2 传递数据 bus.$emit
         3 接受数据 bus.$on
vue中的事件修饰符
￼
事件修饰符：.stop、.prevent、.once等
键盘修饰符：.enter、.ctrl .enter等
什么是路由懒加载
￼
路由懒加载是通过异步的方式来加载对应的路由组件，提高页面相应速度
vue的路由使用步骤？
￼
1.下载vue-router路由模块；
2.创建路由对象；
3.配置路由规则；
4.将路由对象注册为vue实例对象的成员属性；
http协议状态码301和302的区别
￼
301 redirect: 301 代表永久性转移(Permanently Moved)
302 redirect: 302 代表暂时性转移(Temporarily Moved )
302重定向只是暂时的重定向，浏览器会抓取新的内容而保留旧的地址，因为服务器返回302，所以，搜索浏览器认为新的网址是暂时的。
301重定向是永久的重定向，浏览器在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址
谈谈你对虚拟DOM的理解？
￼
就是用JS 的Object对象模拟DOM中的节点，然后再通过特定的render方法将其渲染成真实的DOM节点，因为浏览器工作机制，通过虚拟DOM提升性能。
回流重绘
￼
回流：重新布局
重绘：改变元素属性样式
谈谈你对diff算法的理解？
￼
diff算法是虚拟DOM技术的产物，核心思想是通过新旧虚拟DOM做对比，（即diff），将变化的地方更新在真实的DOM上，也需要diff高效执行对比的过程，从而降低时间复杂度为O(n).
步骤一：用JS对象模拟DOM树
步骤二：比较新旧虚拟DOM树的差异
步骤三：把差异应用到真正的DOM树上
v-for中有key值和没有key值的区别
￼
它们区别主要在于虚拟DOM的复用，绑定key可以更好的复用，避免重复渲染
fetch、axios区别
￼
相同点：都是基于promise封装的HTTP库
不同点:1 fetch官方 axios第三方
    2 axios更强例如拦截器、而fetch需要自己封装等
请谈谈对http的理解	
￼
HTTP：超文本传输协议，主要由request请求 和response响应 组成，规定了计算机之间如何相互通信
项目开发中常遇到的
请求方式常用的有get、post、put、delete
HTTP状态码：...
请求头：expire、gzip、content-type等
HTTP状态码
￼
100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
200 OK 请求成功
201 Created 请求成功并且服务器创建了新的资源
202 Accepted 服务器已接受请求，但尚未处理
301 Moved Permanently 永久性重定向。
302 Found 临时性重定向。
303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
304 Not Modified 浏览器缓存
400 BadRequest 参数有误。
401 Unauthorized 密码错误。
403Forbidden 没有权限。
404 NotFound 文件不存在。
500 InternalServer Error 服务器错误。
503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
vue实现数据双向绑定的原理
￼
采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调
Created与Mounted的区别
￼
Created：在dom渲染之前调用，通常初始化某些属性值，然后再渲染成视图。
Mounted：在dom渲染之后调用，初始化页面完成后，再对dom节点进行一些需要的操作。
vue中mounted和updated这两个生命周期怎么运行的
￼
mounted 页面首次渲染完毕时触发
updated 模型数据更新时候触发
vue首屏加载过慢如何解决
￼
1、路由懒加载（也就是要的时候的时候进行加载。
2、UI组件按需加载
3、webpack启用gzip压缩
什么是JSX
￼
JSX即JavaScript XML，是JS的一种扩展语言。
解释单向数据流和双向数据绑定
￼
单向数据流： 顾名思义，数据流是单向的。数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷。缺点就是写起来不太方便。要使UI发生变更就必须创建各种 action 来维护对应的 state；
双向数据绑定：数据之间是相通的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的场景下，会简化大量与业务无关的代码。缺点就是无法追踪局部状态的变化，增加了出错时 debug 的难度。
Vue 如何去除url中的
￼
vue-router 默认使用 hash 模式，所以在路由加载的时候，项目中的 url 会自带 #。如果不想使用 #， 可以使用 vue-router 的另一种模式 history。
需要注意的是，当我们启用 history 模式的时候，由于我们的项目是一个单页面应用，所以在路由跳转的时候，就会出现访问不到静态资源而出现 404 的情况，这时候就需要服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面(重定向)。
和
router的区别
￼
$router 为 VueRouter 实例，想要导航到不同 URL，则使用 $router.push 方法$route 为当前 router 跳转对象里面可以获取 name 、 path 、 query 、 params 等
NextTick 是做什么的
￼
$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM
当你修改了data的值然后马上获取这个dom元素的值，是不能获取到更新后的值，
你需要使用$nextTick这个回调，让修改后的data值渲染更新到dom元素之后在获取，才能成功
Vue 组件 data 为什么必须是函数
￼
因为js本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了
计算属性computed 和事件 methods 有什么区别
￼
我们可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的
不同点：
computed: 计算属性是基于它们的依赖进行缓存的,只有在它的相关依赖发生改变时才会重新求值对于 method ，只要发生重新渲染，method 调用总会执行该函数
watch和computed区别
  computed结果会缓存,依赖于外界响应式依赖发生变化而变化
  watch是直接监听某个属性,只要这个属性发生了变化,就会触发相应的函数回调,并且能获取到变更值以及变更之前的值 

清除keep-alive缓存
￼
deactivated () { //清除keep-alive的缓存
    this.$destroy(true)
  }
对比 jQuery ，Vue 有什么不同
￼
jQuery 专注视图层，通过操作 DOM 去实现页面的一些逻辑渲染； Vue 专注于数据层，通过数据的双向绑定，最终表现在 DOM 层面，减少了 DOM 操作Vue 使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发
vue-router 路由实现
￼
路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能
Vue 组件 data 为什么必须是函数
￼
因为js本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了
Vue 中怎么自定义指令
￼
全局注册
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
局部注册
directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus()
    }
  }
}
Vue 中怎么自定义过滤器
￼
可以用全局方法 Vue.filter() 注册一个自定义过滤器，它接收两个参数：过滤器 ID 和过滤器函数。过滤器函数以值为参数，返回转换后的值
Vue.filter('reverse', function (value) {
  return value.split('').reverse().join('')
})
&lt;!-- 'abc' =&gt; 'cba' --&gt;
&lt;span v-text=&quot;message | reverse&quot;&gt;&lt;/span&gt;
过滤器也同样接受全局注册和局部注册
对 keep-alive 的了解
￼
keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染
&lt;keep-alive&gt;
  &lt;component&gt;
    &lt;!-- 该组件将被缓存！ --&gt;
  &lt;/component&gt;
&lt;/keep-alive&gt;
可以使用API提供的props，实现组件的动态缓存

钩子函数
	1.activated：页面第一次进入的时候，钩子触发的顺序是created-&gt;mounted-&gt;activated
	2.deactivated ：页面退出的时候会触发deactivated，当再次前进或者后退的时候只触发activated
属性:include包含的组件会被缓存，exclude排除的组件不会被缓存
Vue 的核心是什么
￼
数据驱动 组件系统
vue 等单页面应用的优缺点
￼
优点：1.良好的交互体验 2.良好的前后端工作分离模式 3.减轻服务器压力
缺点：1.SEO难度较高 2.前进、后退管理  3.初次加载耗时多
vue-router有哪几种导航守卫
￼
1&gt;全局守卫
a：router.beforeEach 全局前置守卫，进入路由之前
b：router.beforResolve 全局解析守卫，在beforeRouterEnter调用之后调用
c：router.afterEach 全局后置钩子，进入路由之后
2&gt;路由独享守卫
如果不想全局配置守卫的话，可以为某些路由单独配置守卫
3&gt;路由组件内的守卫
beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建beforeRouteUpdate (2.2)路由复用同一个组件时,在当前路由改变，但是该组件被复用时调用 可以访问组件实例this
beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this
vue-router 使用params与query传参有什么区别
￼
vue-router 可以通过 params 与 query 进行传参
// 传递
this.$router.push({path: './xxx', params: {xx:xxx}})
this.$router.push({path: './xxx', query: {xx:xxx}})
// 接收
this.$route.params
this.$route.query
params 是路由的一部分,必须要有。query 是拼接在 url 后面的参数，没有也没关系
params 不设置的时候，刷新页面或者返回参数会丢，query 则不会有这个问题
你在什么场景下使用了vuex？ 
￼
当应用遇到多个组件共享状态的时候，即：多个视图依赖于同一个状态，不同视图的行为需要变更同一个状态
如：
用户的个人信息管理模块
电商项目购物车模块
props和data的优先级，区别
￼
props&gt;data
props就相当于你的参数，data就相当于局部变量，组件其实就是一个函数
xxxxxxxxxx vuex是：就是用来存放所有组件数据的仓库,也就是组件状态管理工具state:存储数据；mutations:更新数据的方法；actions:调用mutations方法，更新state数据；getters:对state中的数据进行预处理；
</code></pre>
<h4 id="vuex-的作用">vuex 的作用</h4>
<pre><code>实现所有组件相互通信，数据共享
组件之间需要相互通信时，例如购物车购买数量、登录信息等
</code></pre>
<h4 id="什么是计算属性和侦听器">什么是计算属性和侦听器</h4>
<pre><code>计算属性：普通方法的升级版，有缓存
怎么用：在data同级定义computed对象来声明计算属性、调用不加小括号
侦听器：用来监控模型数据变化
 怎么用：在data同级定义watch对象声明侦听器、方法名就是data中的键、不能调用
 如何选：
  1 事件 和 封装减少视图代码冗余便于后期维护 先用普通方法
  2 上述多次执行耗时 计算属性优化
3 当需要监控模型数据改变 使用侦听器。例如：搜索、全选全不选等等
</code></pre>
<h4 id="什么是混入">什么是混入</h4>
<pre><code>是什么：vue中提供的解决组件代码冗余的技术，可以提起相同的普通方法、模型数据等
怎么用：Vue.mixin 或 mixins键来定义
实战用：后期项目的跳转、返回上一页、提示信息等等
</code></pre>
<h4 id="什么是vue组件">什么是vue组件</h4>
<pre><code>是什么：用来代替传统HTML的一种解决方案、里面还是HTML、JS、CSS
好处：倡导模块化、便于后期相互调用、从而减少代码冗余、方便维护
怎么用： Vue.component(组件名，{template, methods, data, ....})
</code></pre>
<h4 id="组件通信工作流">组件通信工作流</h4>
<pre><code>父传子： 子组件通过 props 属性，绑定父组件数据，实现双方通信
子传父：	将父组件的事件在子组件中通过 $emit 触发
兄弟	：1 创建bus总线 全局仓库	
     	2 传递数据 bus.$emit
         3 接受数据 bus.$on
</code></pre>
<h4 id="vue中的事件修饰符">vue中的事件修饰符</h4>
<pre><code>事件修饰符：.stop、.prevent、.once等
键盘修饰符：.enter、.ctrl .enter等
</code></pre>
<h4 id="什么是路由懒加载">什么是路由懒加载</h4>
<pre><code>路由懒加载是通过异步的方式来加载对应的路由组件，提高页面相应速度
</code></pre>
<h4 id="vue的路由使用步骤">vue的路由使用步骤？</h4>
<pre><code>1.下载vue-router路由模块；
2.创建路由对象；
3.配置路由规则；
4.将路由对象注册为vue实例对象的成员属性；
</code></pre>
<h4 id="http协议状态码301和302的区别">http协议状态码301和302的区别</h4>
<pre><code>301 redirect: 301 代表永久性转移(Permanently Moved)
302 redirect: 302 代表暂时性转移(Temporarily Moved )
302重定向只是暂时的重定向，浏览器会抓取新的内容而保留旧的地址，因为服务器返回302，所以，搜索浏览器认为新的网址是暂时的。
301重定向是永久的重定向，浏览器在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址
</code></pre>
<h4 id="谈谈你对虚拟dom的理解">谈谈你对虚拟DOM的理解？</h4>
<pre><code>就是用JS 的Object对象模拟DOM中的节点，然后再通过特定的render方法将其渲染成真实的DOM节点，因为浏览器工作机制，通过虚拟DOM提升性能。
</code></pre>
<h4 id="回流重绘">回流重绘</h4>
<pre><code>回流：重新布局
重绘：改变元素属性样式
</code></pre>
<h4 id="谈谈你对diff算法的理解">谈谈你对diff算法的理解？</h4>
<pre><code>diff算法是虚拟DOM技术的产物，核心思想是通过新旧虚拟DOM做对比，（即diff），将变化的地方更新在真实的DOM上，也需要diff高效执行对比的过程，从而降低时间复杂度为O(n).
步骤一：用JS对象模拟DOM树
步骤二：比较新旧虚拟DOM树的差异
步骤三：把差异应用到真正的DOM树上
</code></pre>
<h4 id="v-for中有key值和没有key值的区别">v-for中有key值和没有key值的区别</h4>
<pre><code>它们区别主要在于虚拟DOM的复用，绑定key可以更好的复用，避免重复渲染
</code></pre>
<h4 id="fetch-axios区别">fetch、axios区别</h4>
<pre><code>相同点：都是基于promise封装的HTTP库
不同点:1 fetch官方 axios第三方
	2 axios更强例如拦截器、而fetch需要自己封装等
</code></pre>
<h4 id="请谈谈对http的理解">请谈谈对http的理解</h4>
<pre><code>HTTP：超文本传输协议，主要由request请求 和response响应 组成，规定了计算机之间如何相互通信
项目开发中常遇到的
请求方式常用的有get、post、put、delete
HTTP状态码：...
请求头：expire、gzip、content-type等
</code></pre>
<h4 id="http状态码">HTTP状态码</h4>
<pre><code>100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
200 OK 请求成功
201 Created 请求成功并且服务器创建了新的资源
202 Accepted 服务器已接受请求，但尚未处理
301 Moved Permanently 永久性重定向。
302 Found 临时性重定向。
303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
304 Not Modified 浏览器缓存
400 BadRequest 参数有误。
401 Unauthorized 密码错误。
403Forbidden 没有权限。
404 NotFound 文件不存在。
500 InternalServer Error 服务器错误。
503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
</code></pre>
<h4 id="vue实现数据双向绑定的原理">vue实现数据双向绑定的原理</h4>
<pre><code>采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调
</code></pre>
<h4 id="created与mounted的区别">Created与Mounted的区别</h4>
<pre><code>Created：在dom渲染之前调用，通常初始化某些属性值，然后再渲染成视图。
Mounted：在dom渲染之后调用，初始化页面完成后，再对dom节点进行一些需要的操作。
</code></pre>
<h4 id="vue中mounted和updated这两个生命周期怎么运行的">vue中mounted和updated这两个生命周期怎么运行的</h4>
<pre><code>mounted 页面首次渲染完毕时触发
updated 模型数据更新时候触发
</code></pre>
<h4 id="vue首屏加载过慢如何解决">vue首屏加载过慢如何解决</h4>
<pre><code>1、路由懒加载（也就是要的时候的时候进行加载。
2、UI组件按需加载
3、webpack启用gzip压缩
</code></pre>
<h4 id="什么是jsx">什么是JSX</h4>
<pre><code>JSX即JavaScript XML，是JS的一种扩展语言。
</code></pre>
<h4 id="解释单向数据流和双向数据绑定">解释单向数据流和双向数据绑定</h4>
<pre><code>单向数据流： 顾名思义，数据流是单向的。数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷。缺点就是写起来不太方便。要使UI发生变更就必须创建各种 action 来维护对应的 state；
双向数据绑定：数据之间是相通的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的场景下，会简化大量与业务无关的代码。缺点就是无法追踪局部状态的变化，增加了出错时 debug 的难度。
</code></pre>
<h4 id="vue-如何去除url中的">Vue 如何去除url中的</h4>
<pre><code>vue-router 默认使用 hash 模式，所以在路由加载的时候，项目中的 url 会自带 #。如果不想使用 #， 可以使用 vue-router 的另一种模式 history。
需要注意的是，当我们启用 history 模式的时候，由于我们的项目是一个单页面应用，所以在路由跳转的时候，就会出现访问不到静态资源而出现 404 的情况，这时候就需要服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面(重定向)。
</code></pre>
<h3 id="route和router的区别"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">和</mi></mrow><annotation encoding="application/x-tex">route和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">和</span></span></span></span>router的区别</h3>
<pre><code>$router 为 VueRouter 实例，想要导航到不同 URL，则使用 $router.push 方法$route 为当前 router 跳转对象里面可以获取 name 、 path 、 query 、 params 等
</code></pre>
<h4 id="nexttick-是做什么的">NextTick 是做什么的</h4>
<pre><code>$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM
当你修改了data的值然后马上获取这个dom元素的值，是不能获取到更新后的值，
你需要使用$nextTick这个回调，让修改后的data值渲染更新到dom元素之后在获取，才能成功
</code></pre>
<h3 id="vue-组件-data-为什么必须是函数">Vue 组件 data 为什么必须是函数</h3>
<pre><code>因为js本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了
</code></pre>
<h4 id="计算属性computed-和事件-methods-有什么区别">计算属性computed 和事件 methods 有什么区别</h4>
<pre><code>我们可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的
不同点：
computed: 计算属性是基于它们的依赖进行缓存的,只有在它的相关依赖发生改变时才会重新求值对于 method ，只要发生重新渲染，method 调用总会执行该函数
</code></pre>
<h1 id="watch和computed区别">watch和computed区别</h1>
<p>computed结果会缓存,依赖于外界响应式依赖发生变化而变化<br>
watch是直接监听某个属性,只要这个属性发生了变化,就会触发相应的函数回调,并且能获取到变更值以及变更之前的值</p>
<h1 id="清除keep-alive缓存">清除keep-alive缓存</h1>
<pre><code>deactivated () { //清除keep-alive的缓存
    this.$destroy(true)
  }
</code></pre>
<h4 id="对比-jquery-vue-有什么不同">对比 jQuery ，Vue 有什么不同</h4>
<pre><code>jQuery 专注视图层，通过操作 DOM 去实现页面的一些逻辑渲染； Vue 专注于数据层，通过数据的双向绑定，最终表现在 DOM 层面，减少了 DOM 操作Vue 使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发
</code></pre>
<h4 id="vue-router-路由实现">vue-router 路由实现</h4>
<pre><code>路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能
</code></pre>
<h4 id="vue-组件-data-为什么必须是函数-2">Vue 组件 data 为什么必须是函数</h4>
<pre><code>因为js本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了
</code></pre>
<h4 id="vue-中怎么自定义指令">Vue 中怎么自定义指令</h4>
<pre><code>全局注册
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
局部注册
directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus()
    }
  }
}
</code></pre>
<h4 id="vue-中怎么自定义过滤器">Vue 中怎么自定义过滤器</h4>
<pre><code>可以用全局方法 Vue.filter() 注册一个自定义过滤器，它接收两个参数：过滤器 ID 和过滤器函数。过滤器函数以值为参数，返回转换后的值
Vue.filter('reverse', function (value) {
  return value.split('').reverse().join('')
})
&lt;!-- 'abc' =&gt; 'cba' --&gt;
&lt;span v-text=&quot;message | reverse&quot;&gt;&lt;/span&gt;
过滤器也同样接受全局注册和局部注册
</code></pre>
<h4 id="对-keep-alive-的了解">对 keep-alive 的了解</h4>
<pre><code>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染
&lt;keep-alive&gt;
  &lt;component&gt;
    &lt;!-- 该组件将被缓存！ --&gt;
  &lt;/component&gt;
&lt;/keep-alive&gt;
可以使用API提供的props，实现组件的动态缓存

钩子函数:activated deactivated
属性:include包含的组件会被缓存，exclude排除的组件不会被缓存
</code></pre>
<h4 id="vue-的核心是什么">Vue 的核心是什么</h4>
<pre><code>数据驱动 组件系统
</code></pre>
<h4 id="vue-等单页面应用的优缺点">vue 等单页面应用的优缺点</h4>
<pre><code>优点：1.良好的交互体验 2.良好的前后端工作分离模式 3.减轻服务器压力
缺点：1.SEO难度较高 2.前进、后退管理 	3.初次加载耗时多
</code></pre>
<h4 id="vue-router有哪几种导航守卫"><strong>vue-router有哪几种导航守卫</strong></h4>
<pre><code>1&gt;全局守卫
a：router.beforeEach 全局前置守卫，进入路由之前
b：router.beforResolve 全局解析守卫，在beforeRouterEnter调用之后调用
c：router.afterEach 全局后置钩子，进入路由之后
2&gt;路由独享守卫
如果不想全局配置守卫的话，可以为某些路由单独配置守卫
3&gt;路由组件内的守卫
beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建beforeRouteUpdate (2.2)路由复用同一个组件时,在当前路由改变，但是该组件被复用时调用 可以访问组件实例this
beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this
</code></pre>
<h4 id="vue-router-使用params与query传参有什么区别">vue-router 使用params与query传参有什么区别</h4>
<pre><code>vue-router 可以通过 params 与 query 进行传参
// 传递
this.$router.push({path: './xxx', params: {xx:xxx}})
this.$router.push({path: './xxx', query: {xx:xxx}})
// 接收
this.$route.params
this.$route.query
params 是路由的一部分,必须要有。query 是拼接在 url 后面的参数，没有也没关系
params 不设置的时候，刷新页面或者返回参数会丢，query 则不会有这个问题
</code></pre>
<h4 id="你在什么场景下使用了vuex">你在什么场景下使用了vuex？</h4>
<pre><code>当应用遇到多个组件共享状态的时候，即：多个视图依赖于同一个状态，不同视图的行为需要变更同一个状态
如：
用户的个人信息管理模块
电商项目购物车模块
</code></pre>
<h4 id="props和data的优先级区别">props和data的优先级，区别</h4>
<pre><code>props&gt;data
props就相当于你的参数，data就相当于局部变量，组件其实就是一个函数
</code></pre>
<h1 id="地址栏输入一个url发生了什么">地址栏输入一个url发生了什么</h1>
<p>1.DNS解析寻址,将输入的url解析为ip地址<br>
2.TCP三次握手:根据ip地址与服务器进行连接通信<br>
3.发送HTTP请求,请求相关资源<br>
4.服务器接收请求并返回HTTP报文,携带指定资源<br>
5.浏览器解析资源,渲染页面<br>
6.TCP四次挥手,关闭连接</p>
<h4 id="js执行机制">js执行机制</h4>
<p>a、首先 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。</p>
<p>b、在执行同步代码的时候，如果遇到了异步事件，会将异步代码放到事件循环中，继续执行执行栈中的其他任务;</p>
<p>c、当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行<br>
d、任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行<br>
e、当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务</p>
<h4 id=""></h4>
<h4 id="深拷贝与浅拷贝的区别">深拷贝与浅拷贝的区别？</h4>
<p>深拷贝递归地复制新对象中的所有值或属性，而拷贝只复制引用。</p>
<p>在深拷贝中，新对象中的更改不会影响原始对象，而在浅拷贝中，新对象中的更改，原始对象中也会跟着改。</p>
<p>在深拷贝中，原始对象不与新对象共享相同的属性，而在浅拷贝中，它们具有相同的属性。</p>
<p>方法：深拷贝：1.递归，2.JSON.stringify(JSON.parse())，3. JQ的extend方法</p>
<p>​			浅拷贝：1. Object.assign()  2. 使用 for in 循环，遍历每一个属性，将他们赋值给新的对象 3. 直接用=赋值 							4  ...扩展运算符</p>
<h5 id="js-中分全局作用域和函数作用">Js 中分全局作用域和函数作用</h5>
<p>全局作用域：在任何地方都能被访问，window对象下的内置属性都是全局作用域</p>
<p>函数作用域：固定代码片段中</p>
<p>作用域链：作用域都有上下级关系，上下级关系确定函数在哪个作用域下创建，变量取值都会在当前作用域中查找，如果没有查到就会像上级作用域查找，直到查到全局作用域，这个查找的过程叫做作用域链</p>
<h1 id="react">React</h1>
<h4 id="react如何实现双向绑定">react如何实现双向绑定</h4>
<pre><code>在React当中，有个onChange属性，可以给input绑定事件，当input框里的值发生变化时会触发调用方法，这个方法会合并data到this.state,并重新渲染组件。
</code></pre>
<h4 id="高阶组件是什么-什么情况下有用到">高阶组件是什么 什么情况下有用到</h4>
<pre><code>如果一个函数 接受一个或多个组件作为参数并且返回一个组件 就可称之为 高阶组件。
什么时候使用：页面复用,组件渲染性能追踪，权限控制。
</code></pre>
<h4 id="react生命周期">react生命周期</h4>
<pre><code>React组件的生命周期可以分为挂载、渲染和卸载这几个阶段，当渲染后的组件需要更新的时候，我们会重新去渲染组件，直到卸载。
因此，我们可以把React生命周期分为两类：
1 当组件在挂载或卸载时
2 当组件接收新的数据时，即组件更新时

componentWillMount  在渲染前调用
componentDidMount  在第一次渲染后调用
componentWillReceiveProps  在组件接受一个新的prop时调用，这个方法在第一次渲染的时候不会被调用。
shouldComponentUpdate  返回一个布尔值，在组件接受到新的props或是state时被调用。在初始化时或是使用forceUpdate时不被调用。可以在你确认不需要更新组件时使用。
componentWillUpdate 在组件接受到新的props或是state但还没有render时被调用。在初始化时不会被调用。
componentDidUpdate  在组件完成更新后立即调用。在初始化时不会被调用
componentWillUnmount  在组件从DOM中移除的时候立即被调用
</code></pre>
<h4 id="react做过哪些优化">react做过哪些优化</h4>
<pre><code>1 减少不必要的props引起的重绘
2 减少不必要state引起的重绘
3 长列表优化
</code></pre>
<h4 id="redux-流程">redux 流程</h4>
<pre><code>1.View在redux中会派发action方法;
2.action通过store的dispatch方法会派发给store;
3.store接收action，连同之前的state，一起传递给reducer；
4.reducer返回新的数据给store；
5.store去改变自己的state。
</code></pre>
<h4 id="说一下react中的key">说一下react中的key</h4>
<pre><code>它主要在于虚拟DOM的复用，绑定key可以更好的复用，避免重复渲染
</code></pre>
<h4 id="redux-数据流动-有什么组件-redux中connect介绍一下-connect的底层是什么">Redux 数据流动 有什么组件 redux中connect介绍一下   connect的底层是什么</h4>
<pre><code>connect是一个高阶函数，首先传入mapStateToProps、mapDispatchToProps，然后返回一个生产Component的函数(wrapWithConnect)，然后再将真正的Component作为参数传入wrapWithConnect，这样就生产出一个经过包裹的Connect组件。
</code></pre>
<h4 id="react的路由-项目中用到什么路由-介绍一下">React的路由 项目中用到什么路由 介绍一下</h4>
<pre><code>1 两种常用的路由：HashRouter和BrowserRouter
2 路由组件：包裹整个应用：一个React应用只使用一次
3 HashRouter：使用URL的哈希值实现，就是在地址栏的后面有#（localhost:3000/#/sdjdjdj）
4 推荐使用BrowserRouter：使用H5的historyAPI实现（localhost:3000/djjdd）
5 Link:组件：用于指定导航链接（a标签） 在浏览器解析时，会将link组件解析成a标签
6 Router组件：指定路由展示相关的组件信息
</code></pre>
<h4 id="react路由传参方法">React路由传参方法</h4>
<pre><code>  通过params
        1.路由表中      
              &lt;Route path=' /sort/:id '   component={Sort}&gt;&lt;/Route&gt;
        2.Link处        
          HTML方式
                 &lt;Link to={ ' /sort/ ' + ' 2 ' }  activeClassName='active'&gt;XXXX&lt;/Link&gt;   
          JS方式
                this.props.history.push(  '/sort/'+'2'  )
        3.sort页面       
               通过  this.props.match.params.id        就可以接受到传递过来的参数（id）
  通过query
      前提：必须由其他页面跳过来，参数才会被传递过来
　　　 注：不需要配置路由表。路由表中的内容照常：&lt;Route path='/sort' component={Sort}&gt;&lt;/Route&gt;
        1.Link处      
         HTML方式
            &lt;Link to={{ path : ' /sort ' , query : { name : 'sunny' }}}&gt;
       JS方式
            this.props.history.push({ path : '/sort' ,query : { name: ' sunny'} })
        2.sort页面     
              this.props.location.query.name
</code></pre>
<h1 id="原型原型链">原型，原型链</h1>
<p>原型：js给每个函数分配的公共空间，减少内存占用</p>
<p>原型链：多个原型的集合，当调用对象的属性或方法时，先自身找，找不到去原型链上找，一直找到Object构造函数得原型链</p>
<h1 id="其他">其他</h1>
<h4 id="sass和less区别">sass和less区别</h4>
<pre><code>1.编译环境不一样,less是基于JavaScript的在客户端处理 所以安装的时候用npm，sass是基于ruby所以在服务器处理。
2.变量符不一样，Less是@，而Scss是$，而且变量的作用域也不一样。
Sass的功能比Less强大
</code></pre>
<h4 id="link和inmport的区别"><strong>link和@inmport的区别</strong></h4>
<pre><code>1》link是html的标签，不仅可以加载css还可以定义Rss , rel连接属性；@import是css的语法规则，只能引入样式；
2》加载页面时，link是同时加载的，@impor是页面加载完后才加载
3》link没有兼容性的问题，而@import只在较高版本的浏览器才可以识别
4》link可以通过js插入操作dom，@import 不可以！
</code></pre>
<h4 id="如何理解js中的原型链"><strong>如何理解js中的原型链</strong></h4>
<pre><code>1；每个构造函数都有一个原型对象
2；每个原型对象都有一个指向构造函数的指针
3；每个实例函数都有一个指向原型对象的指针。
4；查找方式是一层一层查找，直至顶层。Object.prototype
</code></pre>
<h4 id="图片懒加载原理">图片懒加载原理</h4>
<pre><code>就是我们先设置图片的data-set属性（当然也可以是其他任意的，只要不会发送http请求就行了，作用就是为了存取值）值为其图片路径，由于不是src，所以不会发送http请求。 然后我们计算出页面scrollTop的高度和浏览器的高度之和， 如果图片举例页面顶端的坐标Y（相对于整个页面，而不是浏览器窗口）小于前两者之和，就说明图片就要显示出来了（合适的时机，当然也可以是其他情况），这时候我们再将 data-set 属性替换为 src 属性即可。

或
好处：减少HTTP请求
1、监控滚动条滚动
2、获取总可视内容高度（可见视口高度+滚动条滚动高度）
3、获取所有图片
4、遍历步骤3
5、在步骤4中判断，图片.offsetTop &lt;= 步骤2    成立-修改src属性为data-src、失败-不管
6、节流防抖优化
</code></pre>
<h4 id="react和vue有哪些不同说说你对这两个框架的看法"><strong>react和vue有哪些不同，说说你对这两个框架的看法</strong></h4>
<pre><code>相同点:
· 都支持服务器端渲染
· 都有Virtual DOM,组件化开发,通过props参数进行父子组件数据的传递,都实现webComponent规范
· 数据驱动视图
· 都有支持native的方案,React的React native,Vue的weex
不同点:
· React严格上只针对MVC的view层,Vue则是MVVM模式
· virtual DOM不一样,vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树.而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制
· 组件写法不一样, React推荐的做法是 JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即'all in js'; Vue推荐的做法是webpack+vue-loader的单文件组件格式,即html,css,jd写在同一个文件;
· 数据绑定: vue实现了数据的双向绑定,react数据流动是单向的
· state对象在react应用中不可变的,需要使用setState方法更新状态;在vue中,state对象不是必须的,数据由data属性在vue对象中管理
</code></pre>
<h4 id="px和em的区别"><strong>px和em的区别</strong></h4>
<pre><code>相同点：px和em都是长度单位；
异同点：px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。
浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。
</code></pre>
<h4 id="js哪些操作会造成内存泄露"><strong>JS哪些操作会造成内存泄露</strong></h4>
<pre><code>1）意外的全局变量引起的内存泄露
function leak(){  leak=&quot;xxx&quot;;//leak成为一个全局变量，不会被回收  }
2）闭包引起的内存泄露
3）没有清理的DOM元素引用
4）被遗忘的定时器或者回调 
5）子元素存在引起的内存泄露
</code></pre>
<h4 id="浏览器缓存有哪些通常缓存有哪几种"><strong>浏览器缓存有哪些，通常缓存有哪几种</strong></h4>
<pre><code>http缓存
websql
cookie
localstorage
sessionstorage
flash缓存
</code></pre>
<h4 id="浏览器是如何渲染页面的"><strong>浏览器是如何渲染页面的？</strong></h4>
<pre><code>渲染的流程如下：
1.解析HTML文件，创建DOM树。
   自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）。
2.解析CSS。优先级：浏览器默认设置&lt;用户设置&lt;外部样式&lt;内联样式&lt;HTML中的style样式；
3.将CSS与DOM合并，构建渲染树（Render Tree）
4.布局和绘制，重绘（repaint）和重排（reflow）
</code></pre>
<h4 id="css3新增的属性"><strong>CSS3新增的属性</strong></h4>
<pre><code>CSS3实现圆角（border-radius），阴影（box-shadow），
对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）
transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜
增加了更多的CSS选择器  多背景 rgba 
在CSS3中唯一引入的伪元素是::selection.
媒体查询，多栏布局
border-image
</code></pre>
<h4 id="h5新特性"><strong>H5新特性</strong></h4>
<pre><code>(1)新的语义标签和属性
(2)表单新特性
(3)视频和音频
(4)Canvas绘图
(5)SVG绘图
(6)地理定位
(7)拖放API
</code></pre>
<h4 id="谈一下js的继承">谈一下JS的继承</h4>
<pre><code>1.借用构造函数继承，使用call或apply方法，将父对象的构造函数绑定在子对象上
2.原型继承，将子对象的prototype指向父对象的一个实例
3.组合继承
原型链继承的缺点:
字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。
借用构造函数（类式继承）:
借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。
组合式继承:
组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。
</code></pre>
<h4 id="跨域的解决方法">跨域的解决方法</h4>
<pre><code>前端:1.浏览器插件2.前端代理3.SONP
后端:1.声明header头2.后端代理
运维:web服务器配置
等等
</code></pre>
<h4 id="谈谈你对闭包的理解">谈谈你对闭包的理解</h4>
<pre><code>使用闭包主要是为了设置私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念
闭包有三个特性：
1.函数嵌套函数
2.函数内部可以引用外部的参数和变量
3.参数和变量不会被垃圾回收机制回收
</code></pre>
<h4 id="浏览器兼容">浏览器兼容</h4>
<pre><code>浏览器兼容性问题，是指因为不同的浏览器对同一段代码有不同的解析，造成页面显示效果不统一的情况。
</code></pre>
<h4 id="做过哪些性能优化">做过哪些性能优化</h4>
<pre><code>1 尽量减少HTTP请求次数
2 压缩合并js
3 css精灵
4 减少DOM元素数量
5 使用CDN(网站上静态资源即css、js全都使用cdn分发，图片亦然,因为cdn拥有众多服务器，用户请求可以请求距离他近的服务器，加快速度)
6 把CSS放到顶部,把JS放到底部
7 使用gzip压缩内容(服务端)
</code></pre>
<h4 id="bfc的理解">BFC的理解</h4>
<pre><code> BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。
</code></pre>
<h4 id="js执行机制浏览器运行机制">JS执行机制（浏览器运行机制）</h4>
<pre><code>1.JavaScript是一门单线程语言。
2.Event Loop(事件循环)是JavaScript的执行机制。
</code></pre>
<h4 id="关于配置webpack的了解">关于配置webpack的了解？</h4>
<pre><code>它属于一个预编译模块方案（模块打包工具），我们现在的前端代码开始分模块进行构建，则会用到import &quot;./a.js&quot;; 、require (&quot;a.js&quot;); 等方法。但是浏览器是不认识这样的方法。这时，webpack 就出现了，它采用预编译的方式，在代码加载到页面前，把这些模块引用的方式转换成浏览器可以识别的js代码。
</code></pre>
<h4 id="怎么配置cli的三种环境">怎么配置cli的三种环境？</h4>
<pre><code>1.创建环境env文件
2.修改package.json
3.vue.config.js中引用环境变量
</code></pre>
<h4 id="组件的预加载说几种方式">组件的预加载，说几种方式。</h4>
<pre><code>1、使用import导入组件，可以获取到组件
2、使用import导入组件，直接将组件赋值给componet
3、使用require 导入组件，可以获取到组件
4、使用require 导入组件，直接将组件赋值给componet
</code></pre>
<h4 id="mpvue遇到的坑">mpvue遇到的坑</h4>
<pre><code>1.文件夹名字不能大写。
2.两层v-for不能用index的名字来作为索引
3.合法域名校验出错，不在以下合法域名列表中
</code></pre>
<h4 id="说一下盒模型">说一下盒模型</h4>
<pre><code>盒模型的组成，由里向外content，padding，border，margin。
盒模型有两种标准，一个是标准模型，一个是怪异盒模型。
</code></pre>
<h4 id="函数的this指向bind-call-apply-的区别-bind怎么立即调用call-apply怎么延迟调用">函数的this指向，bind call apply 的区别  bind怎么立即调用，call apply怎么延迟调用</h4>
<pre><code>A普通函数调用   	this =&gt;  window   	
B对象函数调用   	this =&gt;  对象本身    
C事件处理函数调用  this =&gt;  事件源    
D定时器调用       this =&gt;  window 
E箭头函数中调用    this  =&gt;  父function中的this    父没有function则window
F bind/apply/call this=&gt;   用来改变this指向 

区别：都用来改变this的指向，bind后函数不会执行，而只是返回一个改变了上下文的另一个函数，而call和apply是直接执行函数。若无参数，apply与call基本没什么区别
</code></pre>
<h4 id="es6">es6</h4>
<pre><code>1.不一样的变量声明：const和let
2.模板字符串
3.箭头函数（Arrow Functions）
4. 函数的参数默认值
5.Spread / Rest 操作符
6.二进制和八进制字面量
7.对象和数组解构
8.对象超类
9.for...of 和 for...in
10.ES6中的类
</code></pre>
<h4 id="promise是什么-和-async-await的区别-async-await-的底层">Promise是什么   和 async await的区别 async await 的底层</h4>
<pre><code>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大，简单地说，Promise好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而这些结果一旦生成是无法改变的

区别：1 Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。
2 async await与Promise一样，是非阻塞的。
3 async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函数。
</code></pre>
<h4 id="echarts是什么">Echarts是什么</h4>
<pre><code>商业级数据图表，它是一个纯JavaScript的图标库，兼容绝大部分的浏览器，底层依赖轻量级的canvas类库ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。创新的拖拽重计算、数据视图、值域漫游等特性大大增强了用户体验，赋予了用户对数据进行挖掘、整合的能力。
Echarts支持的图表：折线图（区域图）、柱状图（条状图）、散点图（气泡图）、K线图、饼图（环形图）
雷达图（填充雷达图）、和弦图、力导向布局图、地图、仪表盘、漏斗图、事件河流图等12类图表
</code></pre>
<h4 id="说一下深浅拷贝">说一下深浅拷贝</h4>
<pre><code>浅拷贝 shadow copy (传地址)
仅仅只拷贝对象自身，内部元素引用的其他对象只拷贝一个引用。
深拷贝 deep copy (传值)
外围和内部元素都拷贝了对象本身。而不是引用。因此深拷贝产生的副本可以随意修改，而不用担心会影响原始值。
</code></pre>
<h4 id="清除浮动的几种方法">清除浮动的几种方法</h4>
<pre><code>1，额外标签法，&lt;divstyle=&quot;clear:both;&quot;&gt;&lt;/div&gt;（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）
2，使用after伪类
#parent:after{
content:&quot;.&quot;;
height:0;
visibility:hidden;
display:block;
clear:both;
}
3,浮动外部元素
4,设置overflow为hidden或者auto
</code></pre>
<h4 id="commonjs的理解">Commonjs的理解</h4>
<pre><code>CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作
</code></pre>
<h4 id="请解释什么是事件代理">请解释什么是事件代理</h4>
<pre><code>事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。
事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能。
</code></pre>
<h4 id="创建ajax过程">创建ajax过程</h4>
<pre><code>ajax(异步javascript xml) 是什么：能够刷新局部网页数据而不是重新加载整个网页。
(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.
(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.
(3)设置响应HTTP请求状态变化的函数.
(4)发送HTTP请求.
(5)获取异步调用返回的数据.
(6)使用JavaScript和DOM实现局部刷新.
</code></pre>
<h4 id="为什么https安全">为什么HTTPS安全</h4>
<pre><code>因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性	
</code></pre>
<h4 id="节流防抖">节流防抖</h4>
<pre><code>节流：一段时间内，只执行一次函数
防抖：事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时
</code></pre>
<h4 id="说一下cookie和session的区别">说一下cookie和session的区别</h4>
<pre><code>性能角度: 	 cookie影响性能    h5不影响性能    h5最重要
生命周期:    cookie自定义      localStorage永久、sessionStorage窗口
存储空间：	cookie 4k      h5  5M
主要网站设置了cookie  后期所有请求都会携带cookie 影响性能
</code></pre>
<h4 id="数组的方法">数组的方法</h4>
<pre><code>1.concat() 功能：用于连接两个或多个数组，该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。
2.join() 功能：根据指定分隔符将数组中的所有元素放入一个字符串，并返回这个字符串。
3.pop() 功能：方法用于删除并返回数组的最后一个元素。
4.shift() 功能：方法用于删除并返回数组的第一个元素。
5.unshift() 功能：向数组的开头添加一个或更多元素，并返回新的长度。
6.push() 功能：向数组的末尾添加一个或更多元素，并返回新的长度。
7.slice() 功能：可从已有的数组中返回选定的元素。该方法接收两个参数slice(start,end)，strat为必选，表示从第几位开始；end为可选，表示到第几位结束(不包含end位)，省略表示到最后一位；start和end都可以为负数，负数时表示从最后一位开始算起，如-1表示最后一位。
8.splice() 功能：向数组中添加，或从数组删除，或替换数组中的元素，然后返回被删除/替换的元素。
参数：splice(start,num,data1,data2,...); 所有参数全部可选。
9.toString() 功能：转换成字符串，类似于没有参数的join()。该方法会在数据发生隐式类型转换时被自动调用，如果手动调用，就是直接转为字符串。
10.indexOf() 功能：根据指定的数据，从左向右，查询在数组中出现的位置，如果不存在指定的数据，返回-1。该方法是查询方法，不会对数组产生改变。
11.forEach() 功能：ES5新增方法，用来遍历数组，该方法没有返回值。forEach接收的回调函数会根据数组的每一项执行，该回调函数默认有三个参数，分别为：遍历到的数组的数据，对应的索引，数组自身。
12.map() 功能：1.同forEach功能；2.map的回调函数会将执行结果返回，最后map将所有回调函数的返回值组成新数组返回。
13.filter() 功能：1.同forEach功能；2.filter的回调函数需要返回布尔值，当为true时，将本次数组的数据返回给filter，最后filter将所有回调函数的返回值组成新数组返回（此功能可理解为“过滤”）。
</code></pre>
<h4 id="数组去重的方法">数组去重的方法</h4>
<pre><code>一、利用ES6中的 Set 方法去重
二、使用双重for循环，再利用数组的splice方法去重（ES5常用）
三、利用数组的indexOf方法去重
四、利用数组的sort方法去重（相邻元素对比法）
五、利用ES6中的Map方法去重
六、利用数组的filter方法去重
</code></pre>
<h4 id="export和export-default的区别">export和export default的区别？</h4>
<pre><code>使用上的不同+
import xxx from './'

export xxx
import {xxx} from './'
</code></pre>
<h4 id="get-post的区别">get、post的区别</h4>
<pre><code>1.get传参方式是通过地址栏URL传递，是可以直接看到get传递的参数，post传参方式参数URL不可见，get把请求的数据在URL后通过？连接，通过&amp;进行参数分割。psot将参数存放在HTTP的包体内
2.get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制
3.get后退不会有影响，post后退会重新进行提交
4.get请求可以被缓存，post不可以被缓存
5.get请求只URL编码，post支持多种编码方式
6.get请求的记录会留在历史记录中，post请求不会留在历史记录
7.get只支持ASCII字符，post没有字符类型限制
</code></pre>
<h4 id="优雅降级和渐进增强">优雅降级和渐进增强</h4>
<pre><code>渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。
优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。
</code></pre>
<h1 id="小程序">小程序</h1>
<h4 id="小程序接口必须是https-你写的项目中是谁操作的">小程序接口必须是https 你写的项目中是谁操作的</h4>
<pre><code>这个配置是公司后端/运维配置的，但是我个人对编程还是比较喜欢研究的 然后呢我就自己谷歌了一把发现就是去腾讯、阿里云申请证书，然后修改nginx配置就行。我当时用的是免费版，收费版没试过。
</code></pre>
<h4 id="小程序微信登录时怎么实现的">小程序微信登录时怎么实现的</h4>
<pre><code>首先通过wx.login和wx.reqeuset获取openid  然后根据API去获取用户的昵称和头像
</code></pre>
<h4 id="小程序项目你做过哪些优化">小程序项目你做过哪些优化</h4>
<pre><code>静态资源优化:
图片懒加载
七牛云对象存储
cdn加速
expires     之前给大家发的nginx课件里面有
gzip        之前给大家发的nginx课件里面有
后端接口优化:
接口开发规范restful api
接口安全（https）
接口性能（多台数据库、缓存服务器redis存内存等）
</code></pre>
<h4 id="咱们项目开发完毕发小超过2m-如果解决">咱们项目开发完毕发小超过2M 如果解决</h4>
<pre><code>静态资源 咱们可以分离项目 放到CDN服务器上  
太大了可以讲一个小程序变成2个小程序  这样就是4M  
然后通过声明式导航、编程式导航，点击直接跳转到另一个小程序即可。
</code></pre>
<h3 id="将一个div盒子水平垂直居中">将一个div盒子水平垂直居中</h3>
<pre><code>    .parent{
        width: 500px;
        height: 500px;
        border: 1px solid red;
    }
    .child{
        width: 100px;
        height: 100px;
        border: 1px slid #111;
    }
    
    
     &lt;div class=&quot;parent&quot;&gt;
         &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;
     &lt;/div&gt;
     
     
方法一：利用定位（常用方法,推荐）

.parent{

    position:relative;

    }

.child{

    position:absolute;

    top:50%;

    left:50%;

    margin-top:-50px;

    margin-left:-50px;

    }

方法一的原理就是定位中心点是盒子的左上顶点，所以定位之后我们需要回退盒子一半的距离。

 

方法二：利用margin:auto;

.parent{

    position:relative;

    }

.child{

    position:absolute;

    margin:auto;

    top:0;

    left:0;

    right:0;

    bottom:0;

    }

方法三：利用display:table-cell;

.parent{

    display:table-cell;

    vertical-align:middle;

    text-align:center;

    }

.child{

    display:inline-block;

    }

方法四：利用display：flex;设置垂直水平都居中；

.parent{

    display:flex;

    justify-content:center;

    align-items:center;

    }

方法五：计算父盒子与子盒子的空间距离(这跟方法一是一个道理)；

计算方法：父盒子高度或者宽度的一半减去子盒子高度或者宽的的一半。

.child{

    margin-top:200px;

    margin-left:200px;

    }

方法六：利用transform

.parent{

    position:relative;

    }

.child{

    position:absolute;

    top:50%;

    left:50%;

    transform:translate(-50%,-50%);

    }

方法七：利用calc计算

.parent{

    position:relative;

    }

.child{

    position:absolute;

    top:calc(200px);//（父元素高-子元素高）÷ 2=200px

    let:calc(200px);//（父元素宽-子元素宽）÷ 2=200px

    }
</code></pre>
<h1 id="vue中更新是异步还是同步的为什么">Vue中更新是异步还是同步的,为什么?</h1>
<ul>
<li>数据是同步更新，视图是异步更新</li>
<li>因为如果视图更新是同步的，那会导致多次渲染浪费不必要的性能，没必要，内部做了去重(重新更新的值)和防抖(只更新最后一次)</li>
</ul>
<h1 id="什么是promise">什么是Promise</h1>
<p>Promise 是异步编程的一种解决方案，其实是一个构造函数，自己身上有all、reject、resolve这几个方法，原型上有then、catch等方法  可以很好地解决<strong>回调地狱</strong>的问题（避免了层层嵌套的回调函数） ， 语法非常简洁</p>
<p><code>Promise</code>对象有以下两个特点。</p>
<p>特点1： 对象的状态不受外界影响。</p>
<p>​			解释： <code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和						<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无						法改变这个状态。</p>
<p>特点2： 一旦状态改变，就不会再变，任何时候都可以得到这个结果。</p>
<p>​			解释：Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要						这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定						型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。</p>
<h2 id="单行文本溢出显示省略号">单行文本溢出，显示省略号</h2>
<pre><code>.div_text{
             width: 300px; 
             overflow: hidden;
             text-overflow: ellipsis; 
             white-space: nowrap;
             }
</code></pre>
<h2 id="多行文本溢出显示省略号">多行文本溢出，显示省略号</h2>
<pre><code> .div_moreline{
            width: 300px; 
            display:-webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 3;
            overflow: hidden; 
            max-height: 90px;
            }
</code></pre>
<h2 id="css手写一个三角形">css手写一个三角形:</h2>
<pre><code>  .triangle{
            width: 0;
            height: 0;
            border: 50px solid transparent;
            border-top-color: black ;
        }

</code></pre>
<h1 id="vue-cli30兼容20版本">vue-cli3.0兼容2.0版本</h1>
<p>npm install -g @vue/cli-init</p>
<h1 id="什么时候视图不会更新">什么时候视图不会更新?</h1>
<pre><code>//1.操作数组的索引
//2.操作数组的length
//以上两种情况都不会更新视图
</code></pre>
<h1 id="为什么操作这两个属性不会更新视图">为什么操作这两个属性不会更新视图?</h1>
<pre><code>//原因就是因为Vue2.0底层响应式原理使用了ES5中的Object.defineProperty()这个方法,这个方法有个缺点,缺点就是无法劫持数组,数组的变化是没有办法进行响应
    //操作一些数组的方法 比如push pop shift unshift reverse等方法会触发视图的更新,因为vue的底层特别对这几个方法做了hack处理,只要我们调用这些方法也会视图的更新
    //Vue3.0的版本,使用的proxy这个方法,这个方法可以劫持数组,就不会出现操作索引和length不更新视图的情况了
</code></pre>
<h1 id="怎么处理不更新的问题">怎么处理不更新的问题?</h1>
<pre><code> //1.不要操作数组的length和索引,如果说硬要操作,可以使用Vue.$set(target,key,value)方法
 //2.如果说操作了这些属性,不知道问题在哪里,解决不了视图不更新的情况,我们可以调用强制更新$forceUpdate()
</code></pre>
<h1 id="v-for中有个属性keykey的作用是什么">v-for中有个属性,key,key的作用是什么?</h1>
<pre><code>用于区分diff算法的时候,元素的唯一性
//key的值,正常情况下一般都要给一个唯一的值,如果没有一个惟一的情况下,那么可以暂时的使用index来代替
//写项目的时候,后台返回的数据肯定有id,那么这个id就是唯一的标识所以我们一般使用id来作为key的值
</code></pre>
<h1 id="v-model的修饰符">v-model的修饰符 ?</h1>
<pre><code>trim lazy number
</code></pre>
<h1 id="v-if-v-show的区别-以及使用场景">V-if v-show的区别 以及使用场景</h1>
<pre><code>//v-if 都是用于控制元素/组件的显示和隐藏 值都是布尔值,如果布尔值为true那么元素就会显示,如果为false,那么元素或者组件就会隐藏 v-if元素不显示的时候,dom结构也会一并移除
//v-if可以和v-else v-else-if结合使用,如果v-if布尔值为true,那么不会展示v-else的内容,如果布尔值为false,那么就会展示v-else,而不会展示v-if,两者的关系,就是老死不相往来,互斥
//v-show  都是用于控制元素/组件的显示和隐藏 值都是布尔值,如果布尔值为true那么元素就会显示,如果为false,那么元素或者组件就会隐藏 v-show隐藏元素之后,不会移除dom结构

//使用场景:首次渲染开销较大的时候,可以使用v-if 频繁切换的时候使用v-show
</code></pre>
<h1 id="v-on的修饰符">v-on的修饰符</h1>
<pre><code>//prevent 阻止默认事件
//ocne 只调用一次
//native 触发组件根元素的原生事件
</code></pre>
<h1 id="定义自定义指令的方式以及自定义指令的钩子函数">定义自定义指令的方式,以及自定义指令的钩子函数</h1>
<pre><code>//bind
//inserted
//update
</code></pre>
<h1 id="计算属性的特点">计算属性的特点?</h1>
<pre><code> //1.计算的结果会缓存
 //2.根据外界响应式依赖发生变化而变化
</code></pre>
<h1 id="watch监听的三种情况和写法">watch监听的三种情况和写法</h1>
<pre><code>普通监听
深度监听
字符串写法
</code></pre>
<h1 id="v-if-v-for的优先级">v-if v-for的优先级</h1>
<pre><code>v-for优先级别高
</code></pre>
<h1 id="全局组件和局部组件创建方式">全局组件和局部组件创建方式</h1>
<pre><code>全局组件的创建
	利用Vue.component来创建全局组件
	vue.component( &quot;vheader&quot;,{
        template: 
        `&lt;div&gt;
        我是全局组件&lt;/div&gt;`
        })
     可以直接使用&lt;vheader&gt;&lt;/vheader&gt;,不需要挂载
     
 
局部组件创建
	（1）创建一个局部组件,举例，命名为App。
	（2）利用组件的components，将App挂载上去。
	（3）在页面使用&lt;App&gt;&lt;/App&gt;即可.
&lt;script&gt;
    const App = {  //创建
        template:`
        &lt;h3&gt;我是App组件&lt;/h3&gt;`
        }
    new vue({
    	el: '#app',
    	data:{},
    	components:{
   			App  //挂载
    	}
    })
 &lt;/ script&gt;


</code></pre>
<h1 id="组件的通信方式-写出所有的">组件的通信方式 写出所有的</h1>
<pre><code>父子传值：props
子父传值:$emit
eventbus
refs
$root
$parent
vueX

</code></pre>
<h1 id="在组件上使用v-model流程">在组件上使用v-model流程</h1>
<pre><code>父组件:子标签上v-model=&quot;val&quot;
子组件:input标签上动态绑定value :value=&quot;value&quot;
注册事件input
@input: 'ipt'
在methods中定义ipt事件，接收参数
    ipt(e){
        this.$emit('input',e.target.value)
    }
原理:语法糖默认接受value的props，默认发射input的事件出去
</code></pre>
<h1 id="封装组件的流程">封装组件的流程</h1>
<pre><code> 1.使用Vue.extend()创建一个组件

 2.使用Vue.component()方法注册组件

 3.如果子组件需要数据，可以在props中接受定义

 4.子组件修改好数据之后，想把数据传递给父组件，可以使用emit()方法
</code></pre>
<h1 id="slot具名插槽-插槽作用域">slot具名插槽 插槽作用域</h1>
<pre><code>1.具名插槽：给slot加上name属性，添加内容时，标签上 v-slot:name属性值
    举例：	
    &lt;div id=&quot;app&quot;&gt;
            &lt;sdh-com&gt;
                &lt;template v-slot:header&gt;
                    &lt;div class=&quot;header&quot;&gt;
                        &lt;h1&gt;这是顶部栏&lt;/h1&gt;
                    &lt;/div&gt;
                &lt;/template&gt;
            &lt;/sdh-com&gt;
     &lt;/div&gt;
    &lt;template id=&quot;sdh&quot;&gt;
        &lt;fieldset&gt;
            &lt;div id=&quot;header&quot;&gt;
                &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/fieldset&gt;
    &lt;/template&gt;

     &lt;script&gt;
         Vue.component('sdh-com', {
            data() {
                return {

                }
            },
            template: '#sdh'
        })

        const vm = new Vue({
            el: &quot;#app&quot;,
            data: {

            }
        })
    &lt;/script&gt;
    
    
2.插槽作用域：将组件内部的数据传递给分发的内容进行渲染，再通过solt接收分发内容
	举例：
		&lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;

        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
            &lt;title&gt;03.插槽slot.html&lt;/title&gt;
        &lt;/head&gt;

        &lt;body&gt;
            &lt;div id=&quot;app&quot;&gt;
                &lt;sdh-com&gt;
                    &lt;template v-slot=&quot;{arr}&quot;&gt;
                        &lt;ul&gt;
                            &lt;li v-for=&quot;(item,index) in arr&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/li&gt;
                        &lt;/ul&gt;
                    &lt;/template&gt;
                &lt;/sdh-com&gt;
            &lt;/div&gt;
        &lt;/body&gt;

        &lt;/html&gt;

        &lt;template id=&quot;sdh&quot;&gt;
            &lt;fieldset&gt;
                &lt;legend&gt;苏大海&lt;/legend&gt;
                &lt;h1&gt;{{girlFriend}}&lt;/h1&gt;
                &lt;slot :arr=&quot;arr&quot;&gt;&lt;/slot&gt;
            &lt;/fieldset&gt;
        &lt;/template&gt;

        &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
            //插槽作用域
            //将组件内部的数据传递给分发的内容进行渲染
            //再通过solt接收分发内容
            Vue.component('sdh-com', {
                data() {
                    return {
                        girlFriend: '乔姑娘',
                        arr: [&quot;黄瓜&quot;, '香蕉', '茄子', '山药', '莲藕']
                    }
                },
                template: '#sdh'
            })

            const vm = new Vue({
                el: &quot;#app&quot;,
                data: {
                    msg: &quot;那是&quot;
                }
            })
        &lt;/script&gt;

	
</code></pre>
<h1 id="mixins合并策略">Mixins合并策略</h1>
<pre><code>//1.如果说混入了data属性,那么会对data进行递归合并,冲突的时候,以组件的属性优先

//2.同名的钩子函数会被合并为一个数组,都会进行调用,会以混入对象的钩子函数优先调用

//3.组件选项 比如methods directives components filters...都会被合并为一个对象,冲突的时候,以组件的键值对为主
</code></pre>
<h1 id="nexttick的作用">$nextTick的作用</h1>
<pre><code>在下次dom,更新循环结束后执行延迟回调,在修改数据之后立即使用,获取更新后的dom元素
</code></pre>
<h1 id="vue生命周期钩子函数-created中能不能修改data-为什么">vue生命周期钩子函数 created中能不能修改data 为什么?</h1>
<pre><code>可以，在这里可以获取data,并且事件监听也添加上了,数据已经被劫持,观察者就绪,在这个钩子函数中可以修改data

</code></pre>
<h1 id="发送异步请求在哪个钩子">发送异步请求在哪个钩子?</h1>
<pre><code>created mounted
</code></pre>
<h1 id="beforedestroy和destroyed一般用来做什么">beforeDestroy和destroyed一般用来做什么?</h1>
<pre><code>销毁定时器，解绑全部指令及事件监听，清除全局事件等
</code></pre>
<h1 id="keep-alive的作用以及使用方式-钩子函数-以及两个属性的用法">keep-alive的作用以及使用方式 钩子函数 以及两个属性的用法</h1>
<pre><code>作用:缓存组件
钩子函数:activated deactivated
属性:include包含的组件会被缓存，exclude排除的组件不会被缓存

</code></pre>
<h1 id="组件相互嵌套钩子函数的执行顺序是什么">组件相互嵌套,钩子函数的执行顺序是什么?</h1>
<pre><code>父组件beforeCreated  ==》父组件created  ==》父组件beforeMount  ==》
子组件beforeCreated  ==》子组件created  ==》子组件beforeMount  ==》子组件mounted  ==》
父组件mounted
</code></pre>
<h1 id="父组件的beforeupdate触发了会不会触发子组件的beforeupdate">父组件的beforeUpdate触发了会不会触发子组件的beforeUpdate?</h1>
<pre><code>不会
</code></pre>
<h1 id="为什么beforecreate不能发请求">为什么beforeCreate不能发请求?</h1>
<pre><code>因为$data都还没初始化,就算获得了后台数据,也不能修改data
</code></pre>
<h1 id="什么是虚拟dom">什么是虚拟dom?</h1>
<pre><code>通过js模拟真实dom的嵌套,创建新的页面的结构,就是虚拟dom,在内存中,页面是看不见的,只有添加到页面上才能看见
</code></pre>
<h1 id="为什么要使用虚拟dom">为什么要使用虚拟dom?</h1>
<pre><code>使用虚拟dom,可以在内存中更新结构,而不是操作真实dom一个一个更新,最大的好处提高页面渲染的性能,结合diff算法 让页面进行高效更新
</code></pre>
<h1 id="vue响应式的原理是什么">Vue响应式的原理是什么?</h1>
<pre><code>　　Vue 的响应式原理是核心是通过 ES5 的保护对象的 Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM 树上。
</code></pre>
<h1 id="什么是回流-什么是重绘">什么是回流 什么是重绘?</h1>
<h1 id="32触发回流的条件-触发重绘的条件">32.触发回流的条件 触发重绘的条件?</h1>
<pre><code># 回流
1. 位置的改变 translate 定位的left top 
2. 元素位置的显示和隐藏也会引起回流
3. 宽高的变化
# 重绘
1. 颜色的变化
2. 字体风格的变化
3. 背景的变化
</code></pre>
<h1 id="33什么是单页应用">33.什么是单页应用?</h1>
<pre><code>一个项目只有一个html页面 所有的页面跳转依据于路由进行
</code></pre>
<h1 id="34单页应用的有点和缺点">34.单页应用的有点和缺点?</h1>
<pre><code>用户体验好,切换速度快,不需要刷新整个页面
</code></pre>
<h1 id="35怎么解决单页应用缺点的问题">35.怎么解决单页应用缺点的问题?</h1>
<pre><code>使用服务端渲染 nuxt
</code></pre>
<h1 id="36history-hash-abstract模式的区别">36.History hash abstract模式的区别?</h1>
<pre><code>1. hash有#号,#号后面的url不会向后端发起请求

2. hash路由使用onhashchange监听 history使用onpopstate监听 

3. history使用的是H5的api pushState replaceState
4. 当hash值相同时,不会触发hashchange,history当输入相同的路径的时候,会将浏览器中的地址当成是请求地址向后台发送请求,会造成页面404
5. abstract模式是在没有浏览器api的情况下自动启用,abstract模式在切换页面的时候,路径是不会发生变化的

6. 关键字 onhashchange pushstate replacestate popstate
7. 
</code></pre>
<h1 id="37动态路由参数解耦合步骤">37.动态路由参数解耦合步骤</h1>
<pre><code>再path路径下，通过props:true解耦，使用，通过props:['动态参数']
</code></pre>
<h1 id="38vuex中的state能映射到组件的data中吗为什么">38.vuex中的state能映射到组件的data中吗?为什么?</h1>
<pre><code>其实可以直接映射在data中,只是使用的时候要加（）不方便将state映射给data中的某一个属性
会造成vuex更新之后视图不更新只有computed才会根据依赖发生改变而改变

</code></pre>
<h1 id="39修改vuex中state唯一的方式是什么只有mutation中可以修改嘛哪些方式还可以修改state的状态">39.修改vuex中state唯一的方式是什么?只有mutation中可以修改嘛?哪些方式还可以修改state的状态?</h1>
<pre><code>mutation
有很多种方式可以修改state，比如getters，比如直接修改，比如action中可以直接修改。但是这些修改不符合vuex的设计原则;所以规定修改state，必需通过mutation进行更改

</code></pre>
<h1 id="40组件中的data为什么要写成一个函数">40.组件中的data为什么要写成一个函数?</h1>
<pre><code>因为如果data是一个对象则会造成数据共享，在多次使用该组件的时候，改变其中一个值会影响全部该组件的值。而如果是通过函数的形式返回出一个对象的话，在每次使用该组件时返回出的对象的地址指向是不一样的，这样子能让各个组件的数据独立。
</code></pre>
<h1 id="41说一下vuex异步的操作流程">41.说一下vuex异步的操作流程</h1>
<pre><code>action中发送异步请求，结果通过commit提交mutation
</code></pre>
<h1 id="网络安全">网络安全</h1>
<h2 id="xss攻击">XSS攻击</h2>
<blockquote>
<p><strong>跨网站指令码</strong>（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程式的安全漏洞攻击，是<a href="https://www.wikiwand.com/zh-hans/%E4%BB%A3%E7%A2%BC%E6%B3%A8%E5%85%A5">代码注入</a>的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。</p>
</blockquote>
<p>XSS 分为三种：反射型，存储型和 DOM-based</p>
<h3 id="如何攻击">如何攻击</h3>
<p>XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。</p>
<p>例如通过 URL 获取某些参数</p>
<pre><code class="language-html">&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;
&lt;div&gt;{{name}}&lt;/div&gt;
</code></pre>
<p>上述 URL 输入可能会将 HTML 改为 <code>alert(1)</code> ，这样页面中就凭空多了一段可执行脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻击。</p>
<p>也有另一种场景，比如写了一篇包含攻击代码 <code>alert(1)</code> 的文章，那么可能浏览文章的用户都会被攻击到。这种攻击类型是存储型攻击，也可以说是 DOM-based 攻击，并且这种攻击打击面更广。</p>
<h3 id="如何防御">如何防御</h3>
<p>最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义</p>
<pre><code class="language-js">function escape(str) {
  str = str.replace(/&amp;/g, '&amp;amp;')
  str = str.replace(/&lt;/g, '&amp;lt;')
  str = str.replace(/&gt;/g, '&amp;gt;')
  str = str.replace(/&quot;/g, '&amp;quto;')
  str = str.replace(/'/g, '&amp;#39;')
  str = str.replace(/`/g, '&amp;#96;')
  str = str.replace(/\//g, '&amp;#x2F;')
  return str
}
</code></pre>
<p>通过转义可以将攻击代码 <code>alert(1)</code> 变成</p>
<pre><code class="language-js">// -&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt;
escape('&lt;script&gt;alert(1)&lt;/script&gt;')
</code></pre>
<p>对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</p>
<pre><code class="language-js">var xss = require('xss')
var html = xss('&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;')
// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert(&quot;xss&quot;);&amp;lt;/script&amp;gt;
console.log(html)
</code></pre>
<p>以上示例使用了 <code>js-xss</code> 来实现。可以看到在输出中保留了 <code>h1</code> 标签且过滤了 <code>script</code> 标签</p>
<h3 id="csp攻击">CSP攻击</h3>
<blockquote>
<p>内容安全策略 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/CSP">CSP</a>) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/XSS">XSS</a>) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。</p>
</blockquote>
<p>我们可以通过 CSP 来尽量减少 XSS 攻击。CSP 本质上也是建立白名单，规定了浏览器只能够执行特定来源的代码。</p>
<p>通常可以通过 HTTP Header 中的 <code>Content-Security-Policy</code> 来开启 CSP</p>
<ul>
<li>
<p>只允许加载本站资源</p>
<pre><code class="language-http">Content-Security-Policy: default-src ‘self’
</code></pre>
</li>
<li>
<p>只允许加载 HTTPS 协议图片</p>
<pre><code class="language-http">Content-Security-Policy: img-src https://*
</code></pre>
</li>
<li>
<p>允许加载任何来源框架</p>
<pre><code class="language-http">Content-Security-Policy: child-src 'none'
</code></pre>
</li>
</ul>
<p>更多属性可以查看 <a href="https://content-security-policy.com/">这里</a></p>
<h2 id="csrf攻击">CSRF攻击</h2>
<blockquote>
<p><strong>跨站请求伪造</strong>（英语：Cross-site request forgery），也被称为 <strong>one-click attack</strong> 或者 <strong>session riding</strong>，通常缩写为 <strong>CSRF</strong> 或者 <strong>XSRF</strong>， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。[<a href="https://www.wikiwand.com/zh/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0#citenoteRistic1">1]</a> 跟<a href="https://www.wikiwand.com/zh/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC">跨網站指令碼</a>（XSS）相比，<strong>XSS</strong> 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p>
</blockquote>
<p>简单点说，CSRF 就是利用用户的登录态发起恶意请求。</p>
<h3 id="csrf漏洞现状">CSRF漏洞现状</h3>
<p>CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI......而现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。</p>
<h3 id="如何攻击-2">如何攻击</h3>
<p>假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口</p>
<pre><code class="language-html">&lt;img src=&quot;http://www.domain.com/xxx?comment='attack'&quot; /&gt;
</code></pre>
<p>如果接口是 Post 提交的，就相对麻烦点，需要用表单来提交接口</p>
<pre><code class="language-html">&lt;form action=&quot;http://www.domain.com/xxx&quot; id=&quot;CSRF&quot; method=&quot;post&quot;&gt;
  &lt;input name=&quot;comment&quot; value=&quot;attack&quot; type=&quot;hidden&quot; /&gt;
&lt;/form&gt;
</code></pre>
<h3 id="如何防御-2">如何防御</h3>
<p>防范 CSRF 可以遵循以下几种规则：</p>
<ol>
<li>Get 请求不对数据进行修改</li>
<li>不让第三方网站访问到用户 Cookie (httponly:true;ali.com)</li>
<li>阻止第三方网站请求接口</li>
<li>请求时附带验证信息，比如验证码或者 token</li>
</ol>
<h4 id="samesite">SameSite</h4>
<p>可以对 Cookie 设置 <code>SameSite</code> 属性。该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。</p>
<h4 id="验证-referer">验证 Referer</h4>
<p>对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。</p>
<h4 id="token">Token</h4>
<p>服务器下发一个随机 Token（算法不能复杂），每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。</p>
<h2 id="密码安全">密码安全</h2>
<p>密码安全虽然大多是后端的事情，但是作为一名优秀的前端程序员也需要熟悉这方面的知识。</p>
<h3 id="加盐">加盐</h3>
<p>对于密码存储来说，必然是不能明文存储在数据库中的，否则一旦数据库泄露，会对用户造成很大的损失。并且不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系。</p>
<p>通常需要对密码加盐，然后进行几次不同加密算法的加密。</p>
<pre><code class="language-js">// 加盐也就是给原密码添加字符串，增加原密码长度
sha256(sha1(md5(salt + password + salt)))
</code></pre>
<p>但是加盐并不能阻止别人盗取账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而应该提示账号或密码错误。</p>
<h1 id="vue中的render函数介绍">vue中的render函数介绍</h1>
<p><strong>render函数是什么</strong> ：</p>
<p>​	 简单的说，在vue中我们使用模板HTML语法组建页面的，使用render函数我们可以用js语言来构建DOM</p>
<p>​	 因为vue是虚拟DOM，所以在拿到template模板时也要转译成VNode的函数，而用render函数构建DOM，vue	就免去了转译的过程。</p>
<p>​	 使用render函数描述虚拟DOM时，vue提供一个函数，这个函数是就构建虚拟DOM所需要的工具。</p>
<h1 id="mvvm和mvc的区别"><strong>MVVM和MVC的区别</strong></h1>
<p>MVC和MVVM的区别其实并不大。都是一种设计思想。</p>
<p>主要就是MVC中Controller演变成MVVM中的viewModel。</p>
<p>MVVM主要解决了MVC中大量的DOM操作使页面渲染性能降低，加载速度变慢，影响用户体验。</p>
<p>当和Model频繁发生变化，开发者需要主动更新到View。</p>
<p><strong>MVVM设计模式的优点</strong></p>
<ol>
<li>
<p>双向绑定技术，当Model变化时，View-Model会自动更新，View也会自动变化。很好的做到数据的一致性</p>
</li>
<li>
<p>由于控制器的功能大都移动到View上处理，大大的对控制器进行了瘦身</p>
</li>
<li>
<p>View的功能进一步强化，具有控制的部分功能，</p>
<p>若想无限增强它的功能，甚至控制器的全部功能几乎都可以迁移到各个View上</p>
</li>
</ol>
<p>（不过这样不可取，那样View干不了属于它职责范围内的事情）。</p>
<p>View可以像控制器一样具有自己都View-Model</p>
<ol start="4">
<li>
<p>可以对View或ViewController的数据处理部分抽象出来一个函数处理model。</p>
<p>这样它们专职页面布局和页面跳转，它们必然更一步的简化。</p>
</li>
</ol>
<p><strong>MVVM设计模式的缺点</strong></p>
<ol>
<li>
<p>数据绑定也使得bug很难被调试。比如你看到页面异常了，有可能是你的View的代码有bug，也可能是你的model的代码有问题。数据绑定使得一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。</p>
</li>
<li>
<p>数据双向绑定不利于代码重用。客户端开发最常用的是View，但是数据双向绑定技术，让你在一个View都绑定了一个model，不同的模块model都不同。那就不能简单重用view了</p>
</li>
<li>
<p>一个大的模块中model也会很大，虽然使用方便了也很容易保证数据的一致性，但是长期持有，不释放内存就造成话费更多的内存。</p>
<h1 id="-2"></h1>
</li>
</ol>
<h1 id="let-const-var的区别">let、const、var的区别</h1>
<pre><code>const声明的是常量，必须赋值
    1）一旦声明必须赋值,不能使用null占位。
    2）声明后不能再修改
    3）如果声明的是复合类型数据，可以修改其属性

let和var声明的是变量，声明之后可以更改，声明时可以不赋值

var允许重复声明变量，后一个变量会覆盖前一个变量。

let和const在同一作用域不允许重复声明变量，会报错。

var声明的变量存在变量提升（将变量提升到当前作用域的顶部）。即变量可以在声明之前调用，值为undefined。
let和const不存在变量提升。即它们所声明的变量一定要在声明后使用，否则报ReferenceError错。


var：只有全局作用域和函数作用域概念，没有块级作用域的概念。但是会把{}内也假称为块作用域。
let const：只有块级作用域的概念 ，由 { } 包括起来，if语句和for语句里面的{ }也属于块级作用域。
ES5中作用域有：全局作用域、函数作用域。没有块作用域的概念。
ES6(简称ES6)中新增了块级作用域。块作用域由 { } 包括，if语句和for语句里面的{ }也属于块作用域。

ES6明确规定：如果区块中存在let命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
            所以在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。
</code></pre>
<h1 id="v-model是如何实现的语法糖">v-model是如何实现的，语法糖</h1>
<h3 id="1作用再普通的表单元素上">1.作用再普通的表单元素上</h3>
<ul>
<li>
<h4 id="动态绑定input的value指向的自定义的变量并且在触发input事件的时候去动态把自定义变量设置为目标值">动态绑定input的value指向的自定义的变量，并且在触发input事件的时候去动态把自定义变量设置为目标值</h4>
</li>
</ul>
<h3 id="2作用在组件上">2.作用在组件上</h3>
<ul>
<li>
<h4 id="是一个父子组件通信的语法糖通过props和emit实现">是一个父子组件通信的语法糖，通过props和$emit实现</h4>
<p>参考组件使用v-model流程</p>
</li>
</ul>
<pre><code>
&lt;input v-model=&quot;a&quot; /&gt;
input元素
&lt;input :value=&quot;a&quot; @input=&quot;a = $event.target.value&quot; /&gt; // $event.target.value
就是把input的值赋值给 a 

对于非input元素 
如果在自定义组件中，v-model
默认会利用名为 value 的 prop 和名为 input 的事件，如下所示： 

父组件：
&lt;ModelChild v-model=&quot;message&quot;&gt;&lt;/ModelChild&gt;

子组件：
&lt;div&gt;{{value}}&lt;/div&gt;
props:{ value: String }, 
methods: { 
    test1(){ 
        this.$emit('input', '小红') 
    }, 
},
</code></pre>
<p>，</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IDEA的使用]]></title>
        <id>https://chenggr.github.io/post/idea-de-shi-yong/</id>
        <link href="https://chenggr.github.io/post/idea-de-shi-yong/">
        </link>
        <updated>2021-11-22T01:34:24.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>记录IDEA常用快捷键配置。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>记录IDEA常用快捷键配置。</p>
</blockquote>
<!--more-->
<h3 id="idea常用快捷键">IDEA常用快捷键</h3>
<ul>
<li>
<p>删除当前行<br>
ctrl + d</p>
</li>
<li>
<p>复制当前行<br>
ctrl + alt + 向下光标</p>
</li>
<li>
<p>补全代码<br>
alt + /</p>
</li>
<li>
<p>添加和取消注释<br>
ctrl + /</p>
</li>
<li>
<p>导入该行需要的类 先配置auto import，然后使用<br>
alt + enter</p>
</li>
<li>
<p>快速格式化代码<br>
alt + ctrl + L</p>
</li>
<li>
<p>快速运行程序 自定义<br>
alt + R</p>
</li>
<li>
<p>生成构造器 generate<br>
control + N</p>
</li>
<li>
<p>查看一个类的层级关系<br>
control + H</p>
</li>
<li>
<p>把光标放在方法上，ctrl + B，可以定位到方法</p>
</li>
<li>
<p>自动分配变量名，通过在后面加 .var</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我的macOS常用软件及配置]]></title>
        <id>https://chenggr.github.io/post/wo-de-macos-chang-yong-ruan-jian-ji-pei-zhi/</id>
        <link href="https://chenggr.github.io/post/wo-de-macos-chang-yong-ruan-jian-ji-pei-zhi/">
        </link>
        <updated>2019-05-22T09:13:08.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>记录我的某些常用软件及配置，方便以后查看。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>记录我的某些常用软件及配置，方便以后查看。</p>
</blockquote>
<!--more-->
<h1 id="破解软件下载地址">破解软件下载地址</h1>
<p><a href ="https://xclient.info/">精品 MAC 应用分享</a><br>
<a href ="https://www.macbl.com/">马可菠萝</a></p>
<h1 id="软件">软件</h1>
<ul>
<li>
<p>chrome &amp; chrome 插件<br>
划词翻译<br>
web 前端助手（FeHelper）</p>
</li>
<li>
<p>可能需要用到的<br>
MacBooster 7（清理垃圾、内存）<br>
Dr. Unarchiver（解压）<br>
iStatistica（查看内存、网络、网速、等等）</p>
</li>
</ul>
<hr>
<ul>
<li>Sourcetree（git）</li>
<li>SmartSVN（svn）</li>
<li>微信开发者工具</li>
<li>Navicat Premium（数据库）</li>
<li>Sublime Text3（编辑器）</li>
<li>MAMP PRO（服务器）</li>
<li>Postman（接口）</li>
<li>Charles（抓包）</li>
<li>Vscode（编译器）</li>
</ul>
<hr>
<h1 id="配置">配置</h1>
<h2 id="vscode">vscode</h2>
<pre><code class="language-javascript">{
  &quot;editor.detectIndentation&quot;: false,
  // 重新设定 tabsize
  &quot;editor.tabSize&quot;: 2,
  // #每次保存的时候自动格式化
  &quot;editor.formatOnSave&quot;: true,
  // #每次保存的时候将代码按 eslint 格式进行修复
  &quot;eslint.autoFixOnSave&quot;: true,
  // 添加 vue 支持
  &quot;eslint.validate&quot;: [
    &quot;javascript&quot;,
    &quot;javascriptreact&quot;,
    {
    &quot;language&quot;: &quot;vue&quot;,
    &quot;autoFix&quot;: true
    }
  ],
  // #让 prettier 使用 eslint 的代码格式进行校验
  &quot;prettier.eslintIntegration&quot;: true,
  // #去掉代码结尾的分号
  &quot;prettier.semi&quot;: false,
  // #使用带引号替代双引号
  &quot;prettier.singleQuote&quot;: true,
  // #让函数(名)和后面的括号之间加个空格
  &quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true,
  // #这个按用户自身习惯选择
  &quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;,
  // #让 vue 中的 js 按编辑器自带的 ts 格式进行格式化
  &quot;vetur.format.defaultFormatter.js&quot;: &quot;vscode-typescript&quot;,
  &quot;vetur.format.defaultFormatterOptions&quot;: {
    &quot;js-beautify-html&quot;: {
    &quot;wrap_attributes&quot;: &quot;force-aligned&quot;
    // #vue 组件中 html 代码格式化样式
    }
  },
  // 格式化 stylus, 需安装 Manta's Stylus Supremacy 插件
  &quot;stylusSupremacy.insertColons&quot;: false, // 是否插入冒号
  &quot;stylusSupremacy.insertSemicolons&quot;: false, // 是否插入分好
  &quot;stylusSupremacy.insertBraces&quot;: false, // 是否插入大括号
  &quot;stylusSupremacy.insertNewLineAroundImports&quot;: false, // import 之后是否换行
  &quot;stylusSupremacy.insertNewLineAroundBlocks&quot;: false, // 两个选择器中是否换行
  &quot;eslint.options&quot;: {
    &quot;plugins&quot;: [&quot;html&quot;]
  },
  &quot;editor.fontSize&quot;: 13
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[interview-js]]></title>
        <id>https://chenggr.github.io/post/interview-js/</id>
        <link href="https://chenggr.github.io/post/interview-js/">
        </link>
        <updated>2019-05-22T08:38:02.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>imooc 的 javascript 笔记</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>imooc 的 javascript 笔记</p>
</blockquote>
<!--more-->
<h1 id="原型规则和示例">原型规则和示例</h1>
<ul>
<li>所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（除了“null”以外）</li>
<li>所有的引用类型（数组、对象、函数），都有一个 ** proto ** (隐式原型)属性，属性值是一个普通的对象</li>
<li>所有的函数，都有一个 prototype(显示原型)属性，属性值也是一个普通对象</li>
<li>所有的引用类型（数组、对象、函数），** proto ** (隐式原型)属性值指向它的构造函数的“prototype”(显示类型)属性值 <strong>obj. ** porto ** === Object.prototype</strong></li>
<li>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的 ** proto **(即它的构造函数的 prototype)中寻找</li>
</ul>
<h1 id="作用域和闭包">作用域和闭包</h1>
<p>执行上下文</p>
<p>this</p>
<p>作用域</p>
<p>作用域链</p>
<p>闭包</p>
<h2 id="执行上下文">执行上下文</h2>
<p>范围：一段 &lt; script &gt; 或者一个函数</p>
<p>全局：变量定义、函数声明</p>
<p>函数：变量定义、函数声明、this、arguments</p>
<p>Ps：函数声明 和 函数表达式 的区别</p>
<h2 id="this">this</h2>
<p>this 要执行时才能确认值，定义时无法确认</p>
<pre><code class="language-javascript">var a = {
  name: 'A',
  fn: function() {
    console.log(this.name)
  }
}
a.fn() // this === a
a.fn.call({ name: 'B' }) // this === {name: 'B'}
var fn1 = a.fn
fn1() // this === window
</code></pre>
<ul>
<li>作为构造函数执行</li>
<li>作为对象属性执行</li>
<li>作为普通函数执行</li>
<li>call apply bind</li>
</ul>
<pre><code class="language-javascript">function Foo(name) {
  this.name = name
}
var f = new Foo('zhangsan')
</code></pre>
<pre><code class="language-javascript">var obj = {
  name: 'A',
  printName: function() {
    console.log(this.name)
  }
}
obj.printName() // this === obj
</code></pre>
<pre><code class="language-javascript">function fn() {
  console.log(this) // this === window
}
fn()
</code></pre>
<pre><code class="language-javascript">// call apply bind
function fn1(name, age) {
  alert(name)
  console.log(this)
}
fn1.call({ x: 100 }, 'zhangsan', 20) // this === {x:100}
fn1.apply({ x: 100 }, ['zhangsan', 20])

var fn2 = function(name, age) {
  alert(name)
  console.log(this)
}.bind({ y: 200 })
fn2('zhangsan', 20)
</code></pre>
<p>作用域</p>
<ul>
<li>
<p>没有块级作用域</p>
</li>
<li>
<p>只有函数和全局作用域</p>
<p>​</p>
</li>
</ul>
<pre><code class="language-javascript">// 无块级作用域
if (true) {
  var name = 'zhangsan'
}
console.log(name)

// 函数和全局作用域
var a = 100
function fn() {
  var a = 200
  console.log('fn', a)
}
console.log('global', a)
fn()
</code></pre>
<p>作用域链</p>
<pre><code class="language-javascript">var a = 100
function fn() {
  var b = 200

  // 当前作用域没有定义的变量，即“自由变量”
  console.log(a)
  console.log(b)
}
fn()
</code></pre>
<pre><code class="language-javascript">var a = 100
function F1() {
  var b = 200
  function F2() {
    var c = 300
    console.log(a) // a是自由变量
    console.log(b) // b是自由变量
    console.log(c)
  }
  F2()
}
F1()
</code></pre>
<h2 id="闭包的使用场景">闭包的使用场景</h2>
<ul>
<li>函数作为返回值</li>
<li>函数作为参数传递</li>
</ul>
<pre><code class="language-javascript">function F1() {
  var a = 100
  // 返回一个函数(函数作为返回值)
  return function() {
    console.log(a) // 自由变量，父级作用域寻找
  }
}
// f1 得到一个函数
var f1 = F1()
var a = 200
f1()

// 1.函数作为返回值 ↑
// 2.函数作为参数来传递 ↓
function F1() {
  var a = 100
  return function() {
    console.log(a)
  }
}
var f1 = F1()
function F2(fn) {
  var a = 200
  fn()
}
F2(f1)
</code></pre>
<h3 id="创建-10-个a标签点击的时候弹出对应的序号">创建 10 个<a>标签，点击的时候弹出对应的序号</h3>
<pre><code class="language-javascript">var i
for (i = 0; i &lt; 10; i++) {
  ;(function(i) {
    var a = document.createElement('a')
    a.innerHTML = i + '&lt;br&gt;'
    a.addEventListener('click', function(e) {
      e.preventDefault()
      alert(i)
    })
    document.body.appendChild(a)
  })(i)
}
</code></pre>
<h3 id="闭包的应用">闭包的应用</h3>
<pre><code class="language-javascript">// 闭包实际开发中主要用于封装变量，收敛权限
function isFirstLoad() {
  var _list = []
  return function(id) {
    if (_list.indexOf(id) &gt;= 0) {
      return false
    } else {
      _list.push(id)
      return true
    }
  }
}
// 使用  判断是否第一次
var firstLoad = isFirstLoad()
firstLoad(10) // true
firstLoad(10) // false
firstLoad(20) // true
</code></pre>
<h1 id="异步和单线程">异步和单线程</h1>
<h2 id="同步和异步的区别是什么">同步和异步的区别是什么</h2>
<p>同步会阻塞代码执行，而异步不会</p>
<p>alert 是同步，setTimeout 是异步</p>
<h2 id="前端使用异步的场景有哪些">前端使用异步的场景有哪些</h2>
<p>定时任务：setTimeout、setInterval</p>
<p>网络请求：ajax 请求，动态<img>加载</p>
<p>事件绑定</p>
<h1 id="日期">日期</h1>
<pre><code class="language-javascript">Date.now() // 获取当前时间毫秒数
var dt = new Date()
dt.getTime() // 获取毫秒数
dt.getFullYear() // 年
dt.getMonth() // 月(0-11)
dt.getDate() // 日(1-31)
dt.getHours() // 小时(0-23)
dt.getMinutes() // 分钟(0-59)
dt.getSeconds() // 秒(0-59)
</code></pre>
<h1 id="数组-api">数组 API</h1>
<h2 id="foreach">forEach</h2>
<pre><code class="language-javascript">var arr = [1, 2, 3]
arr.forEach(function(item, index) {
  //  遍历数组的所有元素
  console.log(index, item)
})
</code></pre>
<h2 id="every">every</h2>
<pre><code class="language-javascript">var arr = [1, 2, 3]
var result = arr.every(function(item, index) {
  // 用来判断所有的数组元素，都满足一个条件
  if (item &lt; 4) {
    return true
  }
})
console.log(result)
</code></pre>
<h2 id="some">some</h2>
<pre><code class="language-javascript">var arr = [1, 2, 3]
var result = arr.some(function(item, index) {
  // 用来判断只要有一个数组元素满足条件
  if (item &lt; 1) {
    return true
  }
})
console.log(result)
</code></pre>
<h2 id="sort">sort</h2>
<pre><code class="language-javascript">var arr = [1, 3, 2, 3, 5]
var arr2 = arr.sort(function(a, b) {
  // 从小到大排序
  return a - b
  // 从大到小排序
  // return b - a
})
console.log(arr)
console.log(arr2)
</code></pre>
<h2 id="map">map</h2>
<pre><code class="language-javascript">var arr = [1, 2, 3, 4]
var arr2 = arr.map(function(item, index) {
  // 将元素重新组装，并返回
  return '&lt;b&gt;' + item + '&lt;/b&gt;'
})
console.log(arr2)
</code></pre>
<h2 id="filter">filter</h2>
<pre><code class="language-javascript">var arr = [1, 2, 3]
var arr2 = arr.filter(function(item, index) {
  // 通过某一个条件过滤数组
  if (item &gt;= 2) {
    return true
  }
})
console.log(arr2)
</code></pre>
<h1 id="对象-api">对象 API</h1>
<pre><code class="language-javascript">var obj = {
  x: 100,
  y: 200,
  z: 300
}
var key
for (key in obj) {
  if (obj.hasOwnProperty(key)) {
    console.log(key, obj[key])
  }
}
</code></pre>
<p><strong>获取随机数，要求是长度一致的字符串格式</strong></p>
<pre><code class="language-javascript">var random = Math.random()
var random = random + '0000000000' // 后面加上10个零
var random = random.slice(0, 10)
console.log(random)
</code></pre>
<p><strong>一个能遍历对象和数组的 forEach 函数</strong></p>
<pre><code class="language-javascript">// 自定义forEach
function forEach(obj, fn) {
  var key
  if (obj instanceof Array) {
    obj.forEach(function(item, index) {
      fn(index, item)
    })
  } else {
    for (key in obj) {
      if (obj.hasOwnProperty(key)) {
        fn(key, obj[key])
      }
    }
  }
}
// 使用forEach
// 遍历数组
var arr = [1, 2, 3]
// 注意,这里参数的位置顺序换了，为了和对象遍历格式一致
forEach(arr, function(index, item) {
  console.log(index, item)
})
// 遍历对象
var obj = { x: 100, y: 200 }
forEach(obj, function(key, value) {
  console.log(key, value)
})
</code></pre>
<h1 id="dom">DOM</h1>
<h2 id="获取-dom-节点">获取 DOM 节点</h2>
<pre><code class="language-javascript">var div1 = document.getElementById('div1') //元素
var divList = document.getElementsByTagName('div') // 集合

var containerList = document.getElementByClassName('.container') // 集合
var pList = document.querySelectorAll('p') // 集合
</code></pre>
<h2 id="property">property</h2>
<pre><code class="language-javascript">var obj = { x: 100, y: 200 }
console.log(obj.x) // 100

var p = document.getElementsByTagName('p')[0]
console.log(p.nodeName) // P
</code></pre>
<h2 id="attribute">Attribute</h2>
<pre><code class="language-javascript">var pList = document.querySelectorAll('p')
var p = pList[0]
p.getAttribute('data-name')
p.setAttribute('data-name', 'imooc')
p.getAttribute('style')
p.setAttribute('style', 'font-size:30px')
</code></pre>
<p>property 只是一个 js 对象的属性的修改</p>
<p>Attribute 是对 HTML 标签属性的修改</p>
<h2 id="新增节点">新增节点</h2>
<pre><code class="language-javascript">var div1 = document.getElementById('div1')
// 添加新节点
var p1 = document.createElement('p')
p1.innerHTML = 'this is p1'
div1.appendChild(p1) // 添加新创建的元素
// 移动已有节点
var p2 = document.getElementById('p2')
div1.appendChild(p2)
</code></pre>
<h2 id="获取父元素和子元素">获取父元素和子元素</h2>
<pre><code class="language-javascript">var div1 = document.getElementById('div1')
var parent = div1.parentElement

var child = div1.childNodes
</code></pre>
<h2 id="删除节点">删除节点</h2>
<pre><code class="language-javascript">var div1 = document.getElementById('div1')
var child = div1.childNodes
div1.removeChild(child[0])
</code></pre>
<h1 id="bom">BOM</h1>
<h2 id="navigator-screen">navigator &amp; screen</h2>
<pre><code class="language-javascript">// navigator
var ua = navigator.userAgent
var isChrome = ua.indexOf('Chrome')
console.log(isChrome)

// screen
console.log(screen.width)
console.log(screen.height)
</code></pre>
<h2 id="location-history">location &amp; history</h2>
<pre><code class="language-javascript">// location
console.log(location.href)
console.log(location.protocol) // 'http:' 'https:'
console.log(location.host) //  域名
console.log(location.pathname) // '/learn/199'
console.log(location.search) // '?a=xxx'
console.log(location.hash) // '#...'

// history
history.back()
history.forward()
</code></pre>
<h1 id="事件">事件</h1>
<h2 id="通用事件绑定">通用事件绑定</h2>
<pre><code class="language-javascript">var btn = document.getElementById('btn1')
btn.addEventListener('click', function(event) {
  console.log('clicked')
})

function bindEvent(elem, type, fn) {
  elem.addEventListener(type, fn)
}
var a = document.getElementById('link1')
bindEvent(a, 'click', function(e) {
  e.preventDefault() //阻止默认行为
  alert('clicked')
})
</code></pre>
<p>关于 IE 低版本的兼容性</p>
<p>IE 低版本使用 attachEvent 绑定事件，和 W3C 标准不一样</p>
<p>IE 低版本使用量已非常少，很多网站都早已不支持</p>
<h2 id="代理">代理</h2>
<pre><code class="language-html">&lt;div id=&quot;div1&quot;&gt;
  &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt;
  &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt;
  &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt;
  &lt;!-- 会随时新增更多a标签 --&gt;
&lt;/div&gt;

&lt;script&gt;
  var div1 = document.getElementById('div1')
  div1.addEventListener('click', function(e) {
    var target = e.target
    if (target.nodeName === 'A') {
      alert(target.innerHTML)
    }
  })
&lt;/script&gt;
</code></pre>
<h2 id="完善通用绑定事件的函数">完善通用绑定事件的函数</h2>
<pre><code class="language-javascript">function bindEvent(elem, type, selector, fn) {
  if (fn == null) {
    fn = selector
    selector = null
  }
  elem.addEventListener(type, function(e) {
    var target
    // 代理
    if (selector) {
      target = e.target
      if (target.matches(selector)) {
        fn.call(target, e)
      }
    } else {
      // 不是代理
      fn(e)
    }
  })
}

// 使用代理
var div1 = document.getElementById('div1')
bindEvent(div1, 'click', 'a', function(e) {
  console.log(this.innerHTML)
})

// 不使用代理
var a = document.getElementById('a1')
bindEvent(div1, 'click', function(e) {
  console.log(a.innerHTML)
})
</code></pre>
<h1 id="ajax">Ajax</h1>
<h2 id="xmlhttprequest">XMLHttpRequest</h2>
<pre><code class="language-javascript">var xhr = new XMLHttpRequest()
Xhr.open('GET', '/api', false) // false指异步
Xhr.onreadystatechange = function() {
  // 这里的函数异步执行
  if (xhr.readyState == 4) {
    if (xhr.status == 200) {
      console.log(xhr.responseText)
    }
  }
}
xhr.send(null)
</code></pre>
<p>IE 低版本使用 ActiveXObject</p>
<h2 id="readystate">readyState</h2>
<p>0 - (未初始化) 还没用调用 send()方法</p>
<p>1 - (载入) 已调用 send()方法，正在发送请求</p>
<p>2 - (载入完成) send()方法执行完成，已经接收到全部响应内容</p>
<p>3 - (交互) 正在解析响应内容</p>
<p>4 - (完成) 响应内容解析完成，可以在客户端调用了</p>
<h2 id="status">status</h2>
<p>2xx - 表示成功处理请求。 如 200</p>
<p>3xx - 需要重定向，浏览器直接跳转</p>
<p>4xx - 客户端请求错误，如 404</p>
<p>5xx - 服务端错误</p>
<h1 id="跨域">跨域</h1>
<p>浏览器有同源策略，不允许 ajax 访问其他域接口</p>
<p>跨域条件：协议、域名、端口，有一个不同就算跨域</p>
<h2 id="允许跨域的三个标签">允许跨域的三个标签</h2>
<p>img</p>
<p>link</p>
<p>script</p>
<p><img> 用于打点统计，统计网站可能是其他域</p>
<link><script> 可以使用CDN,CDN的也是其他域
<script>可以用于JSONP



## 跨域注意事项

所有的跨域请求都必须经过信息提供方允许

如果未经允许即可获取，那是浏览器同源策略出现漏洞



## JSONP实现原理

加载http://coding.m.imooc.com/classindex.html

不一定服务器端存在一个classindex.html文件

服务器跨域根据请求，动态生成一个文件，返回

同理于 <script src="http://coding.m.imooc.com/api.js">



例如你的网站要跨域访问慕课网的一个接口

慕课给你一个地址http://coding.m.imooc.com/api.js

返回内容格式如 callback({x:100,y:200}) (可动态生成)

```javascript
window.callback = function(data) {
    // 这是我们跨域得到的信息
  	console.log(data)
}
<script src="http://coding.m.imooc.com/api.js"></script>
<!-- 以上将返回 callback({x:100,y:200}) -->
<pre><code>


# 存储

描述一下cookie,sessionStorage和localStorage的区别

## cookie

本身用于客户端和服务器端通信

但是它有本地存储的功能，于是就被“借用”

使用document.cookie = … 获取和修改



**cookie用于存储的缺点**

存储量太小，只有4KB

所有http请求都带有，会影响获取资源的效率

API简单，需要封装才能用 document.cookie = ...



## sessionStorage和localStorage的

HTML5专门为存储而设计，最大容量5M

API简答易用

localStorage.setItem(key, value); localStorage.getItem(key)







# 页面加载

## 加载一个资源的过程

浏览器根据DNS服务器得到域名的IP地址

向这个IP的机器发送http(或https)请求

服务器收到、处理并返回http(或https)请求

浏览器得到返回内容

## 浏览器渲染页面的过程

根据HTML结果生成DOM Tree

根据CSS生成CSSOM

将DOM和CSSOM整合成RenderTree

根据RenderTree开始渲染和展示

遇到&lt;script&gt;时，会执行并阻塞渲染



## window.onload 和 DOMContentLoaded

```javascript
window.addEventListener('load',function () {
    // 页面的全部资源加载完才会执行，包括图片、视频等
})
document.addEventListener('DOMContentLoaded', function () {
    // DOM渲染完即可执行，此时图片、视频还可能没有加载完
})
</code></pre>
<h1 id="性能优化">性能优化</h1>
<p><strong>原则</strong></p>
<p>多使用内存、缓存或者其他方法</p>
<p>减少 CPU 计算、减少网络请求</p>
<p><strong>从哪里入手</strong></p>
<p>加载页面和静态资源</p>
<p>页面渲染</p>
<p><strong>加载资源优化</strong></p>
<p>静态资源的压缩合并</p>
<p>静态资源缓存</p>
<p>使用 CDN 让资源加载更快</p>
<p>使用 SSR 后端渲染，数据直接输出到 HTML 中</p>
<p><strong>渲染优化</strong></p>
<p>CSS 放前面、JS 放后面</p>
<p>懒加载(图片懒加载、下拉加载更多)</p>
<p>减少 DOM 查询，对 DOM 查询做缓存</p>
<p>减少 DOM 操作，多个操作尽量合并在一起执行</p>
<p>事件节流</p>
<p>尽早执行操作（如 DOMContentLoaded）</p>
<h2 id="缓存-dom-查询">缓存 DOM 查询</h2>
<pre><code class="language-javascript">// 未缓存DOM查询
var i
for (i = 0; i &lt; document.getElementByTagName('p').length; i++) {
  // todo
}

// 缓存了DOM查询
var pList = document.getElementByTagName('p')
var i
for (i = 0; i &lt; pList.length; i++) {
  //todo
}
</code></pre>
<h2 id="合并-dom-插入">合并 DOM 插入</h2>
<pre><code class="language-javascript">var listNode = document.getElementById('list')

// 要插入 10 个 li 标签
var frag = document.createDocumentFragment()
var x, li
for (x = 0; x &lt; 10; x++) {
  li = document.createElement('li')
  li.innerHTML = 'List item' + x
  frag.appendChild(li)
}
listNode.appendChild(frag)
</code></pre>
<h2 id="事件节流">事件节流</h2>
<pre><code class="language-javascript">var textarea = document.getElementById('text')
var timeoutId
textarea.addEventListener('keyup', function() {
  if (timeoutId) {
    clearTimeout(timeoutId)
  }
  timeoutId = setTimeout(function() {
    // 触发 change 事件
  }, 100)
})
</code></pre>
<h2 id="尽早操作">尽早操作</h2>
<pre><code class="language-javascript">window.addEventListener('load', function() {
  // 页面的全部资源加载完才会执行，包括图片、视频等
})
document.addEventListener('DOMContentLoaded', function() {
  // DOM渲染完即可执行，此时图片、视频还可能没有加载完
})
</code></pre>
<h1 id="安全性">安全性</h1>
<p>XSS 跨站请求攻击</p>
<p>XSRF 跨站请求伪造</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[interview]]></title>
        <id>https://chenggr.github.io/post/interview/</id>
        <link href="https://chenggr.github.io/post/interview/">
        </link>
        <updated>2019-05-22T00:38:57.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>imooc 面试笔记</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>imooc 面试笔记</p>
</blockquote>
<!--more-->
<h1 id="dom-事件">DOM 事件</h1>
<p>基本概念：DOM 事件级别</p>
<p>DOM 事件级别</p>
<p>DOM 事件流</p>
<p>描述 DOM 事件捕获的具体流程</p>
<p>Event 对象的常用应用</p>
<p>自定义事件</p>
<h2 id="dom-事件类-事件级别">DOM 事件类 事件级别</h2>
<p>DOM0 element.onclick=function(){}</p>
<p>DOM2 element.addEventListener('click',function(){},false)</p>
<p>DOM3 element.addEventListener('keyup',function(){},false)</p>
<h2 id="dom-事件模型">DOM 事件模型</h2>
<p>事件模型</p>
<p>​ 捕获 ↓ 冒泡 ↑</p>
<h2 id="dom-事件流">DOM 事件流</h2>
<p>三阶段</p>
<p>捕获-&gt;目标阶段-&gt;冒泡</p>
<h2 id="描述-dom-事件捕获的具体流程">描述 DOM 事件捕获的具体流程</h2>
<p>window-&gt;</p>
<p>​ document-&gt;</p>
<p>​ html-&gt;</p>
<p>​ body-&gt;</p>
<p>​ ….</p>
<p>​ 目标元素</p>
<pre><code class="language-javascript">var ev = document.getElementById('ev')

window.addEventListener(
  'click',
  function(e) {
    console.log('window captrue')
  },
  true
)

document.addEventListener(
  'click',
  function(e) {
    console.log('document captrue')
  },
  true
)

document.documentElement.addEventListener(
  'click',
  function(e) {
    console.log('html captrue')
  },
  true
)

document.body.addEventListener(
  'click',
  function(e) {
    console.log('body captrue')
  },
  true
)

ev.addEventListener(
  'click',
  function(e) {
    console.log('ev captrue')
  },
  true
)
</code></pre>
<h2 id="event-对象的常用应用">Event 对象的常用应用</h2>
<p>event.preventDefault() //阻止默认行为</p>
<p>Event.stopPropagation() //阻止冒泡行为</p>
<p>Event.stopImmediatePropagation()</p>
<p>​ //同一元素绑定两个点击事件 A 和 B 在事件 A 中使用该事件 Event.stopImmediatePropagation()可以阻止事件 B 的触发</p>
<p>Event.currentTarget //当前绑定的事件</p>
<p>Event.target //当前被点击的元素</p>
<h2 id="自定义事件">自定义事件</h2>
<pre><code class="language-Javascript">var eve = new Event('custome');
el.addEventListener('custome',function(){
  console.log('custome');
});
el.dispatchEvent(eve)
</code></pre>
<p>CustomEvent 可以添加参数</p>
<h1 id="http-协议类">HTTP 协议类</h1>
<p>HTTP 协议的主要特点</p>
<p>HTTP 报文的组成部分</p>
<p>HTTP 方法</p>
<p>POST 和 GET 的区别</p>
<p>HTTP 状态码</p>
<p>什么是持久链接</p>
<p>什么是管线化</p>
<h2 id="http-协议的主要特点">HTTP 协议的主要特点</h2>
<h3 id="简单快速">简单快速</h3>
<p>​ 每个资源(URI)都是固定的</p>
<h3 id="灵活">灵活</h3>
<p>​ 通过头部分，一个 HTTP 协议可以完成不同数据类型的传输</p>
<h3 id="无连接">无连接</h3>
<p>​ 连接一次，它就会断掉，不会保持连接</p>
<h3 id="无状态">无状态</h3>
<p>​ 单从 HTTP 协议上，是不能区分两次连接者的身份的</p>
<h2 id="http-报文的组成部分">HTTP 报文的组成部分</h2>
<h3 id="请求报文">请求报文</h3>
<p>​ 请求行</p>
<p>​ http 方法、页面地址、http 协议、版本</p>
<p>​ 请求头</p>
<p>​ 空行</p>
<p>​ 请求体</p>
<h3 id="响应报文">响应报文</h3>
<p>​ 状态行</p>
<p>​ 响应头</p>
<p>​ 空行</p>
<p>​ 响应体</p>
<h2 id="http-协议类-2">HTTP 协议类</h2>
<h3 id="http-方法">HTTP 方法</h3>
<p>​ GET 获取资源</p>
<p>​ POST 传输资源</p>
<p>​ PUT 更新资源</p>
<p>​ DELETE 删除资源</p>
<p>​ HEAD 获得报文首部</p>
<h2 id="post-和-get-的区别">POST 和 GET 的区别</h2>
<ul>
<li>
<p>GET 在浏览器回退时是无害的，而 POST 会再次提交请求</p>
</li>
<li>
<p>GET 产生的 URL 地址可以被收藏，而 POST 不可以</p>
</li>
<li>
<p>GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置</p>
</li>
<li>
<p>GET 请求只能进行 url 编码，而 POST 支持多种编码方式</p>
</li>
<li>
<p>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留</p>
</li>
<li>
<p>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有限制</p>
</li>
<li>
<p>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制</p>
</li>
<li>
<p>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息</p>
</li>
<li>
<p>GET 参数通过 URL 传递，POST 放在 Request body 中</p>
</li>
</ul>
<h2 id="http-状态码">HTTP 状态码</h2>
<p>1xx: 指示信息-表示请求已接受，继续处理</p>
<p>2xx: 成功-表示请求已被成功接受</p>
<p>3xx: 重定向-要完成请求必须进行更进一步的操作</p>
<p>4xx: 客户端错误-请求语法错误或请求无法实现</p>
<p>5xx: 服务器错误-服务器未能实现合法的请求</p>
<p>200 OK : 客户端请求成功</p>
<p>206 Partial Content: 客户发送了一个带有 Range 头的 GET 请求，服务器完成了它</p>
<p>301 Moved Permanently: 所请求的页面已经转移至新的 url</p>
<p>302 Found: 所请求的页面已经临时转移至新的 url</p>
<p>304 Not Modified: 客户端有缓存的文档并发出了一个条件性的请求，服务器告诉客户，原来缓存的文档还可以继续使用</p>
<p>400 Bad Request: 客户端请求有语法错误，不能被服务器所理解</p>
<p>401 Unauthorized: 请求未经许可，这个状态码必须和 WWW-Authenticate 报头域一起使用</p>
<p>403 Forbidden: 对被请求页面的访问被禁止</p>
<p>404 Not Found: 请求资源不存在</p>
<p>500 Internal Server Error: 服务器发生不可预测的错误原来缓存的文档还可以继续使用</p>
<p>503 Server Unavailable: 请求未完成，服务器临时过载或当机，一段时间后可能恢复正常</p>
<h2 id="持久链接">持久链接</h2>
<p>HTTP 协议采用“请求-应答”模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建立一个连接，完成之后立即断开连接（HTTP 协议为无连接的协议）</p>
<p>当使用 Keep-Alive 模式(又称持久连接、连接重用)时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或重新建立连接</p>
<p>1.1 才支持持久连接</p>
<h2 id="管线化">管线化</h2>
<p><strong>在使用持久连接的情况下</strong>，某个连接上消息的传递类似于</p>
<p>请求 1-&gt;响应 1-&gt;请求 2-&gt;响应 2-&gt;请求 3-&gt;响应 3</p>
<p>某个连接上的消息变成了类似这样</p>
<p>请求 1-&gt;请求 2-&gt;请求 3-&gt;响应 1-&gt;响应 2-&gt;响应 3</p>
<ul>
<li>管线化机制通过持久连接完成，仅 HTTP/1.1 支持此技术</li>
<li>只有 GET 和 HEAD 请求可以进行管线化，而 POST 则有所限制</li>
<li>初次创建连接时不应启动管线机制，因为对方(服务器)不一定支持 HTTP/1.1 版本的协议</li>
<li>管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变</li>
<li>HTTP/1.1 要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可</li>
<li>由于上面提到的服务器端的问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理 程序对管线化的支持并不好，因此现代浏览器如 Chrome 和 Firefox 默认并未开启管线化支持</li>
</ul>
<h1 id="原型链类">原型链类</h1>
<p>创建对象有几种方法</p>
<p>原型、构造函数、实例、原型链</p>
<p>instanceof 的原理</p>
<p>new 运算符</p>
<h2 id="创建对象的几种方法">创建对象的几种方法</h2>
<p>// 字面量创建对象</p>
<p>var o1 = {name:'o1'}</p>
<p>var o11 = new Object({name:'o11'})</p>
<p>// 显示构造函数创建对象</p>
<p>var M = function(){this.name = 'o2'}</p>
<p>var o2 = new M();</p>
<p>// 通过 Object.create</p>
<p>var P = {name: 'o3'}</p>
<p>var o3 = Object.create(P)</p>
<h2 id="new-运算符">new 运算符</h2>
<p>一个新对象被创建。它继承自 foo.prototype</p>
<p>​ ↓</p>
<p>构造函数 foo 被执行。执行的时候，相应的传参会被传入，同时上下文（this）会被指定为这个新实例。new foo 等同于 new foo(),只能用在不传递任何参数的情况</p>
<p>​ ↓</p>
<p>如果构造函数返回一个“对象”，那么这个对象会取代整个 new 处理的结果。如果构造函数没有返回对象，那么 new 出来的结果为步骤 1 创建的对象。</p>
<pre><code class="language-javascript">var new2 = function(func) {
  var o = Object.create(func.prototype) //传入一个构造函数的原型对象来创建对象
  var k = func.call(o) //上下文（this）会指定为这个新实例
  if (typeof k === 'object') {
    return k
  } else {
    return o
  }
}
</code></pre>
<h1 id="通信类">通信类</h1>
<p>什么是同源策略及限制</p>
<p>前后端如何通信</p>
<p>如何创建 Ajax</p>
<p>跨域通信的几种方式</p>
<h2 id="什么是同源策略及限制">什么是同源策略及限制</h2>
<p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。</p>
<p>这是一个用于隔离潜在恶意文件的关键的安全机制。</p>
<ul>
<li>
<p>Cookie、LocalStorage 和 IndexDB 无法读取</p>
</li>
<li>
<p>DOM 无法获得</p>
</li>
<li>
<p>AJAX 请求不能发送</p>
<p>​</p>
</li>
</ul>
<h2 id="前后端如何通信">前后端如何通信</h2>
<p>Ajax</p>
<p>WebSocket</p>
<p>CORS</p>
<h2 id="如何创建-ajax">如何创建 Ajax</h2>
<p>XMLHttpRequest 对象的工作流程</p>
<p>兼容性处理</p>
<p>事件的触发条件</p>
<p>事件的触发顺序</p>
<h2 id="跨域通信的几种方式">跨域通信的几种方式</h2>
<p>JSONP</p>
<p>Hash</p>
<p>postMessage</p>
<p>WebSocket</p>
<p>CORS</p>
<h1 id="安全类">安全类</h1>
<h2 id="csrf">CSRF</h2>
<p>CSRF,通常称为跨站请求伪造，英文名 Cross-site request forgery</p>
<h2 id="csrf-防御措施">CSRF 防御措施</h2>
<p>Token 验证</p>
<p>Referer 验证</p>
<p>隐藏令牌</p>
<h2 id="xss">XSS</h2>
<p>XSS（cross-site scripting）跨域脚本攻击</p>
<h1 id="算法类">算法类</h1>
<p>排序</p>
<p>堆栈、队列、链表</p>
<p>递归</p>
<p>波兰式和逆波兰式</p>
<h1 id="渲染机制">渲染机制</h1>
<h2 id="什么是-doctype-及作用">什么是 DOCTYPE 及作用</h2>
<p>DTD(doucument type definition,文档类型定义)是一系列的语法规则，用来定义 XML 或(x)HTML 的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器模式</p>
<p>DOCTYPE 是用来声明文档类型和 DTD 规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出一些差错</p>
<h2 id="浏览器渲染过程">浏览器渲染过程</h2>
<h2 id="重排-reflow">重排 Reflow</h2>
<p><strong>定义</strong></p>
<p>DOM 结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为 reflow</p>
<p><strong>触发 Reflow</strong></p>
<p>当你增加、删除、修改 DOM 节点时，会导致 Reflow 或 Repaint</p>
<p>当你移动 DOM 的位置，或是搞个动画的时候</p>
<p>当你修改 CSS 样式的时候</p>
<p>当你 Resize 窗口的时候（移动端没有这个问题），或是滚动的时候</p>
<p>当你修改网页的默认字体时</p>
<h2 id="重绘-repaint">重绘 Repaint</h2>
<p><strong>定义</strong></p>
<p>当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等确定下来后，浏览器于是便把这些元素都按照各自的特性绘制一遍，于是页面的内容出现了，这个过程称之为 repaint</p>
<p><strong>触发 Repaint</strong></p>
<p>DOM 改动</p>
<p>CSS 改动</p>
<h2 id="布局-layout">布局 Layout</h2>
<h1 id="js-运行机制">JS 运行机制</h1>
<p>异步任务</p>
<p>setTimeout 和 setInterval</p>
<p>DOM 事件</p>
<p>ES6 中的 Promise</p>
<h1 id="页面性能">页面性能</h1>
<p>提升页面性能的方法有哪些？</p>
<p>1、资源压缩合并，减少 HTTP 请求</p>
<p>2、非核心代码异步加载-&gt;异步加载的方式-&gt;异步加载的区别</p>
<p>3、利用浏览器缓存-&gt;缓存的分类-&gt;缓存的原理</p>
<p>4、使用 CDN</p>
<p>5、预解析 DNS</p>
<p>​ <meta http-equiv="x-dns-prefetch-control" content="on"> // https 中 a 链接打开 DNS 预解析</p>
<p>​ <link rel="dns-prefetch" href="//host_name_to_prefetch.com"></p>
<p><strong>异步加载</strong></p>
<p>1、异步加载的方式</p>
<p>​ 1）动态脚本加载 2）defer 3）async</p>
<p>2、异步加载的区别</p>
<p>​ 1）defer 是在 HTML 解析完之后才会执行，如果是多个，按照加载的顺序依次执行</p>
<p>​ 2）async 是在加载之后立即执行，如果是多个，执行顺序和加载顺序无关</p>
<p><strong>浏览器缓存</strong></p>
<p>1、缓存的分类</p>
<p>​ 1）强缓存</p>
<p>​ Expires Expires:Thu,21 Jan 2017 23:39:02 GMT</p>
<p>​ Cache-Control Cache-Control:max-age=3600</p>
<p>​ 2）协商缓存</p>
<p>​ Last-Modified If-Modified-Since Last-Modified:Wed,26 Jan 2017 00:35:11 GMT</p>
<p>​ Etag If-None-Match</p>
<h1 id="错误监控">错误监控</h1>
<p>前端错误的分类</p>
<p>错误的捕获方式</p>
<p>上报错误的基本原理</p>
<p><strong>即时运行错误的捕获方式</strong></p>
<p>1）try…catch 2）window.onerror</p>
<p><strong>资源加载错误</strong></p>
<p>1）object.onerror 2）performance.getEntries() 3）Error 事件捕获</p>
<p><strong>延伸：跨域的 js 运行错误跨域捕获吗，错误提示什么，应该怎么处理？</strong></p>
<p>1、在 script 标签增加 crossorigin 属性</p>
<p>2、设置 js 资源响应头 Access-Control-Allow-Origin:*</p>
<p><strong>上报错误的基本原理</strong></p>
<p>1、采用 Ajax 通信的方式上报</p>
<p>2、利用 Image 对象上报</p>
<h1 id="业务能力">业务能力</h1>
<p>我做过什么业务？</p>
<p>负责的业务有什么业绩？</p>
<p>使用了什么技术方案？</p>
<p>突破了什么技术难点？</p>
<p>遇到了什么问题？</p>
<p>最大的收获是什么？</p>
<h1 id="事物推动能力">事物推动能力</h1>
<p>主动描述</p>
<h1 id="终面">终面</h1>
<p>1、职业竞争力</p>
<p>2、职业规划</p>
<h2 id="职业竞争力">职业竞争力</h2>
<p>1、业务能力</p>
<p>2、思考能力</p>
<p>3、学习能力</p>
<p>4、无上限的付出</p>
<h1 id="职业规划">职业规划</h1>
<p>1、目标是什么</p>
<p>​ 在业务上成为专家，在技术上成为行业大牛</p>
<p>2、近阶段的目标</p>
<p>​ 不断的学习积累各方面的经验，以学习为主</p>
<p>3、长期目标</p>
<p>​ 做几件很有价值的事情，如开源作品、技术框架等</p>
<p>4、方式方法</p>
<p>​ 先完成业务上的主要问题，做到极致、然后逐步向目标靠拢</p>
<h1 id="面试技巧">面试技巧</h1>
<p>1、乐观积极</p>
<p>2、主动沟通</p>
<p>3、逻辑顺畅</p>
<p>4、上进有责任心</p>
<p>5、有主张、做事果断</p>
]]></content>
    </entry>
</feed>