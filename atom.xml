<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chenggr.github.io</id>
    <title>chenggr&apos;s blog</title>
    <updated>2022-03-10T08:15:49.013Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chenggr.github.io"/>
    <link rel="self" href="https://chenggr.github.io/atom.xml"/>
    <subtitle>一个记录与分享的地方~</subtitle>
    <logo>https://chenggr.github.io/images/avatar.png</logo>
    <icon>https://chenggr.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, chenggr&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[interview questions]]></title>
        <id>https://chenggr.github.io/post/interview-questions/</id>
        <link href="https://chenggr.github.io/post/interview-questions/">
        </link>
        <updated>2022-03-10T02:57:41.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>Summary of interview questions for Han Qi</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>Summary of interview questions for Han Qi</p>
</blockquote>
<!--more-->
<h1 id="vue">VUE</h1>
<h4 id="vue的生命周期是什么"><strong>vue的生命周期是什么</strong></h4>
<pre><code>vue每个组件都是独立的，每个组件都有一个属于它的生命周期，从一个组件创建、数据初始化、挂载、更新、销毁，这就是一个组件所谓的生命周期。
beforeCreate() 在实例创建之间执行，数据未加载状态
created() 在实例创建、数据加载后，能初始化数据，dom渲染之前执行
beforeMount() 虚拟dom已创建完成，在数据渲染前最后一次更改数据
mounted() 页面、数据渲染完成，真实dom挂载完成
beforeUpadate() 重新渲染之前触发
updated() 数据已经更改完成，dom 也重新 render 完成,更改数据会陷入死循环
beforeDestory() 和 destoryed() 前者是销毁前执行（实例仍然完全可用），后者则是销毁后执行
</code></pre>
<h4 id="为什么要有生命周期">为什么要有生命周期</h4>
<pre><code>因为：VUE中MVVM思想、虚拟DOM等机制
所以：需要钩子函数/生命周期，从而方便开发、提升性能等
</code></pre>
<h4 id="你说下vue路由模式有几种">你说下vue路由模式有几种？</h4>
<pre><code>常用路由模式有2个，分别为hash和history  直接修改路由构造函数加个mode键即可
准备说有3个，hash/history用于客户端，abstract用户服务端
</code></pre>
<h4 id="你说下vue路由原理">你说下vue路由原理？</h4>
<pre><code>vue路由是基于SPA单页面应用思想去开发的
利用BOM API 来使用
hash模式    通过 BOM  location对象的hash属性来改变路由
history模式   通过BOM history对象的pushState属性来改变路由
</code></pre>
<h4 id="那你说下什么是单页面应用spa优缺点如何选择">那你说下什么是单页面应用SPA优缺点，如何选择</h4>
<pre><code>SPA优点：1.切换速度快、减少HTTP请求、便于加特效
2.前后端分离便于后期扩展
3.转场动画，也就是一个页面切换另一个页面  transition
缺点：1. 不利于seo优化
	2. 初次加载耗时（注：这时候可能问vue首屏加载慢如何解决 见优化部分答案）SPA缺点：不利于SEO优化（就是百度可以搜到你）
MPA多页面的好处
概念：有多个页面，跳转方式是页面之间的跳转
优点：首屏加载快；seo优化好
缺点：跳转较慢；相对复杂，没有实现前后端分离
如何选择
根据项目需求，老板没有明确说直接用vue脚手架创建框架就行，
但是老板说需要seo优化则通过：Vue.js 服务器端渲染（nuxt.js）
</code></pre>
<h4 id="声明式导航和">声明式导航和</h4>
<pre><code>写法不一样,声明式导航是写在组件的template中,通过router-link来触发,
编程式导航写在js函数中,通过this.$router.push(xxx)来触发路径
</code></pre>
<h4 id="vuex是什么怎么使用哪种功能场景使用它">vuex是什么？怎么使用？哪种功能场景使用它？</h4>
<pre><code>就是用来存放所有组件数据的仓库,也就是组件状态管理工具
state:存储数据；
mutations:更新数据的方法；
actions:调用mutations方法，更新state数据；
getters:对state中的数据进行预处理；
vuex 的作用
￼
实现所有组件相互通信，数据共享
组件之间需要相互通信时，例如购物车购买数量、登录信息等
什么是计算属性和侦听器
￼
计算属性：普通方法的升级版，有缓存
怎么用：在data同级定义computed对象来声明计算属性、调用不加小括号
侦听器：用来监控模型数据变化
 怎么用：在data同级定义watch对象声明侦听器、方法名就是data中的键、不能调用
 如何选：
  1 事件 和 封装减少视图代码冗余便于后期维护 先用普通方法
  2 上述多次执行耗时 计算属性优化
3 当需要监控模型数据改变 使用侦听器。例如：搜索、全选全不选等等
什么是混入
￼
是什么：vue中提供的解决组件代码冗余的技术，可以提起相同的普通方法、模型数据等
怎么用：Vue.mixin 或 mixins键来定义
实战用：后期项目的跳转、返回上一页、提示信息等等
什么是vue组件
￼
是什么：用来代替传统HTML的一种解决方案、里面还是HTML、JS、CSS
好处：倡导模块化、便于后期相互调用、从而减少代码冗余、方便维护
怎么用： Vue.component(组件名，{template, methods, data, ....})
组件通信工作流
￼
父传子： 子组件通过 props 属性，绑定父组件数据，实现双方通信
子传父：    将父组件的事件在子组件中通过 $emit 触发
兄弟  ：1 创建bus总线 全局仓库 
        2 传递数据 bus.$emit
         3 接受数据 bus.$on
vue中的事件修饰符
￼
事件修饰符：.stop、.prevent、.once等
键盘修饰符：.enter、.ctrl .enter等
什么是路由懒加载
￼
路由懒加载是通过异步的方式来加载对应的路由组件，提高页面相应速度
vue的路由使用步骤？
￼
1.下载vue-router路由模块；
2.创建路由对象；
3.配置路由规则；
4.将路由对象注册为vue实例对象的成员属性；
http协议状态码301和302的区别
￼
301 redirect: 301 代表永久性转移(Permanently Moved)
302 redirect: 302 代表暂时性转移(Temporarily Moved )
302重定向只是暂时的重定向，浏览器会抓取新的内容而保留旧的地址，因为服务器返回302，所以，搜索浏览器认为新的网址是暂时的。
301重定向是永久的重定向，浏览器在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址
谈谈你对虚拟DOM的理解？
￼
就是用JS 的Object对象模拟DOM中的节点，然后再通过特定的render方法将其渲染成真实的DOM节点，因为浏览器工作机制，通过虚拟DOM提升性能。
回流重绘
￼
回流：重新布局
重绘：改变元素属性样式
谈谈你对diff算法的理解？
￼
diff算法是虚拟DOM技术的产物，核心思想是通过新旧虚拟DOM做对比，（即diff），将变化的地方更新在真实的DOM上，也需要diff高效执行对比的过程，从而降低时间复杂度为O(n).
步骤一：用JS对象模拟DOM树
步骤二：比较新旧虚拟DOM树的差异
步骤三：把差异应用到真正的DOM树上
v-for中有key值和没有key值的区别
￼
它们区别主要在于虚拟DOM的复用，绑定key可以更好的复用，避免重复渲染
fetch、axios区别
￼
相同点：都是基于promise封装的HTTP库
不同点:1 fetch官方 axios第三方
    2 axios更强例如拦截器、而fetch需要自己封装等
请谈谈对http的理解	
￼
HTTP：超文本传输协议，主要由request请求 和response响应 组成，规定了计算机之间如何相互通信
项目开发中常遇到的
请求方式常用的有get、post、put、delete
HTTP状态码：...
请求头：expire、gzip、content-type等
HTTP状态码
￼
100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
200 OK 请求成功
201 Created 请求成功并且服务器创建了新的资源
202 Accepted 服务器已接受请求，但尚未处理
301 Moved Permanently 永久性重定向。
302 Found 临时性重定向。
303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
304 Not Modified 浏览器缓存
400 BadRequest 参数有误。
401 Unauthorized 密码错误。
403Forbidden 没有权限。
404 NotFound 文件不存在。
500 InternalServer Error 服务器错误。
503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
vue实现数据双向绑定的原理
￼
采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调
Created与Mounted的区别
￼
Created：在dom渲染之前调用，通常初始化某些属性值，然后再渲染成视图。
Mounted：在dom渲染之后调用，初始化页面完成后，再对dom节点进行一些需要的操作。
vue中mounted和updated这两个生命周期怎么运行的
￼
mounted 页面首次渲染完毕时触发
updated 模型数据更新时候触发
vue首屏加载过慢如何解决
￼
1、路由懒加载（也就是要的时候的时候进行加载。
2、UI组件按需加载
3、webpack启用gzip压缩
什么是JSX
￼
JSX即JavaScript XML，是JS的一种扩展语言。
解释单向数据流和双向数据绑定
￼
单向数据流： 顾名思义，数据流是单向的。数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷。缺点就是写起来不太方便。要使UI发生变更就必须创建各种 action 来维护对应的 state；
双向数据绑定：数据之间是相通的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的场景下，会简化大量与业务无关的代码。缺点就是无法追踪局部状态的变化，增加了出错时 debug 的难度。
Vue 如何去除url中的
￼
vue-router 默认使用 hash 模式，所以在路由加载的时候，项目中的 url 会自带 #。如果不想使用 #， 可以使用 vue-router 的另一种模式 history。
需要注意的是，当我们启用 history 模式的时候，由于我们的项目是一个单页面应用，所以在路由跳转的时候，就会出现访问不到静态资源而出现 404 的情况，这时候就需要服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面(重定向)。
和
router的区别
￼
$router 为 VueRouter 实例，想要导航到不同 URL，则使用 $router.push 方法$route 为当前 router 跳转对象里面可以获取 name 、 path 、 query 、 params 等
NextTick 是做什么的
￼
$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM
当你修改了data的值然后马上获取这个dom元素的值，是不能获取到更新后的值，
你需要使用$nextTick这个回调，让修改后的data值渲染更新到dom元素之后在获取，才能成功
Vue 组件 data 为什么必须是函数
￼
因为js本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了
计算属性computed 和事件 methods 有什么区别
￼
我们可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的
不同点：
computed: 计算属性是基于它们的依赖进行缓存的,只有在它的相关依赖发生改变时才会重新求值对于 method ，只要发生重新渲染，method 调用总会执行该函数
watch和computed区别
  computed结果会缓存,依赖于外界响应式依赖发生变化而变化
  watch是直接监听某个属性,只要这个属性发生了变化,就会触发相应的函数回调,并且能获取到变更值以及变更之前的值 

清除keep-alive缓存
￼
deactivated () { //清除keep-alive的缓存
    this.$destroy(true)
  }
对比 jQuery ，Vue 有什么不同
￼
jQuery 专注视图层，通过操作 DOM 去实现页面的一些逻辑渲染； Vue 专注于数据层，通过数据的双向绑定，最终表现在 DOM 层面，减少了 DOM 操作Vue 使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发
vue-router 路由实现
￼
路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能
Vue 组件 data 为什么必须是函数
￼
因为js本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了
Vue 中怎么自定义指令
￼
全局注册
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
局部注册
directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus()
    }
  }
}
Vue 中怎么自定义过滤器
￼
可以用全局方法 Vue.filter() 注册一个自定义过滤器，它接收两个参数：过滤器 ID 和过滤器函数。过滤器函数以值为参数，返回转换后的值
Vue.filter('reverse', function (value) {
  return value.split('').reverse().join('')
})
&lt;!-- 'abc' =&gt; 'cba' --&gt;
&lt;span v-text=&quot;message | reverse&quot;&gt;&lt;/span&gt;
过滤器也同样接受全局注册和局部注册
对 keep-alive 的了解
￼
keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染
&lt;keep-alive&gt;
  &lt;component&gt;
    &lt;!-- 该组件将被缓存！ --&gt;
  &lt;/component&gt;
&lt;/keep-alive&gt;
可以使用API提供的props，实现组件的动态缓存

钩子函数
	1.activated：页面第一次进入的时候，钩子触发的顺序是created-&gt;mounted-&gt;activated
	2.deactivated ：页面退出的时候会触发deactivated，当再次前进或者后退的时候只触发activated
属性:include包含的组件会被缓存，exclude排除的组件不会被缓存
Vue 的核心是什么
￼
数据驱动 组件系统
vue 等单页面应用的优缺点
￼
优点：1.良好的交互体验 2.良好的前后端工作分离模式 3.减轻服务器压力
缺点：1.SEO难度较高 2.前进、后退管理  3.初次加载耗时多
vue-router有哪几种导航守卫
￼
1&gt;全局守卫
a：router.beforeEach 全局前置守卫，进入路由之前
b：router.beforResolve 全局解析守卫，在beforeRouterEnter调用之后调用
c：router.afterEach 全局后置钩子，进入路由之后
2&gt;路由独享守卫
如果不想全局配置守卫的话，可以为某些路由单独配置守卫
3&gt;路由组件内的守卫
beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建beforeRouteUpdate (2.2)路由复用同一个组件时,在当前路由改变，但是该组件被复用时调用 可以访问组件实例this
beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this
vue-router 使用params与query传参有什么区别
￼
vue-router 可以通过 params 与 query 进行传参
// 传递
this.$router.push({path: './xxx', params: {xx:xxx}})
this.$router.push({path: './xxx', query: {xx:xxx}})
// 接收
this.$route.params
this.$route.query
params 是路由的一部分,必须要有。query 是拼接在 url 后面的参数，没有也没关系
params 不设置的时候，刷新页面或者返回参数会丢，query 则不会有这个问题
你在什么场景下使用了vuex？ 
￼
当应用遇到多个组件共享状态的时候，即：多个视图依赖于同一个状态，不同视图的行为需要变更同一个状态
如：
用户的个人信息管理模块
电商项目购物车模块
props和data的优先级，区别
￼
props&gt;data
props就相当于你的参数，data就相当于局部变量，组件其实就是一个函数
xxxxxxxxxx vuex是：就是用来存放所有组件数据的仓库,也就是组件状态管理工具state:存储数据；mutations:更新数据的方法；actions:调用mutations方法，更新state数据；getters:对state中的数据进行预处理；
</code></pre>
<h4 id="vuex-的作用">vuex 的作用</h4>
<pre><code>实现所有组件相互通信，数据共享
组件之间需要相互通信时，例如购物车购买数量、登录信息等
</code></pre>
<h4 id="什么是计算属性和侦听器">什么是计算属性和侦听器</h4>
<pre><code>计算属性：普通方法的升级版，有缓存
怎么用：在data同级定义computed对象来声明计算属性、调用不加小括号
侦听器：用来监控模型数据变化
 怎么用：在data同级定义watch对象声明侦听器、方法名就是data中的键、不能调用
 如何选：
  1 事件 和 封装减少视图代码冗余便于后期维护 先用普通方法
  2 上述多次执行耗时 计算属性优化
3 当需要监控模型数据改变 使用侦听器。例如：搜索、全选全不选等等
</code></pre>
<h4 id="什么是混入">什么是混入</h4>
<pre><code>是什么：vue中提供的解决组件代码冗余的技术，可以提起相同的普通方法、模型数据等
怎么用：Vue.mixin 或 mixins键来定义
实战用：后期项目的跳转、返回上一页、提示信息等等
</code></pre>
<h4 id="什么是vue组件">什么是vue组件</h4>
<pre><code>是什么：用来代替传统HTML的一种解决方案、里面还是HTML、JS、CSS
好处：倡导模块化、便于后期相互调用、从而减少代码冗余、方便维护
怎么用： Vue.component(组件名，{template, methods, data, ....})
</code></pre>
<h4 id="组件通信工作流">组件通信工作流</h4>
<pre><code>父传子： 子组件通过 props 属性，绑定父组件数据，实现双方通信
子传父：	将父组件的事件在子组件中通过 $emit 触发
兄弟	：1 创建bus总线 全局仓库	
     	2 传递数据 bus.$emit
         3 接受数据 bus.$on
</code></pre>
<h4 id="vue中的事件修饰符">vue中的事件修饰符</h4>
<pre><code>事件修饰符：.stop、.prevent、.once等
键盘修饰符：.enter、.ctrl .enter等
</code></pre>
<h4 id="什么是路由懒加载">什么是路由懒加载</h4>
<pre><code>路由懒加载是通过异步的方式来加载对应的路由组件，提高页面相应速度
</code></pre>
<h4 id="vue的路由使用步骤">vue的路由使用步骤？</h4>
<pre><code>1.下载vue-router路由模块；
2.创建路由对象；
3.配置路由规则；
4.将路由对象注册为vue实例对象的成员属性；
</code></pre>
<h4 id="http协议状态码301和302的区别">http协议状态码301和302的区别</h4>
<pre><code>301 redirect: 301 代表永久性转移(Permanently Moved)
302 redirect: 302 代表暂时性转移(Temporarily Moved )
302重定向只是暂时的重定向，浏览器会抓取新的内容而保留旧的地址，因为服务器返回302，所以，搜索浏览器认为新的网址是暂时的。
301重定向是永久的重定向，浏览器在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址
</code></pre>
<h4 id="谈谈你对虚拟dom的理解">谈谈你对虚拟DOM的理解？</h4>
<pre><code>就是用JS 的Object对象模拟DOM中的节点，然后再通过特定的render方法将其渲染成真实的DOM节点，因为浏览器工作机制，通过虚拟DOM提升性能。
</code></pre>
<h4 id="回流重绘">回流重绘</h4>
<pre><code>回流：重新布局
重绘：改变元素属性样式
</code></pre>
<h4 id="谈谈你对diff算法的理解">谈谈你对diff算法的理解？</h4>
<pre><code>diff算法是虚拟DOM技术的产物，核心思想是通过新旧虚拟DOM做对比，（即diff），将变化的地方更新在真实的DOM上，也需要diff高效执行对比的过程，从而降低时间复杂度为O(n).
步骤一：用JS对象模拟DOM树
步骤二：比较新旧虚拟DOM树的差异
步骤三：把差异应用到真正的DOM树上
</code></pre>
<h4 id="v-for中有key值和没有key值的区别">v-for中有key值和没有key值的区别</h4>
<pre><code>它们区别主要在于虚拟DOM的复用，绑定key可以更好的复用，避免重复渲染
</code></pre>
<h4 id="fetch-axios区别">fetch、axios区别</h4>
<pre><code>相同点：都是基于promise封装的HTTP库
不同点:1 fetch官方 axios第三方
	2 axios更强例如拦截器、而fetch需要自己封装等
</code></pre>
<h4 id="请谈谈对http的理解">请谈谈对http的理解</h4>
<pre><code>HTTP：超文本传输协议，主要由request请求 和response响应 组成，规定了计算机之间如何相互通信
项目开发中常遇到的
请求方式常用的有get、post、put、delete
HTTP状态码：...
请求头：expire、gzip、content-type等
</code></pre>
<h4 id="http状态码">HTTP状态码</h4>
<pre><code>100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
200 OK 请求成功
201 Created 请求成功并且服务器创建了新的资源
202 Accepted 服务器已接受请求，但尚未处理
301 Moved Permanently 永久性重定向。
302 Found 临时性重定向。
303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
304 Not Modified 浏览器缓存
400 BadRequest 参数有误。
401 Unauthorized 密码错误。
403Forbidden 没有权限。
404 NotFound 文件不存在。
500 InternalServer Error 服务器错误。
503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
</code></pre>
<h4 id="vue实现数据双向绑定的原理">vue实现数据双向绑定的原理</h4>
<pre><code>采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调
</code></pre>
<h4 id="created与mounted的区别">Created与Mounted的区别</h4>
<pre><code>Created：在dom渲染之前调用，通常初始化某些属性值，然后再渲染成视图。
Mounted：在dom渲染之后调用，初始化页面完成后，再对dom节点进行一些需要的操作。
</code></pre>
<h4 id="vue中mounted和updated这两个生命周期怎么运行的">vue中mounted和updated这两个生命周期怎么运行的</h4>
<pre><code>mounted 页面首次渲染完毕时触发
updated 模型数据更新时候触发
</code></pre>
<h4 id="vue首屏加载过慢如何解决">vue首屏加载过慢如何解决</h4>
<pre><code>1、路由懒加载（也就是要的时候的时候进行加载。
2、UI组件按需加载
3、webpack启用gzip压缩
</code></pre>
<h4 id="什么是jsx">什么是JSX</h4>
<pre><code>JSX即JavaScript XML，是JS的一种扩展语言。
</code></pre>
<h4 id="解释单向数据流和双向数据绑定">解释单向数据流和双向数据绑定</h4>
<pre><code>单向数据流： 顾名思义，数据流是单向的。数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷。缺点就是写起来不太方便。要使UI发生变更就必须创建各种 action 来维护对应的 state；
双向数据绑定：数据之间是相通的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的场景下，会简化大量与业务无关的代码。缺点就是无法追踪局部状态的变化，增加了出错时 debug 的难度。
</code></pre>
<h4 id="vue-如何去除url中的">Vue 如何去除url中的</h4>
<pre><code>vue-router 默认使用 hash 模式，所以在路由加载的时候，项目中的 url 会自带 #。如果不想使用 #， 可以使用 vue-router 的另一种模式 history。
需要注意的是，当我们启用 history 模式的时候，由于我们的项目是一个单页面应用，所以在路由跳转的时候，就会出现访问不到静态资源而出现 404 的情况，这时候就需要服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面(重定向)。
</code></pre>
<h3 id="route和router的区别"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">和</mi></mrow><annotation encoding="application/x-tex">route和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">和</span></span></span></span>router的区别</h3>
<pre><code>$router 为 VueRouter 实例，想要导航到不同 URL，则使用 $router.push 方法$route 为当前 router 跳转对象里面可以获取 name 、 path 、 query 、 params 等
</code></pre>
<h4 id="nexttick-是做什么的">NextTick 是做什么的</h4>
<pre><code>$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM
当你修改了data的值然后马上获取这个dom元素的值，是不能获取到更新后的值，
你需要使用$nextTick这个回调，让修改后的data值渲染更新到dom元素之后在获取，才能成功
</code></pre>
<h3 id="vue-组件-data-为什么必须是函数">Vue 组件 data 为什么必须是函数</h3>
<pre><code>因为js本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了
</code></pre>
<h4 id="计算属性computed-和事件-methods-有什么区别">计算属性computed 和事件 methods 有什么区别</h4>
<pre><code>我们可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的
不同点：
computed: 计算属性是基于它们的依赖进行缓存的,只有在它的相关依赖发生改变时才会重新求值对于 method ，只要发生重新渲染，method 调用总会执行该函数
</code></pre>
<h1 id="watch和computed区别">watch和computed区别</h1>
<p>computed结果会缓存,依赖于外界响应式依赖发生变化而变化<br>
watch是直接监听某个属性,只要这个属性发生了变化,就会触发相应的函数回调,并且能获取到变更值以及变更之前的值</p>
<h1 id="清除keep-alive缓存">清除keep-alive缓存</h1>
<pre><code>deactivated () { //清除keep-alive的缓存
    this.$destroy(true)
  }
</code></pre>
<h4 id="对比-jquery-vue-有什么不同">对比 jQuery ，Vue 有什么不同</h4>
<pre><code>jQuery 专注视图层，通过操作 DOM 去实现页面的一些逻辑渲染； Vue 专注于数据层，通过数据的双向绑定，最终表现在 DOM 层面，减少了 DOM 操作Vue 使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发
</code></pre>
<h4 id="vue-router-路由实现">vue-router 路由实现</h4>
<pre><code>路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能
</code></pre>
<h4 id="vue-组件-data-为什么必须是函数-2">Vue 组件 data 为什么必须是函数</h4>
<pre><code>因为js本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了
</code></pre>
<h4 id="vue-中怎么自定义指令">Vue 中怎么自定义指令</h4>
<pre><code>全局注册
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
局部注册
directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus()
    }
  }
}
</code></pre>
<h4 id="vue-中怎么自定义过滤器">Vue 中怎么自定义过滤器</h4>
<pre><code>可以用全局方法 Vue.filter() 注册一个自定义过滤器，它接收两个参数：过滤器 ID 和过滤器函数。过滤器函数以值为参数，返回转换后的值
Vue.filter('reverse', function (value) {
  return value.split('').reverse().join('')
})
&lt;!-- 'abc' =&gt; 'cba' --&gt;
&lt;span v-text=&quot;message | reverse&quot;&gt;&lt;/span&gt;
过滤器也同样接受全局注册和局部注册
</code></pre>
<h4 id="对-keep-alive-的了解">对 keep-alive 的了解</h4>
<pre><code>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染
&lt;keep-alive&gt;
  &lt;component&gt;
    &lt;!-- 该组件将被缓存！ --&gt;
  &lt;/component&gt;
&lt;/keep-alive&gt;
可以使用API提供的props，实现组件的动态缓存

钩子函数:activated deactivated
属性:include包含的组件会被缓存，exclude排除的组件不会被缓存
</code></pre>
<h4 id="vue-的核心是什么">Vue 的核心是什么</h4>
<pre><code>数据驱动 组件系统
</code></pre>
<h4 id="vue-等单页面应用的优缺点">vue 等单页面应用的优缺点</h4>
<pre><code>优点：1.良好的交互体验 2.良好的前后端工作分离模式 3.减轻服务器压力
缺点：1.SEO难度较高 2.前进、后退管理 	3.初次加载耗时多
</code></pre>
<h4 id="vue-router有哪几种导航守卫"><strong>vue-router有哪几种导航守卫</strong></h4>
<pre><code>1&gt;全局守卫
a：router.beforeEach 全局前置守卫，进入路由之前
b：router.beforResolve 全局解析守卫，在beforeRouterEnter调用之后调用
c：router.afterEach 全局后置钩子，进入路由之后
2&gt;路由独享守卫
如果不想全局配置守卫的话，可以为某些路由单独配置守卫
3&gt;路由组件内的守卫
beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建beforeRouteUpdate (2.2)路由复用同一个组件时,在当前路由改变，但是该组件被复用时调用 可以访问组件实例this
beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this
</code></pre>
<h4 id="vue-router-使用params与query传参有什么区别">vue-router 使用params与query传参有什么区别</h4>
<pre><code>vue-router 可以通过 params 与 query 进行传参
// 传递
this.$router.push({path: './xxx', params: {xx:xxx}})
this.$router.push({path: './xxx', query: {xx:xxx}})
// 接收
this.$route.params
this.$route.query
params 是路由的一部分,必须要有。query 是拼接在 url 后面的参数，没有也没关系
params 不设置的时候，刷新页面或者返回参数会丢，query 则不会有这个问题
</code></pre>
<h4 id="你在什么场景下使用了vuex">你在什么场景下使用了vuex？</h4>
<pre><code>当应用遇到多个组件共享状态的时候，即：多个视图依赖于同一个状态，不同视图的行为需要变更同一个状态
如：
用户的个人信息管理模块
电商项目购物车模块
</code></pre>
<h4 id="props和data的优先级区别">props和data的优先级，区别</h4>
<pre><code>props&gt;data
props就相当于你的参数，data就相当于局部变量，组件其实就是一个函数
</code></pre>
<h1 id="地址栏输入一个url发生了什么">地址栏输入一个url发生了什么</h1>
<p>1.DNS解析寻址,将输入的url解析为ip地址<br>
2.TCP三次握手:根据ip地址与服务器进行连接通信<br>
3.发送HTTP请求,请求相关资源<br>
4.服务器接收请求并返回HTTP报文,携带指定资源<br>
5.浏览器解析资源,渲染页面<br>
6.TCP四次挥手,关闭连接</p>
<h4 id="js执行机制">js执行机制</h4>
<p>a、首先 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。</p>
<p>b、在执行同步代码的时候，如果遇到了异步事件，会将异步代码放到事件循环中，继续执行执行栈中的其他任务;</p>
<p>c、当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行<br>
d、任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行<br>
e、当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务</p>
<h4 id=""></h4>
<h4 id="深拷贝与浅拷贝的区别">深拷贝与浅拷贝的区别？</h4>
<p>深拷贝递归地复制新对象中的所有值或属性，而拷贝只复制引用。</p>
<p>在深拷贝中，新对象中的更改不会影响原始对象，而在浅拷贝中，新对象中的更改，原始对象中也会跟着改。</p>
<p>在深拷贝中，原始对象不与新对象共享相同的属性，而在浅拷贝中，它们具有相同的属性。</p>
<p>方法：深拷贝：1.递归，2.JSON.stringify(JSON.parse())，3. JQ的extend方法</p>
<p>​			浅拷贝：1. Object.assign()  2. 使用 for in 循环，遍历每一个属性，将他们赋值给新的对象 3. 直接用=赋值 							4  ...扩展运算符</p>
<h5 id="js-中分全局作用域和函数作用">Js 中分全局作用域和函数作用</h5>
<p>全局作用域：在任何地方都能被访问，window对象下的内置属性都是全局作用域</p>
<p>函数作用域：固定代码片段中</p>
<p>作用域链：作用域都有上下级关系，上下级关系确定函数在哪个作用域下创建，变量取值都会在当前作用域中查找，如果没有查到就会像上级作用域查找，直到查到全局作用域，这个查找的过程叫做作用域链</p>
<h1 id="react">React</h1>
<h4 id="react如何实现双向绑定">react如何实现双向绑定</h4>
<pre><code>在React当中，有个onChange属性，可以给input绑定事件，当input框里的值发生变化时会触发调用方法，这个方法会合并data到this.state,并重新渲染组件。
</code></pre>
<h4 id="高阶组件是什么-什么情况下有用到">高阶组件是什么 什么情况下有用到</h4>
<pre><code>如果一个函数 接受一个或多个组件作为参数并且返回一个组件 就可称之为 高阶组件。
什么时候使用：页面复用,组件渲染性能追踪，权限控制。
</code></pre>
<h4 id="react生命周期">react生命周期</h4>
<pre><code>React组件的生命周期可以分为挂载、渲染和卸载这几个阶段，当渲染后的组件需要更新的时候，我们会重新去渲染组件，直到卸载。
因此，我们可以把React生命周期分为两类：
1 当组件在挂载或卸载时
2 当组件接收新的数据时，即组件更新时

componentWillMount  在渲染前调用
componentDidMount  在第一次渲染后调用
componentWillReceiveProps  在组件接受一个新的prop时调用，这个方法在第一次渲染的时候不会被调用。
shouldComponentUpdate  返回一个布尔值，在组件接受到新的props或是state时被调用。在初始化时或是使用forceUpdate时不被调用。可以在你确认不需要更新组件时使用。
componentWillUpdate 在组件接受到新的props或是state但还没有render时被调用。在初始化时不会被调用。
componentDidUpdate  在组件完成更新后立即调用。在初始化时不会被调用
componentWillUnmount  在组件从DOM中移除的时候立即被调用
</code></pre>
<h4 id="react做过哪些优化">react做过哪些优化</h4>
<pre><code>1 减少不必要的props引起的重绘
2 减少不必要state引起的重绘
3 长列表优化
</code></pre>
<h4 id="redux-流程">redux 流程</h4>
<pre><code>1.View在redux中会派发action方法;
2.action通过store的dispatch方法会派发给store;
3.store接收action，连同之前的state，一起传递给reducer；
4.reducer返回新的数据给store；
5.store去改变自己的state。
</code></pre>
<h4 id="说一下react中的key">说一下react中的key</h4>
<pre><code>它主要在于虚拟DOM的复用，绑定key可以更好的复用，避免重复渲染
</code></pre>
<h4 id="redux-数据流动-有什么组件-redux中connect介绍一下-connect的底层是什么">Redux 数据流动 有什么组件 redux中connect介绍一下   connect的底层是什么</h4>
<pre><code>connect是一个高阶函数，首先传入mapStateToProps、mapDispatchToProps，然后返回一个生产Component的函数(wrapWithConnect)，然后再将真正的Component作为参数传入wrapWithConnect，这样就生产出一个经过包裹的Connect组件。
</code></pre>
<h4 id="react的路由-项目中用到什么路由-介绍一下">React的路由 项目中用到什么路由 介绍一下</h4>
<pre><code>1 两种常用的路由：HashRouter和BrowserRouter
2 路由组件：包裹整个应用：一个React应用只使用一次
3 HashRouter：使用URL的哈希值实现，就是在地址栏的后面有#（localhost:3000/#/sdjdjdj）
4 推荐使用BrowserRouter：使用H5的historyAPI实现（localhost:3000/djjdd）
5 Link:组件：用于指定导航链接（a标签） 在浏览器解析时，会将link组件解析成a标签
6 Router组件：指定路由展示相关的组件信息
</code></pre>
<h4 id="react路由传参方法">React路由传参方法</h4>
<pre><code>  通过params
        1.路由表中      
              &lt;Route path=' /sort/:id '   component={Sort}&gt;&lt;/Route&gt;
        2.Link处        
          HTML方式
                 &lt;Link to={ ' /sort/ ' + ' 2 ' }  activeClassName='active'&gt;XXXX&lt;/Link&gt;   
          JS方式
                this.props.history.push(  '/sort/'+'2'  )
        3.sort页面       
               通过  this.props.match.params.id        就可以接受到传递过来的参数（id）
  通过query
      前提：必须由其他页面跳过来，参数才会被传递过来
　　　 注：不需要配置路由表。路由表中的内容照常：&lt;Route path='/sort' component={Sort}&gt;&lt;/Route&gt;
        1.Link处      
         HTML方式
            &lt;Link to={{ path : ' /sort ' , query : { name : 'sunny' }}}&gt;
       JS方式
            this.props.history.push({ path : '/sort' ,query : { name: ' sunny'} })
        2.sort页面     
              this.props.location.query.name
</code></pre>
<h1 id="原型原型链">原型，原型链</h1>
<p>原型：js给每个函数分配的公共空间，减少内存占用</p>
<p>原型链：多个原型的集合，当调用对象的属性或方法时，先自身找，找不到去原型链上找，一直找到Object构造函数得原型链</p>
<h1 id="其他">其他</h1>
<h4 id="sass和less区别">sass和less区别</h4>
<pre><code>1.编译环境不一样,less是基于JavaScript的在客户端处理 所以安装的时候用npm，sass是基于ruby所以在服务器处理。
2.变量符不一样，Less是@，而Scss是$，而且变量的作用域也不一样。
Sass的功能比Less强大
</code></pre>
<h4 id="link和inmport的区别"><strong>link和@inmport的区别</strong></h4>
<pre><code>1》link是html的标签，不仅可以加载css还可以定义Rss , rel连接属性；@import是css的语法规则，只能引入样式；
2》加载页面时，link是同时加载的，@impor是页面加载完后才加载
3》link没有兼容性的问题，而@import只在较高版本的浏览器才可以识别
4》link可以通过js插入操作dom，@import 不可以！
</code></pre>
<h4 id="如何理解js中的原型链"><strong>如何理解js中的原型链</strong></h4>
<pre><code>1；每个构造函数都有一个原型对象
2；每个原型对象都有一个指向构造函数的指针
3；每个实例函数都有一个指向原型对象的指针。
4；查找方式是一层一层查找，直至顶层。Object.prototype
</code></pre>
<h4 id="图片懒加载原理">图片懒加载原理</h4>
<pre><code>就是我们先设置图片的data-set属性（当然也可以是其他任意的，只要不会发送http请求就行了，作用就是为了存取值）值为其图片路径，由于不是src，所以不会发送http请求。 然后我们计算出页面scrollTop的高度和浏览器的高度之和， 如果图片举例页面顶端的坐标Y（相对于整个页面，而不是浏览器窗口）小于前两者之和，就说明图片就要显示出来了（合适的时机，当然也可以是其他情况），这时候我们再将 data-set 属性替换为 src 属性即可。

或
好处：减少HTTP请求
1、监控滚动条滚动
2、获取总可视内容高度（可见视口高度+滚动条滚动高度）
3、获取所有图片
4、遍历步骤3
5、在步骤4中判断，图片.offsetTop &lt;= 步骤2    成立-修改src属性为data-src、失败-不管
6、节流防抖优化
</code></pre>
<h4 id="react和vue有哪些不同说说你对这两个框架的看法"><strong>react和vue有哪些不同，说说你对这两个框架的看法</strong></h4>
<pre><code>相同点:
· 都支持服务器端渲染
· 都有Virtual DOM,组件化开发,通过props参数进行父子组件数据的传递,都实现webComponent规范
· 数据驱动视图
· 都有支持native的方案,React的React native,Vue的weex
不同点:
· React严格上只针对MVC的view层,Vue则是MVVM模式
· virtual DOM不一样,vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树.而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制
· 组件写法不一样, React推荐的做法是 JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即'all in js'; Vue推荐的做法是webpack+vue-loader的单文件组件格式,即html,css,jd写在同一个文件;
· 数据绑定: vue实现了数据的双向绑定,react数据流动是单向的
· state对象在react应用中不可变的,需要使用setState方法更新状态;在vue中,state对象不是必须的,数据由data属性在vue对象中管理
</code></pre>
<h4 id="px和em的区别"><strong>px和em的区别</strong></h4>
<pre><code>相同点：px和em都是长度单位；
异同点：px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。
浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。
</code></pre>
<h4 id="js哪些操作会造成内存泄露"><strong>JS哪些操作会造成内存泄露</strong></h4>
<pre><code>1）意外的全局变量引起的内存泄露
function leak(){  leak=&quot;xxx&quot;;//leak成为一个全局变量，不会被回收  }
2）闭包引起的内存泄露
3）没有清理的DOM元素引用
4）被遗忘的定时器或者回调 
5）子元素存在引起的内存泄露
</code></pre>
<h4 id="浏览器缓存有哪些通常缓存有哪几种"><strong>浏览器缓存有哪些，通常缓存有哪几种</strong></h4>
<pre><code>http缓存
websql
cookie
localstorage
sessionstorage
flash缓存
</code></pre>
<h4 id="浏览器是如何渲染页面的"><strong>浏览器是如何渲染页面的？</strong></h4>
<pre><code>渲染的流程如下：
1.解析HTML文件，创建DOM树。
   自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）。
2.解析CSS。优先级：浏览器默认设置&lt;用户设置&lt;外部样式&lt;内联样式&lt;HTML中的style样式；
3.将CSS与DOM合并，构建渲染树（Render Tree）
4.布局和绘制，重绘（repaint）和重排（reflow）
</code></pre>
<h4 id="css3新增的属性"><strong>CSS3新增的属性</strong></h4>
<pre><code>CSS3实现圆角（border-radius），阴影（box-shadow），
对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）
transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜
增加了更多的CSS选择器  多背景 rgba 
在CSS3中唯一引入的伪元素是::selection.
媒体查询，多栏布局
border-image
</code></pre>
<h4 id="h5新特性"><strong>H5新特性</strong></h4>
<pre><code>(1)新的语义标签和属性
(2)表单新特性
(3)视频和音频
(4)Canvas绘图
(5)SVG绘图
(6)地理定位
(7)拖放API
</code></pre>
<h4 id="谈一下js的继承">谈一下JS的继承</h4>
<pre><code>1.借用构造函数继承，使用call或apply方法，将父对象的构造函数绑定在子对象上
2.原型继承，将子对象的prototype指向父对象的一个实例
3.组合继承
原型链继承的缺点:
字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。
借用构造函数（类式继承）:
借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。
组合式继承:
组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。
</code></pre>
<h4 id="跨域的解决方法">跨域的解决方法</h4>
<pre><code>前端:1.浏览器插件2.前端代理3.SONP
后端:1.声明header头2.后端代理
运维:web服务器配置
等等
</code></pre>
<h4 id="谈谈你对闭包的理解">谈谈你对闭包的理解</h4>
<pre><code>使用闭包主要是为了设置私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念
闭包有三个特性：
1.函数嵌套函数
2.函数内部可以引用外部的参数和变量
3.参数和变量不会被垃圾回收机制回收
</code></pre>
<h4 id="浏览器兼容">浏览器兼容</h4>
<pre><code>浏览器兼容性问题，是指因为不同的浏览器对同一段代码有不同的解析，造成页面显示效果不统一的情况。
</code></pre>
<h4 id="做过哪些性能优化">做过哪些性能优化</h4>
<pre><code>1 尽量减少HTTP请求次数
2 压缩合并js
3 css精灵
4 减少DOM元素数量
5 使用CDN(网站上静态资源即css、js全都使用cdn分发，图片亦然,因为cdn拥有众多服务器，用户请求可以请求距离他近的服务器，加快速度)
6 把CSS放到顶部,把JS放到底部
7 使用gzip压缩内容(服务端)
</code></pre>
<h4 id="bfc的理解">BFC的理解</h4>
<pre><code> BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。
</code></pre>
<h4 id="js执行机制浏览器运行机制">JS执行机制（浏览器运行机制）</h4>
<pre><code>1.JavaScript是一门单线程语言。
2.Event Loop(事件循环)是JavaScript的执行机制。
</code></pre>
<h4 id="关于配置webpack的了解">关于配置webpack的了解？</h4>
<pre><code>它属于一个预编译模块方案（模块打包工具），我们现在的前端代码开始分模块进行构建，则会用到import &quot;./a.js&quot;; 、require (&quot;a.js&quot;); 等方法。但是浏览器是不认识这样的方法。这时，webpack 就出现了，它采用预编译的方式，在代码加载到页面前，把这些模块引用的方式转换成浏览器可以识别的js代码。
</code></pre>
<h4 id="怎么配置cli的三种环境">怎么配置cli的三种环境？</h4>
<pre><code>1.创建环境env文件
2.修改package.json
3.vue.config.js中引用环境变量
</code></pre>
<h4 id="组件的预加载说几种方式">组件的预加载，说几种方式。</h4>
<pre><code>1、使用import导入组件，可以获取到组件
2、使用import导入组件，直接将组件赋值给componet
3、使用require 导入组件，可以获取到组件
4、使用require 导入组件，直接将组件赋值给componet
</code></pre>
<h4 id="mpvue遇到的坑">mpvue遇到的坑</h4>
<pre><code>1.文件夹名字不能大写。
2.两层v-for不能用index的名字来作为索引
3.合法域名校验出错，不在以下合法域名列表中
</code></pre>
<h4 id="说一下盒模型">说一下盒模型</h4>
<pre><code>盒模型的组成，由里向外content，padding，border，margin。
盒模型有两种标准，一个是标准模型，一个是怪异盒模型。
</code></pre>
<h4 id="函数的this指向bind-call-apply-的区别-bind怎么立即调用call-apply怎么延迟调用">函数的this指向，bind call apply 的区别  bind怎么立即调用，call apply怎么延迟调用</h4>
<pre><code>A普通函数调用   	this =&gt;  window   	
B对象函数调用   	this =&gt;  对象本身    
C事件处理函数调用  this =&gt;  事件源    
D定时器调用       this =&gt;  window 
E箭头函数中调用    this  =&gt;  父function中的this    父没有function则window
F bind/apply/call this=&gt;   用来改变this指向 

区别：都用来改变this的指向，bind后函数不会执行，而只是返回一个改变了上下文的另一个函数，而call和apply是直接执行函数。若无参数，apply与call基本没什么区别
</code></pre>
<h4 id="es6">es6</h4>
<pre><code>1.不一样的变量声明：const和let
2.模板字符串
3.箭头函数（Arrow Functions）
4. 函数的参数默认值
5.Spread / Rest 操作符
6.二进制和八进制字面量
7.对象和数组解构
8.对象超类
9.for...of 和 for...in
10.ES6中的类
</code></pre>
<h4 id="promise是什么-和-async-await的区别-async-await-的底层">Promise是什么   和 async await的区别 async await 的底层</h4>
<pre><code>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大，简单地说，Promise好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而这些结果一旦生成是无法改变的

区别：1 Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。
2 async await与Promise一样，是非阻塞的。
3 async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函数。
</code></pre>
<h4 id="echarts是什么">Echarts是什么</h4>
<pre><code>商业级数据图表，它是一个纯JavaScript的图标库，兼容绝大部分的浏览器，底层依赖轻量级的canvas类库ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。创新的拖拽重计算、数据视图、值域漫游等特性大大增强了用户体验，赋予了用户对数据进行挖掘、整合的能力。
Echarts支持的图表：折线图（区域图）、柱状图（条状图）、散点图（气泡图）、K线图、饼图（环形图）
雷达图（填充雷达图）、和弦图、力导向布局图、地图、仪表盘、漏斗图、事件河流图等12类图表
</code></pre>
<h4 id="说一下深浅拷贝">说一下深浅拷贝</h4>
<pre><code>浅拷贝 shadow copy (传地址)
仅仅只拷贝对象自身，内部元素引用的其他对象只拷贝一个引用。
深拷贝 deep copy (传值)
外围和内部元素都拷贝了对象本身。而不是引用。因此深拷贝产生的副本可以随意修改，而不用担心会影响原始值。
</code></pre>
<h4 id="清除浮动的几种方法">清除浮动的几种方法</h4>
<pre><code>1，额外标签法，&lt;divstyle=&quot;clear:both;&quot;&gt;&lt;/div&gt;（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）
2，使用after伪类
#parent:after{
content:&quot;.&quot;;
height:0;
visibility:hidden;
display:block;
clear:both;
}
3,浮动外部元素
4,设置overflow为hidden或者auto
</code></pre>
<h4 id="commonjs的理解">Commonjs的理解</h4>
<pre><code>CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作
</code></pre>
<h4 id="请解释什么是事件代理">请解释什么是事件代理</h4>
<pre><code>事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。
事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能。
</code></pre>
<h4 id="创建ajax过程">创建ajax过程</h4>
<pre><code>ajax(异步javascript xml) 是什么：能够刷新局部网页数据而不是重新加载整个网页。
(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.
(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.
(3)设置响应HTTP请求状态变化的函数.
(4)发送HTTP请求.
(5)获取异步调用返回的数据.
(6)使用JavaScript和DOM实现局部刷新.
</code></pre>
<h4 id="为什么https安全">为什么HTTPS安全</h4>
<pre><code>因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性	
</code></pre>
<h4 id="节流防抖">节流防抖</h4>
<pre><code>节流：一段时间内，只执行一次函数
防抖：事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时
</code></pre>
<h4 id="说一下cookie和session的区别">说一下cookie和session的区别</h4>
<pre><code>性能角度: 	 cookie影响性能    h5不影响性能    h5最重要
生命周期:    cookie自定义      localStorage永久、sessionStorage窗口
存储空间：	cookie 4k      h5  5M
主要网站设置了cookie  后期所有请求都会携带cookie 影响性能
</code></pre>
<h4 id="数组的方法">数组的方法</h4>
<pre><code>1.concat() 功能：用于连接两个或多个数组，该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。
2.join() 功能：根据指定分隔符将数组中的所有元素放入一个字符串，并返回这个字符串。
3.pop() 功能：方法用于删除并返回数组的最后一个元素。
4.shift() 功能：方法用于删除并返回数组的第一个元素。
5.unshift() 功能：向数组的开头添加一个或更多元素，并返回新的长度。
6.push() 功能：向数组的末尾添加一个或更多元素，并返回新的长度。
7.slice() 功能：可从已有的数组中返回选定的元素。该方法接收两个参数slice(start,end)，strat为必选，表示从第几位开始；end为可选，表示到第几位结束(不包含end位)，省略表示到最后一位；start和end都可以为负数，负数时表示从最后一位开始算起，如-1表示最后一位。
8.splice() 功能：向数组中添加，或从数组删除，或替换数组中的元素，然后返回被删除/替换的元素。
参数：splice(start,num,data1,data2,...); 所有参数全部可选。
9.toString() 功能：转换成字符串，类似于没有参数的join()。该方法会在数据发生隐式类型转换时被自动调用，如果手动调用，就是直接转为字符串。
10.indexOf() 功能：根据指定的数据，从左向右，查询在数组中出现的位置，如果不存在指定的数据，返回-1。该方法是查询方法，不会对数组产生改变。
11.forEach() 功能：ES5新增方法，用来遍历数组，该方法没有返回值。forEach接收的回调函数会根据数组的每一项执行，该回调函数默认有三个参数，分别为：遍历到的数组的数据，对应的索引，数组自身。
12.map() 功能：1.同forEach功能；2.map的回调函数会将执行结果返回，最后map将所有回调函数的返回值组成新数组返回。
13.filter() 功能：1.同forEach功能；2.filter的回调函数需要返回布尔值，当为true时，将本次数组的数据返回给filter，最后filter将所有回调函数的返回值组成新数组返回（此功能可理解为“过滤”）。
</code></pre>
<h4 id="数组去重的方法">数组去重的方法</h4>
<pre><code>一、利用ES6中的 Set 方法去重
二、使用双重for循环，再利用数组的splice方法去重（ES5常用）
三、利用数组的indexOf方法去重
四、利用数组的sort方法去重（相邻元素对比法）
五、利用ES6中的Map方法去重
六、利用数组的filter方法去重
</code></pre>
<h4 id="export和export-default的区别">export和export default的区别？</h4>
<pre><code>使用上的不同+
import xxx from './'

export xxx
import {xxx} from './'
</code></pre>
<h4 id="get-post的区别">get、post的区别</h4>
<pre><code>1.get传参方式是通过地址栏URL传递，是可以直接看到get传递的参数，post传参方式参数URL不可见，get把请求的数据在URL后通过？连接，通过&amp;进行参数分割。psot将参数存放在HTTP的包体内
2.get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制
3.get后退不会有影响，post后退会重新进行提交
4.get请求可以被缓存，post不可以被缓存
5.get请求只URL编码，post支持多种编码方式
6.get请求的记录会留在历史记录中，post请求不会留在历史记录
7.get只支持ASCII字符，post没有字符类型限制
</code></pre>
<h4 id="优雅降级和渐进增强">优雅降级和渐进增强</h4>
<pre><code>渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。
优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。
</code></pre>
<h1 id="小程序">小程序</h1>
<h4 id="小程序接口必须是https-你写的项目中是谁操作的">小程序接口必须是https 你写的项目中是谁操作的</h4>
<pre><code>这个配置是公司后端/运维配置的，但是我个人对编程还是比较喜欢研究的 然后呢我就自己谷歌了一把发现就是去腾讯、阿里云申请证书，然后修改nginx配置就行。我当时用的是免费版，收费版没试过。
</code></pre>
<h4 id="小程序微信登录时怎么实现的">小程序微信登录时怎么实现的</h4>
<pre><code>首先通过wx.login和wx.reqeuset获取openid  然后根据API去获取用户的昵称和头像
</code></pre>
<h4 id="小程序项目你做过哪些优化">小程序项目你做过哪些优化</h4>
<pre><code>静态资源优化:
图片懒加载
七牛云对象存储
cdn加速
expires     之前给大家发的nginx课件里面有
gzip        之前给大家发的nginx课件里面有
后端接口优化:
接口开发规范restful api
接口安全（https）
接口性能（多台数据库、缓存服务器redis存内存等）
</code></pre>
<h4 id="咱们项目开发完毕发小超过2m-如果解决">咱们项目开发完毕发小超过2M 如果解决</h4>
<pre><code>静态资源 咱们可以分离项目 放到CDN服务器上  
太大了可以讲一个小程序变成2个小程序  这样就是4M  
然后通过声明式导航、编程式导航，点击直接跳转到另一个小程序即可。
</code></pre>
<h3 id="将一个div盒子水平垂直居中">将一个div盒子水平垂直居中</h3>
<pre><code>    .parent{
        width: 500px;
        height: 500px;
        border: 1px solid red;
    }
    .child{
        width: 100px;
        height: 100px;
        border: 1px slid #111;
    }
    
    
     &lt;div class=&quot;parent&quot;&gt;
         &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;
     &lt;/div&gt;
     
     
方法一：利用定位（常用方法,推荐）

.parent{

    position:relative;

    }

.child{

    position:absolute;

    top:50%;

    left:50%;

    margin-top:-50px;

    margin-left:-50px;

    }

方法一的原理就是定位中心点是盒子的左上顶点，所以定位之后我们需要回退盒子一半的距离。

 

方法二：利用margin:auto;

.parent{

    position:relative;

    }

.child{

    position:absolute;

    margin:auto;

    top:0;

    left:0;

    right:0;

    bottom:0;

    }

方法三：利用display:table-cell;

.parent{

    display:table-cell;

    vertical-align:middle;

    text-align:center;

    }

.child{

    display:inline-block;

    }

方法四：利用display：flex;设置垂直水平都居中；

.parent{

    display:flex;

    justify-content:center;

    align-items:center;

    }

方法五：计算父盒子与子盒子的空间距离(这跟方法一是一个道理)；

计算方法：父盒子高度或者宽度的一半减去子盒子高度或者宽的的一半。

.child{

    margin-top:200px;

    margin-left:200px;

    }

方法六：利用transform

.parent{

    position:relative;

    }

.child{

    position:absolute;

    top:50%;

    left:50%;

    transform:translate(-50%,-50%);

    }

方法七：利用calc计算

.parent{

    position:relative;

    }

.child{

    position:absolute;

    top:calc(200px);//（父元素高-子元素高）÷ 2=200px

    let:calc(200px);//（父元素宽-子元素宽）÷ 2=200px

    }
</code></pre>
<h1 id="vue中更新是异步还是同步的为什么">Vue中更新是异步还是同步的,为什么?</h1>
<ul>
<li>数据是同步更新，视图是异步更新</li>
<li>因为如果视图更新是同步的，那会导致多次渲染浪费不必要的性能，没必要，内部做了去重(重新更新的值)和防抖(只更新最后一次)</li>
</ul>
<h1 id="什么是promise">什么是Promise</h1>
<p>Promise 是异步编程的一种解决方案，其实是一个构造函数，自己身上有all、reject、resolve这几个方法，原型上有then、catch等方法  可以很好地解决<strong>回调地狱</strong>的问题（避免了层层嵌套的回调函数） ， 语法非常简洁</p>
<p><code>Promise</code>对象有以下两个特点。</p>
<p>特点1： 对象的状态不受外界影响。</p>
<p>​			解释： <code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和						<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无						法改变这个状态。</p>
<p>特点2： 一旦状态改变，就不会再变，任何时候都可以得到这个结果。</p>
<p>​			解释：Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要						这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定						型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。</p>
<h2 id="单行文本溢出显示省略号">单行文本溢出，显示省略号</h2>
<pre><code>.div_text{
             width: 300px; 
             overflow: hidden;
             text-overflow: ellipsis; 
             white-space: nowrap;
             }
</code></pre>
<h2 id="多行文本溢出显示省略号">多行文本溢出，显示省略号</h2>
<pre><code> .div_moreline{
            width: 300px; 
            display:-webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 3;
            overflow: hidden; 
            max-height: 90px;
            }
</code></pre>
<h2 id="css手写一个三角形">css手写一个三角形:</h2>
<pre><code>  .triangle{
            width: 0;
            height: 0;
            border: 50px solid transparent;
            border-top-color: black ;
        }

</code></pre>
<h1 id="vue-cli30兼容20版本">vue-cli3.0兼容2.0版本</h1>
<p>npm install -g @vue/cli-init</p>
<h1 id="什么时候视图不会更新">什么时候视图不会更新?</h1>
<pre><code>//1.操作数组的索引
//2.操作数组的length
//以上两种情况都不会更新视图
</code></pre>
<h1 id="为什么操作这两个属性不会更新视图">为什么操作这两个属性不会更新视图?</h1>
<pre><code>//原因就是因为Vue2.0底层响应式原理使用了ES5中的Object.defineProperty()这个方法,这个方法有个缺点,缺点就是无法劫持数组,数组的变化是没有办法进行响应
    //操作一些数组的方法 比如push pop shift unshift reverse等方法会触发视图的更新,因为vue的底层特别对这几个方法做了hack处理,只要我们调用这些方法也会视图的更新
    //Vue3.0的版本,使用的proxy这个方法,这个方法可以劫持数组,就不会出现操作索引和length不更新视图的情况了
</code></pre>
<h1 id="怎么处理不更新的问题">怎么处理不更新的问题?</h1>
<pre><code> //1.不要操作数组的length和索引,如果说硬要操作,可以使用Vue.$set(target,key,value)方法
 //2.如果说操作了这些属性,不知道问题在哪里,解决不了视图不更新的情况,我们可以调用强制更新$forceUpdate()
</code></pre>
<h1 id="v-for中有个属性keykey的作用是什么">v-for中有个属性,key,key的作用是什么?</h1>
<pre><code>用于区分diff算法的时候,元素的唯一性
//key的值,正常情况下一般都要给一个唯一的值,如果没有一个惟一的情况下,那么可以暂时的使用index来代替
//写项目的时候,后台返回的数据肯定有id,那么这个id就是唯一的标识所以我们一般使用id来作为key的值
</code></pre>
<h1 id="v-model的修饰符">v-model的修饰符 ?</h1>
<pre><code>trim lazy number
</code></pre>
<h1 id="v-if-v-show的区别-以及使用场景">V-if v-show的区别 以及使用场景</h1>
<pre><code>//v-if 都是用于控制元素/组件的显示和隐藏 值都是布尔值,如果布尔值为true那么元素就会显示,如果为false,那么元素或者组件就会隐藏 v-if元素不显示的时候,dom结构也会一并移除
//v-if可以和v-else v-else-if结合使用,如果v-if布尔值为true,那么不会展示v-else的内容,如果布尔值为false,那么就会展示v-else,而不会展示v-if,两者的关系,就是老死不相往来,互斥
//v-show  都是用于控制元素/组件的显示和隐藏 值都是布尔值,如果布尔值为true那么元素就会显示,如果为false,那么元素或者组件就会隐藏 v-show隐藏元素之后,不会移除dom结构

//使用场景:首次渲染开销较大的时候,可以使用v-if 频繁切换的时候使用v-show
</code></pre>
<h1 id="v-on的修饰符">v-on的修饰符</h1>
<pre><code>//prevent 阻止默认事件
//ocne 只调用一次
//native 触发组件根元素的原生事件
</code></pre>
<h1 id="定义自定义指令的方式以及自定义指令的钩子函数">定义自定义指令的方式,以及自定义指令的钩子函数</h1>
<pre><code>//bind
//inserted
//update
</code></pre>
<h1 id="计算属性的特点">计算属性的特点?</h1>
<pre><code> //1.计算的结果会缓存
 //2.根据外界响应式依赖发生变化而变化
</code></pre>
<h1 id="watch监听的三种情况和写法">watch监听的三种情况和写法</h1>
<pre><code>普通监听
深度监听
字符串写法
</code></pre>
<h1 id="v-if-v-for的优先级">v-if v-for的优先级</h1>
<pre><code>v-for优先级别高
</code></pre>
<h1 id="全局组件和局部组件创建方式">全局组件和局部组件创建方式</h1>
<pre><code>全局组件的创建
	利用Vue.component来创建全局组件
	vue.component( &quot;vheader&quot;,{
        template: 
        `&lt;div&gt;
        我是全局组件&lt;/div&gt;`
        })
     可以直接使用&lt;vheader&gt;&lt;/vheader&gt;,不需要挂载
     
 
局部组件创建
	（1）创建一个局部组件,举例，命名为App。
	（2）利用组件的components，将App挂载上去。
	（3）在页面使用&lt;App&gt;&lt;/App&gt;即可.
&lt;script&gt;
    const App = {  //创建
        template:`
        &lt;h3&gt;我是App组件&lt;/h3&gt;`
        }
    new vue({
    	el: '#app',
    	data:{},
    	components:{
   			App  //挂载
    	}
    })
 &lt;/ script&gt;


</code></pre>
<h1 id="组件的通信方式-写出所有的">组件的通信方式 写出所有的</h1>
<pre><code>父子传值：props
子父传值:$emit
eventbus
refs
$root
$parent
vueX

</code></pre>
<h1 id="在组件上使用v-model流程">在组件上使用v-model流程</h1>
<pre><code>父组件:子标签上v-model=&quot;val&quot;
子组件:input标签上动态绑定value :value=&quot;value&quot;
注册事件input
@input: 'ipt'
在methods中定义ipt事件，接收参数
    ipt(e){
        this.$emit('input',e.target.value)
    }
原理:语法糖默认接受value的props，默认发射input的事件出去
</code></pre>
<h1 id="封装组件的流程">封装组件的流程</h1>
<pre><code> 1.使用Vue.extend()创建一个组件

 2.使用Vue.component()方法注册组件

 3.如果子组件需要数据，可以在props中接受定义

 4.子组件修改好数据之后，想把数据传递给父组件，可以使用emit()方法
</code></pre>
<h1 id="slot具名插槽-插槽作用域">slot具名插槽 插槽作用域</h1>
<pre><code>1.具名插槽：给slot加上name属性，添加内容时，标签上 v-slot:name属性值
    举例：	
    &lt;div id=&quot;app&quot;&gt;
            &lt;sdh-com&gt;
                &lt;template v-slot:header&gt;
                    &lt;div class=&quot;header&quot;&gt;
                        &lt;h1&gt;这是顶部栏&lt;/h1&gt;
                    &lt;/div&gt;
                &lt;/template&gt;
            &lt;/sdh-com&gt;
     &lt;/div&gt;
    &lt;template id=&quot;sdh&quot;&gt;
        &lt;fieldset&gt;
            &lt;div id=&quot;header&quot;&gt;
                &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/fieldset&gt;
    &lt;/template&gt;

     &lt;script&gt;
         Vue.component('sdh-com', {
            data() {
                return {

                }
            },
            template: '#sdh'
        })

        const vm = new Vue({
            el: &quot;#app&quot;,
            data: {

            }
        })
    &lt;/script&gt;
    
    
2.插槽作用域：将组件内部的数据传递给分发的内容进行渲染，再通过solt接收分发内容
	举例：
		&lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;

        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
            &lt;title&gt;03.插槽slot.html&lt;/title&gt;
        &lt;/head&gt;

        &lt;body&gt;
            &lt;div id=&quot;app&quot;&gt;
                &lt;sdh-com&gt;
                    &lt;template v-slot=&quot;{arr}&quot;&gt;
                        &lt;ul&gt;
                            &lt;li v-for=&quot;(item,index) in arr&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/li&gt;
                        &lt;/ul&gt;
                    &lt;/template&gt;
                &lt;/sdh-com&gt;
            &lt;/div&gt;
        &lt;/body&gt;

        &lt;/html&gt;

        &lt;template id=&quot;sdh&quot;&gt;
            &lt;fieldset&gt;
                &lt;legend&gt;苏大海&lt;/legend&gt;
                &lt;h1&gt;{{girlFriend}}&lt;/h1&gt;
                &lt;slot :arr=&quot;arr&quot;&gt;&lt;/slot&gt;
            &lt;/fieldset&gt;
        &lt;/template&gt;

        &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
            //插槽作用域
            //将组件内部的数据传递给分发的内容进行渲染
            //再通过solt接收分发内容
            Vue.component('sdh-com', {
                data() {
                    return {
                        girlFriend: '乔姑娘',
                        arr: [&quot;黄瓜&quot;, '香蕉', '茄子', '山药', '莲藕']
                    }
                },
                template: '#sdh'
            })

            const vm = new Vue({
                el: &quot;#app&quot;,
                data: {
                    msg: &quot;那是&quot;
                }
            })
        &lt;/script&gt;

	
</code></pre>
<h1 id="mixins合并策略">Mixins合并策略</h1>
<pre><code>//1.如果说混入了data属性,那么会对data进行递归合并,冲突的时候,以组件的属性优先

//2.同名的钩子函数会被合并为一个数组,都会进行调用,会以混入对象的钩子函数优先调用

//3.组件选项 比如methods directives components filters...都会被合并为一个对象,冲突的时候,以组件的键值对为主
</code></pre>
<h1 id="nexttick的作用">$nextTick的作用</h1>
<pre><code>在下次dom,更新循环结束后执行延迟回调,在修改数据之后立即使用,获取更新后的dom元素
</code></pre>
<h1 id="vue生命周期钩子函数-created中能不能修改data-为什么">vue生命周期钩子函数 created中能不能修改data 为什么?</h1>
<pre><code>可以，在这里可以获取data,并且事件监听也添加上了,数据已经被劫持,观察者就绪,在这个钩子函数中可以修改data

</code></pre>
<h1 id="发送异步请求在哪个钩子">发送异步请求在哪个钩子?</h1>
<pre><code>created mounted
</code></pre>
<h1 id="beforedestroy和destroyed一般用来做什么">beforeDestroy和destroyed一般用来做什么?</h1>
<pre><code>销毁定时器，解绑全部指令及事件监听，清除全局事件等
</code></pre>
<h1 id="keep-alive的作用以及使用方式-钩子函数-以及两个属性的用法">keep-alive的作用以及使用方式 钩子函数 以及两个属性的用法</h1>
<pre><code>作用:缓存组件
钩子函数:activated deactivated
属性:include包含的组件会被缓存，exclude排除的组件不会被缓存

</code></pre>
<h1 id="组件相互嵌套钩子函数的执行顺序是什么">组件相互嵌套,钩子函数的执行顺序是什么?</h1>
<pre><code>父组件beforeCreated  ==》父组件created  ==》父组件beforeMount  ==》
子组件beforeCreated  ==》子组件created  ==》子组件beforeMount  ==》子组件mounted  ==》
父组件mounted
</code></pre>
<h1 id="父组件的beforeupdate触发了会不会触发子组件的beforeupdate">父组件的beforeUpdate触发了会不会触发子组件的beforeUpdate?</h1>
<pre><code>不会
</code></pre>
<h1 id="为什么beforecreate不能发请求">为什么beforeCreate不能发请求?</h1>
<pre><code>因为$data都还没初始化,就算获得了后台数据,也不能修改data
</code></pre>
<h1 id="什么是虚拟dom">什么是虚拟dom?</h1>
<pre><code>通过js模拟真实dom的嵌套,创建新的页面的结构,就是虚拟dom,在内存中,页面是看不见的,只有添加到页面上才能看见
</code></pre>
<h1 id="为什么要使用虚拟dom">为什么要使用虚拟dom?</h1>
<pre><code>使用虚拟dom,可以在内存中更新结构,而不是操作真实dom一个一个更新,最大的好处提高页面渲染的性能,结合diff算法 让页面进行高效更新
</code></pre>
<h1 id="vue响应式的原理是什么">Vue响应式的原理是什么?</h1>
<pre><code>　　Vue 的响应式原理是核心是通过 ES5 的保护对象的 Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM 树上。
</code></pre>
<h1 id="什么是回流-什么是重绘">什么是回流 什么是重绘?</h1>
<h1 id="32触发回流的条件-触发重绘的条件">32.触发回流的条件 触发重绘的条件?</h1>
<pre><code># 回流
1. 位置的改变 translate 定位的left top 
2. 元素位置的显示和隐藏也会引起回流
3. 宽高的变化
# 重绘
1. 颜色的变化
2. 字体风格的变化
3. 背景的变化
</code></pre>
<h1 id="33什么是单页应用">33.什么是单页应用?</h1>
<pre><code>一个项目只有一个html页面 所有的页面跳转依据于路由进行
</code></pre>
<h1 id="34单页应用的有点和缺点">34.单页应用的有点和缺点?</h1>
<pre><code>用户体验好,切换速度快,不需要刷新整个页面
</code></pre>
<h1 id="35怎么解决单页应用缺点的问题">35.怎么解决单页应用缺点的问题?</h1>
<pre><code>使用服务端渲染 nuxt
</code></pre>
<h1 id="36history-hash-abstract模式的区别">36.History hash abstract模式的区别?</h1>
<pre><code>1. hash有#号,#号后面的url不会向后端发起请求

2. hash路由使用onhashchange监听 history使用onpopstate监听 

3. history使用的是H5的api pushState replaceState
4. 当hash值相同时,不会触发hashchange,history当输入相同的路径的时候,会将浏览器中的地址当成是请求地址向后台发送请求,会造成页面404
5. abstract模式是在没有浏览器api的情况下自动启用,abstract模式在切换页面的时候,路径是不会发生变化的

6. 关键字 onhashchange pushstate replacestate popstate
7. 
</code></pre>
<h1 id="37动态路由参数解耦合步骤">37.动态路由参数解耦合步骤</h1>
<pre><code>再path路径下，通过props:true解耦，使用，通过props:['动态参数']
</code></pre>
<h1 id="38vuex中的state能映射到组件的data中吗为什么">38.vuex中的state能映射到组件的data中吗?为什么?</h1>
<pre><code>其实可以直接映射在data中,只是使用的时候要加（）不方便将state映射给data中的某一个属性
会造成vuex更新之后视图不更新只有computed才会根据依赖发生改变而改变

</code></pre>
<h1 id="39修改vuex中state唯一的方式是什么只有mutation中可以修改嘛哪些方式还可以修改state的状态">39.修改vuex中state唯一的方式是什么?只有mutation中可以修改嘛?哪些方式还可以修改state的状态?</h1>
<pre><code>mutation
有很多种方式可以修改state，比如getters，比如直接修改，比如action中可以直接修改。但是这些修改不符合vuex的设计原则;所以规定修改state，必需通过mutation进行更改

</code></pre>
<h1 id="40组件中的data为什么要写成一个函数">40.组件中的data为什么要写成一个函数?</h1>
<pre><code>因为如果data是一个对象则会造成数据共享，在多次使用该组件的时候，改变其中一个值会影响全部该组件的值。而如果是通过函数的形式返回出一个对象的话，在每次使用该组件时返回出的对象的地址指向是不一样的，这样子能让各个组件的数据独立。
</code></pre>
<h1 id="41说一下vuex异步的操作流程">41.说一下vuex异步的操作流程</h1>
<pre><code>action中发送异步请求，结果通过commit提交mutation
</code></pre>
<h1 id="网络安全">网络安全</h1>
<h2 id="xss攻击">XSS攻击</h2>
<blockquote>
<p><strong>跨网站指令码</strong>（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程式的安全漏洞攻击，是<a href="https://www.wikiwand.com/zh-hans/%E4%BB%A3%E7%A2%BC%E6%B3%A8%E5%85%A5">代码注入</a>的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。</p>
</blockquote>
<p>XSS 分为三种：反射型，存储型和 DOM-based</p>
<h3 id="如何攻击">如何攻击</h3>
<p>XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。</p>
<p>例如通过 URL 获取某些参数</p>
<pre><code class="language-html">&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;
&lt;div&gt;{{name}}&lt;/div&gt;
</code></pre>
<p>上述 URL 输入可能会将 HTML 改为 <code>alert(1)</code> ，这样页面中就凭空多了一段可执行脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻击。</p>
<p>也有另一种场景，比如写了一篇包含攻击代码 <code>alert(1)</code> 的文章，那么可能浏览文章的用户都会被攻击到。这种攻击类型是存储型攻击，也可以说是 DOM-based 攻击，并且这种攻击打击面更广。</p>
<h3 id="如何防御">如何防御</h3>
<p>最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义</p>
<pre><code class="language-js">function escape(str) {
  str = str.replace(/&amp;/g, '&amp;amp;')
  str = str.replace(/&lt;/g, '&amp;lt;')
  str = str.replace(/&gt;/g, '&amp;gt;')
  str = str.replace(/&quot;/g, '&amp;quto;')
  str = str.replace(/'/g, '&amp;#39;')
  str = str.replace(/`/g, '&amp;#96;')
  str = str.replace(/\//g, '&amp;#x2F;')
  return str
}
</code></pre>
<p>通过转义可以将攻击代码 <code>alert(1)</code> 变成</p>
<pre><code class="language-js">// -&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt;
escape('&lt;script&gt;alert(1)&lt;/script&gt;')
</code></pre>
<p>对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</p>
<pre><code class="language-js">var xss = require('xss')
var html = xss('&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;')
// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert(&quot;xss&quot;);&amp;lt;/script&amp;gt;
console.log(html)
</code></pre>
<p>以上示例使用了 <code>js-xss</code> 来实现。可以看到在输出中保留了 <code>h1</code> 标签且过滤了 <code>script</code> 标签</p>
<h3 id="csp攻击">CSP攻击</h3>
<blockquote>
<p>内容安全策略 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/CSP">CSP</a>) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/XSS">XSS</a>) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。</p>
</blockquote>
<p>我们可以通过 CSP 来尽量减少 XSS 攻击。CSP 本质上也是建立白名单，规定了浏览器只能够执行特定来源的代码。</p>
<p>通常可以通过 HTTP Header 中的 <code>Content-Security-Policy</code> 来开启 CSP</p>
<ul>
<li>
<p>只允许加载本站资源</p>
<pre><code class="language-http">Content-Security-Policy: default-src ‘self’
</code></pre>
</li>
<li>
<p>只允许加载 HTTPS 协议图片</p>
<pre><code class="language-http">Content-Security-Policy: img-src https://*
</code></pre>
</li>
<li>
<p>允许加载任何来源框架</p>
<pre><code class="language-http">Content-Security-Policy: child-src 'none'
</code></pre>
</li>
</ul>
<p>更多属性可以查看 <a href="https://content-security-policy.com/">这里</a></p>
<h2 id="csrf攻击">CSRF攻击</h2>
<blockquote>
<p><strong>跨站请求伪造</strong>（英语：Cross-site request forgery），也被称为 <strong>one-click attack</strong> 或者 <strong>session riding</strong>，通常缩写为 <strong>CSRF</strong> 或者 <strong>XSRF</strong>， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。[<a href="https://www.wikiwand.com/zh/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0#citenoteRistic1">1]</a> 跟<a href="https://www.wikiwand.com/zh/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC">跨網站指令碼</a>（XSS）相比，<strong>XSS</strong> 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p>
</blockquote>
<p>简单点说，CSRF 就是利用用户的登录态发起恶意请求。</p>
<h3 id="csrf漏洞现状">CSRF漏洞现状</h3>
<p>CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI......而现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。</p>
<h3 id="如何攻击-2">如何攻击</h3>
<p>假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口</p>
<pre><code class="language-html">&lt;img src=&quot;http://www.domain.com/xxx?comment='attack'&quot; /&gt;
</code></pre>
<p>如果接口是 Post 提交的，就相对麻烦点，需要用表单来提交接口</p>
<pre><code class="language-html">&lt;form action=&quot;http://www.domain.com/xxx&quot; id=&quot;CSRF&quot; method=&quot;post&quot;&gt;
  &lt;input name=&quot;comment&quot; value=&quot;attack&quot; type=&quot;hidden&quot; /&gt;
&lt;/form&gt;
</code></pre>
<h3 id="如何防御-2">如何防御</h3>
<p>防范 CSRF 可以遵循以下几种规则：</p>
<ol>
<li>Get 请求不对数据进行修改</li>
<li>不让第三方网站访问到用户 Cookie (httponly:true;ali.com)</li>
<li>阻止第三方网站请求接口</li>
<li>请求时附带验证信息，比如验证码或者 token</li>
</ol>
<h4 id="samesite">SameSite</h4>
<p>可以对 Cookie 设置 <code>SameSite</code> 属性。该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。</p>
<h4 id="验证-referer">验证 Referer</h4>
<p>对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。</p>
<h4 id="token">Token</h4>
<p>服务器下发一个随机 Token（算法不能复杂），每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。</p>
<h2 id="密码安全">密码安全</h2>
<p>密码安全虽然大多是后端的事情，但是作为一名优秀的前端程序员也需要熟悉这方面的知识。</p>
<h3 id="加盐">加盐</h3>
<p>对于密码存储来说，必然是不能明文存储在数据库中的，否则一旦数据库泄露，会对用户造成很大的损失。并且不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系。</p>
<p>通常需要对密码加盐，然后进行几次不同加密算法的加密。</p>
<pre><code class="language-js">// 加盐也就是给原密码添加字符串，增加原密码长度
sha256(sha1(md5(salt + password + salt)))
</code></pre>
<p>但是加盐并不能阻止别人盗取账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而应该提示账号或密码错误。</p>
<h1 id="vue中的render函数介绍">vue中的render函数介绍</h1>
<p><strong>render函数是什么</strong> ：</p>
<p>​	 简单的说，在vue中我们使用模板HTML语法组建页面的，使用render函数我们可以用js语言来构建DOM</p>
<p>​	 因为vue是虚拟DOM，所以在拿到template模板时也要转译成VNode的函数，而用render函数构建DOM，vue	就免去了转译的过程。</p>
<p>​	 使用render函数描述虚拟DOM时，vue提供一个函数，这个函数是就构建虚拟DOM所需要的工具。</p>
<h1 id="mvvm和mvc的区别"><strong>MVVM和MVC的区别</strong></h1>
<p>MVC和MVVM的区别其实并不大。都是一种设计思想。</p>
<p>主要就是MVC中Controller演变成MVVM中的viewModel。</p>
<p>MVVM主要解决了MVC中大量的DOM操作使页面渲染性能降低，加载速度变慢，影响用户体验。</p>
<p>当和Model频繁发生变化，开发者需要主动更新到View。</p>
<p><strong>MVVM设计模式的优点</strong></p>
<ol>
<li>
<p>双向绑定技术，当Model变化时，View-Model会自动更新，View也会自动变化。很好的做到数据的一致性</p>
</li>
<li>
<p>由于控制器的功能大都移动到View上处理，大大的对控制器进行了瘦身</p>
</li>
<li>
<p>View的功能进一步强化，具有控制的部分功能，</p>
<p>若想无限增强它的功能，甚至控制器的全部功能几乎都可以迁移到各个View上</p>
</li>
</ol>
<p>（不过这样不可取，那样View干不了属于它职责范围内的事情）。</p>
<p>View可以像控制器一样具有自己都View-Model</p>
<ol start="4">
<li>
<p>可以对View或ViewController的数据处理部分抽象出来一个函数处理model。</p>
<p>这样它们专职页面布局和页面跳转，它们必然更一步的简化。</p>
</li>
</ol>
<p><strong>MVVM设计模式的缺点</strong></p>
<ol>
<li>
<p>数据绑定也使得bug很难被调试。比如你看到页面异常了，有可能是你的View的代码有bug，也可能是你的model的代码有问题。数据绑定使得一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。</p>
</li>
<li>
<p>数据双向绑定不利于代码重用。客户端开发最常用的是View，但是数据双向绑定技术，让你在一个View都绑定了一个model，不同的模块model都不同。那就不能简单重用view了</p>
</li>
<li>
<p>一个大的模块中model也会很大，虽然使用方便了也很容易保证数据的一致性，但是长期持有，不释放内存就造成话费更多的内存。</p>
<h1 id="-2"></h1>
</li>
</ol>
<h1 id="let-const-var的区别">let、const、var的区别</h1>
<pre><code>const声明的是常量，必须赋值
    1）一旦声明必须赋值,不能使用null占位。
    2）声明后不能再修改
    3）如果声明的是复合类型数据，可以修改其属性

let和var声明的是变量，声明之后可以更改，声明时可以不赋值

var允许重复声明变量，后一个变量会覆盖前一个变量。

let和const在同一作用域不允许重复声明变量，会报错。

var声明的变量存在变量提升（将变量提升到当前作用域的顶部）。即变量可以在声明之前调用，值为undefined。
let和const不存在变量提升。即它们所声明的变量一定要在声明后使用，否则报ReferenceError错。


var：只有全局作用域和函数作用域概念，没有块级作用域的概念。但是会把{}内也假称为块作用域。
let const：只有块级作用域的概念 ，由 { } 包括起来，if语句和for语句里面的{ }也属于块级作用域。
ES5中作用域有：全局作用域、函数作用域。没有块作用域的概念。
ES6(简称ES6)中新增了块级作用域。块作用域由 { } 包括，if语句和for语句里面的{ }也属于块作用域。

ES6明确规定：如果区块中存在let命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
            所以在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。
</code></pre>
<h1 id="v-model是如何实现的语法糖">v-model是如何实现的，语法糖</h1>
<h3 id="1作用再普通的表单元素上">1.作用再普通的表单元素上</h3>
<ul>
<li>
<h4 id="动态绑定input的value指向的自定义的变量并且在触发input事件的时候去动态把自定义变量设置为目标值">动态绑定input的value指向的自定义的变量，并且在触发input事件的时候去动态把自定义变量设置为目标值</h4>
</li>
</ul>
<h3 id="2作用在组件上">2.作用在组件上</h3>
<ul>
<li>
<h4 id="是一个父子组件通信的语法糖通过props和emit实现">是一个父子组件通信的语法糖，通过props和$emit实现</h4>
<p>参考组件使用v-model流程</p>
</li>
</ul>
<pre><code>
&lt;input v-model=&quot;a&quot; /&gt;
input元素
&lt;input :value=&quot;a&quot; @input=&quot;a = $event.target.value&quot; /&gt; // $event.target.value
就是把input的值赋值给 a 

对于非input元素 
如果在自定义组件中，v-model
默认会利用名为 value 的 prop 和名为 input 的事件，如下所示： 

父组件：
&lt;ModelChild v-model=&quot;message&quot;&gt;&lt;/ModelChild&gt;

子组件：
&lt;div&gt;{{value}}&lt;/div&gt;
props:{ value: String }, 
methods: { 
    test1(){ 
        this.$emit('input', '小红') 
    }, 
},
</code></pre>
<p>，</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[javascript notes]]></title>
        <id>https://chenggr.github.io/post/javascript-notes/</id>
        <link href="https://chenggr.github.io/post/javascript-notes/">
        </link>
        <updated>2022-03-10T02:18:33.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>知识笔记</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>知识笔记</p>
</blockquote>
<!--more-->
<h1 id="常见值类型">常见值类型</h1>
<pre><code class="language-javascript">let a // undefined
const s = 'abc'
const n = 100
const b = true
const s = Symbol('s')
</code></pre>
<h1 id="常见引用类型">常见引用类型</h1>
<pre><code class="language-javascript">const obj = { x: 100 }
const arr = ['a', 'b', 'c']

const n = null // 特殊引用类型，指针指向为空的地址 

// 特殊应用类型，但不用于存储数据，所以没有“拷贝、复制函数”这一说
function fn() {}
</code></pre>
<h1 id="值类型和引用类型的区别">值类型和引用类型的区别</h1>
<pre><code class="language-javascript">const obj1 = { x: 100, y:200 }
const obj2 = obj1
let x1 = obj1.x
obj2.x = 101
x1 = 102
console.log(obj1.x)   // { x: 101 }
</code></pre>
<h1 id="typeof">typeof</h1>
<pre><code class="language-javascript">let a                           typeof a // 'undefined'
const str = 'abc'               typeof str // 'string'
const n = 100                   typeof n // 'number'
const b = true                  typeof b // 'boolean'
const s = Symbol('s')           typeof s // 'symbol' 
</code></pre>
<pre><code class="language-javascript">// 能判断函数
typeof console.log              // 'function'
typeof function () {}           // 'function'

// 能识别引用类型（不能再继续识别）
typeof null             // 'object'
typeof ['a', 'b']       // 'object'
typeof { x: 100 }       // 'object'
</code></pre>
<h1 id="深拷贝">深拷贝</h1>
<pre><code class="language-javascript">/**
 * 深拷贝
 */

const obj1 = {
    age: 20,
    name: 'xxx',
    address: {
        city: 'beijing'
    },
    arr: ['a', 'b', 'c']
}

const obj2 = deepClone(obj1)
obj2.address.city = 'shanghai'
obj2.arr[0] = 'a1'
console.log(obj1.address.city)
console.log(obj1.arr[0])

/**
 * 深拷贝
 * @param {Object} obj 要拷贝的对象
 */
function deepClone(obj = {}) {
    if (typeof obj !== 'object' || obj == null) {
        // obj 是 null ，或者不是对象和数组，直接返回
        return obj
    }

    // 初始化返回结果
    let result
    if (obj instanceof Array) {
        result = []
    } else {
        result = {}
    }

    for (let key in obj) {
        // 保证 key 不是原型的属性
        if (obj.hasOwnProperty(key)) {
            // 递归调用！！！
            result[key] = deepClone(obj[key])
        }
    }

    // 返回结果
    return result
}
</code></pre>
<h1 id="原型和原型链">原型和原型链</h1>
<pre><code class="language-javascript">// 父类
class People {
    constructor(name) {
        this.name = name
    }
    eat() {
        console.log(`${this.name} eat something`)
    }
}

// 子类
class Student extends People {
    constructor(name, number) {
        super(name)
        this.number = number
    }
    sayHi() {
        console.log(`姓名 ${this.name} 学号 ${this.number}`)
    }
}

// 子类
class Teacher extends People {
    constructor(name, major) {
        super(name)
        this.major = major
    }
    teach() {
        console.log(`${this.name} 教授 ${this.major}`)
    }
}

// 实例
const xialuo = new Student('夏洛', 100)
console.log(xialuo.name)
console.log(xialuo.number)
xialuo.sayHi()
xialuo.eat()

// 实例
const wanglaoshi = new Teacher('王老师', '语文')
console.log(wanglaoshi.name)
console.log(wanglaoshi.major)
wanglaoshi.teach()
wanglaoshi.eat()
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://chenggr.github.io/post-images/1646897786563.jpg" alt="" loading="lazy"></figure>
<h2 id="原型关系">原型关系</h2>
<pre><code>- 每个 class 都有显示原型 prototype
- 每个实例都有隐式原型 __proto__
- 实例的 __proto__ 指向对应 class 的 prototype
</code></pre>
<h2 id="基于原型的执行规则">基于原型的执行规则</h2>
<pre><code>- 获取属性 xialuo.name 或执行方法 xialuo.sayhi() 时
- 先在自身属性和方法寻找
- 如果找不到则自动 __proto__ 中查找
</code></pre>
<h2 id="原型链">原型链</h2>
<pre><code class="language-javascript">console.log( Student.prototype.__proto__ )
console.log( People.prototype )
console.log( People.prototype === Student.prototype.__proto__ )
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://chenggr.github.io/post-images/1646898516562.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://chenggr.github.io/post-images/1646898904237.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IDEA的使用]]></title>
        <id>https://chenggr.github.io/post/idea-de-shi-yong/</id>
        <link href="https://chenggr.github.io/post/idea-de-shi-yong/">
        </link>
        <updated>2021-11-22T01:34:24.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>记录IDEA常用快捷键配置。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>记录IDEA常用快捷键配置。</p>
</blockquote>
<!--more-->
<h3 id="idea常用快捷键">IDEA常用快捷键</h3>
<ul>
<li>
<p>删除当前行<br>
ctrl + d</p>
</li>
<li>
<p>复制当前行<br>
ctrl + alt + 向下光标</p>
</li>
<li>
<p>补全代码<br>
alt + /</p>
</li>
<li>
<p>添加和取消注释<br>
ctrl + /</p>
</li>
<li>
<p>导入该行需要的类 先配置auto import，然后使用<br>
alt + enter</p>
</li>
<li>
<p>快速格式化代码<br>
alt + ctrl + L</p>
</li>
<li>
<p>快速运行程序 自定义<br>
alt + R</p>
</li>
<li>
<p>生成构造器 generate<br>
control + N</p>
</li>
<li>
<p>查看一个类的层级关系<br>
control + H</p>
</li>
<li>
<p>把光标放在方法上，ctrl + B，可以定位到方法</p>
</li>
<li>
<p>自动分配变量名，通过在后面加 .var</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我的macOS常用软件及配置]]></title>
        <id>https://chenggr.github.io/post/wo-de-macos-chang-yong-ruan-jian-ji-pei-zhi/</id>
        <link href="https://chenggr.github.io/post/wo-de-macos-chang-yong-ruan-jian-ji-pei-zhi/">
        </link>
        <updated>2019-05-22T09:13:08.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>记录我的某些常用软件及配置，方便以后查看。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>记录我的某些常用软件及配置，方便以后查看。</p>
</blockquote>
<!--more-->
<h1 id="破解软件下载地址">破解软件下载地址</h1>
<p><a href ="https://xclient.info/">精品 MAC 应用分享</a><br>
<a href ="https://www.macbl.com/">马可菠萝</a></p>
<h1 id="软件">软件</h1>
<ul>
<li>
<p>chrome &amp; chrome 插件<br>
划词翻译<br>
web 前端助手（FeHelper）</p>
</li>
<li>
<p>可能需要用到的<br>
MacBooster 7（清理垃圾、内存）<br>
Dr. Unarchiver（解压）<br>
iStatistica（查看内存、网络、网速、等等）</p>
</li>
</ul>
<hr>
<ul>
<li>Sourcetree（git）</li>
<li>SmartSVN（svn）</li>
<li>微信开发者工具</li>
<li>Navicat Premium（数据库）</li>
<li>Sublime Text3（编辑器）</li>
<li>MAMP PRO（服务器）</li>
<li>Postman（接口）</li>
<li>Charles（抓包）</li>
<li>Vscode（编译器）</li>
</ul>
<hr>
<h1 id="配置">配置</h1>
<h2 id="vscode">vscode</h2>
<pre><code class="language-javascript">{
  &quot;editor.detectIndentation&quot;: false,
  // 重新设定 tabsize
  &quot;editor.tabSize&quot;: 2,
  // #每次保存的时候自动格式化
  &quot;editor.formatOnSave&quot;: true,
  // #每次保存的时候将代码按 eslint 格式进行修复
  &quot;eslint.autoFixOnSave&quot;: true,
  // 添加 vue 支持
  &quot;eslint.validate&quot;: [
    &quot;javascript&quot;,
    &quot;javascriptreact&quot;,
    {
    &quot;language&quot;: &quot;vue&quot;,
    &quot;autoFix&quot;: true
    }
  ],
  // #让 prettier 使用 eslint 的代码格式进行校验
  &quot;prettier.eslintIntegration&quot;: true,
  // #去掉代码结尾的分号
  &quot;prettier.semi&quot;: false,
  // #使用带引号替代双引号
  &quot;prettier.singleQuote&quot;: true,
  // #让函数(名)和后面的括号之间加个空格
  &quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true,
  // #这个按用户自身习惯选择
  &quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;,
  // #让 vue 中的 js 按编辑器自带的 ts 格式进行格式化
  &quot;vetur.format.defaultFormatter.js&quot;: &quot;vscode-typescript&quot;,
  &quot;vetur.format.defaultFormatterOptions&quot;: {
    &quot;js-beautify-html&quot;: {
    &quot;wrap_attributes&quot;: &quot;force-aligned&quot;
    // #vue 组件中 html 代码格式化样式
    }
  },
  // 格式化 stylus, 需安装 Manta's Stylus Supremacy 插件
  &quot;stylusSupremacy.insertColons&quot;: false, // 是否插入冒号
  &quot;stylusSupremacy.insertSemicolons&quot;: false, // 是否插入分好
  &quot;stylusSupremacy.insertBraces&quot;: false, // 是否插入大括号
  &quot;stylusSupremacy.insertNewLineAroundImports&quot;: false, // import 之后是否换行
  &quot;stylusSupremacy.insertNewLineAroundBlocks&quot;: false, // 两个选择器中是否换行
  &quot;eslint.options&quot;: {
    &quot;plugins&quot;: [&quot;html&quot;]
  },
  &quot;editor.fontSize&quot;: 13
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[interview-js]]></title>
        <id>https://chenggr.github.io/post/interview-js/</id>
        <link href="https://chenggr.github.io/post/interview-js/">
        </link>
        <updated>2019-05-22T08:38:02.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>imooc 的 javascript 笔记</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>imooc 的 javascript 笔记</p>
</blockquote>
<!--more-->
<h1 id="原型规则和示例">原型规则和示例</h1>
<ul>
<li>所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（除了“null”以外）</li>
<li>所有的引用类型（数组、对象、函数），都有一个 ** proto ** (隐式原型)属性，属性值是一个普通的对象</li>
<li>所有的函数，都有一个 prototype(显示原型)属性，属性值也是一个普通对象</li>
<li>所有的引用类型（数组、对象、函数），** proto ** (隐式原型)属性值指向它的构造函数的“prototype”(显示类型)属性值 <strong>obj. ** porto ** === Object.prototype</strong></li>
<li>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的 ** proto **(即它的构造函数的 prototype)中寻找</li>
</ul>
<h1 id="作用域和闭包">作用域和闭包</h1>
<p>执行上下文</p>
<p>this</p>
<p>作用域</p>
<p>作用域链</p>
<p>闭包</p>
<h2 id="执行上下文">执行上下文</h2>
<p>范围：一段 &lt; script &gt; 或者一个函数</p>
<p>全局：变量定义、函数声明</p>
<p>函数：变量定义、函数声明、this、arguments</p>
<p>Ps：函数声明 和 函数表达式 的区别</p>
<h2 id="this">this</h2>
<p>this 要执行时才能确认值，定义时无法确认</p>
<pre><code class="language-javascript">var a = {
  name: 'A',
  fn: function() {
    console.log(this.name)
  }
}
a.fn() // this === a
a.fn.call({ name: 'B' }) // this === {name: 'B'}
var fn1 = a.fn
fn1() // this === window
</code></pre>
<ul>
<li>作为构造函数执行</li>
<li>作为对象属性执行</li>
<li>作为普通函数执行</li>
<li>call apply bind</li>
</ul>
<pre><code class="language-javascript">function Foo(name) {
  this.name = name
}
var f = new Foo('zhangsan')
</code></pre>
<pre><code class="language-javascript">var obj = {
  name: 'A',
  printName: function() {
    console.log(this.name)
  }
}
obj.printName() // this === obj
</code></pre>
<pre><code class="language-javascript">function fn() {
  console.log(this) // this === window
}
fn()
</code></pre>
<pre><code class="language-javascript">// call apply bind
function fn1(name, age) {
  alert(name)
  console.log(this)
}
fn1.call({ x: 100 }, 'zhangsan', 20) // this === {x:100}
fn1.apply({ x: 100 }, ['zhangsan', 20])

var fn2 = function(name, age) {
  alert(name)
  console.log(this)
}.bind({ y: 200 })
fn2('zhangsan', 20)
</code></pre>
<p>作用域</p>
<ul>
<li>
<p>没有块级作用域</p>
</li>
<li>
<p>只有函数和全局作用域</p>
<p>​</p>
</li>
</ul>
<pre><code class="language-javascript">// 无块级作用域
if (true) {
  var name = 'zhangsan'
}
console.log(name)

// 函数和全局作用域
var a = 100
function fn() {
  var a = 200
  console.log('fn', a)
}
console.log('global', a)
fn()
</code></pre>
<p>作用域链</p>
<pre><code class="language-javascript">var a = 100
function fn() {
  var b = 200

  // 当前作用域没有定义的变量，即“自由变量”
  console.log(a)
  console.log(b)
}
fn()
</code></pre>
<pre><code class="language-javascript">var a = 100
function F1() {
  var b = 200
  function F2() {
    var c = 300
    console.log(a) // a是自由变量
    console.log(b) // b是自由变量
    console.log(c)
  }
  F2()
}
F1()
</code></pre>
<h2 id="闭包的使用场景">闭包的使用场景</h2>
<ul>
<li>函数作为返回值</li>
<li>函数作为参数传递</li>
</ul>
<pre><code class="language-javascript">function F1() {
  var a = 100
  // 返回一个函数(函数作为返回值)
  return function() {
    console.log(a) // 自由变量，父级作用域寻找
  }
}
// f1 得到一个函数
var f1 = F1()
var a = 200
f1()

// 1.函数作为返回值 ↑
// 2.函数作为参数来传递 ↓
function F1() {
  var a = 100
  return function() {
    console.log(a)
  }
}
var f1 = F1()
function F2(fn) {
  var a = 200
  fn()
}
F2(f1)
</code></pre>
<h3 id="创建-10-个a标签点击的时候弹出对应的序号">创建 10 个<a>标签，点击的时候弹出对应的序号</h3>
<pre><code class="language-javascript">var i
for (i = 0; i &lt; 10; i++) {
  ;(function(i) {
    var a = document.createElement('a')
    a.innerHTML = i + '&lt;br&gt;'
    a.addEventListener('click', function(e) {
      e.preventDefault()
      alert(i)
    })
    document.body.appendChild(a)
  })(i)
}
</code></pre>
<h3 id="闭包的应用">闭包的应用</h3>
<pre><code class="language-javascript">// 闭包实际开发中主要用于封装变量，收敛权限
function isFirstLoad() {
  var _list = []
  return function(id) {
    if (_list.indexOf(id) &gt;= 0) {
      return false
    } else {
      _list.push(id)
      return true
    }
  }
}
// 使用  判断是否第一次
var firstLoad = isFirstLoad()
firstLoad(10) // true
firstLoad(10) // false
firstLoad(20) // true
</code></pre>
<h1 id="异步和单线程">异步和单线程</h1>
<h2 id="同步和异步的区别是什么">同步和异步的区别是什么</h2>
<p>同步会阻塞代码执行，而异步不会</p>
<p>alert 是同步，setTimeout 是异步</p>
<h2 id="前端使用异步的场景有哪些">前端使用异步的场景有哪些</h2>
<p>定时任务：setTimeout、setInterval</p>
<p>网络请求：ajax 请求，动态<img>加载</p>
<p>事件绑定</p>
<h1 id="日期">日期</h1>
<pre><code class="language-javascript">Date.now() // 获取当前时间毫秒数
var dt = new Date()
dt.getTime() // 获取毫秒数
dt.getFullYear() // 年
dt.getMonth() // 月(0-11)
dt.getDate() // 日(1-31)
dt.getHours() // 小时(0-23)
dt.getMinutes() // 分钟(0-59)
dt.getSeconds() // 秒(0-59)
</code></pre>
<h1 id="数组-api">数组 API</h1>
<h2 id="foreach">forEach</h2>
<pre><code class="language-javascript">var arr = [1, 2, 3]
arr.forEach(function(item, index) {
  //  遍历数组的所有元素
  console.log(index, item)
})
</code></pre>
<h2 id="every">every</h2>
<pre><code class="language-javascript">var arr = [1, 2, 3]
var result = arr.every(function(item, index) {
  // 用来判断所有的数组元素，都满足一个条件
  if (item &lt; 4) {
    return true
  }
})
console.log(result)
</code></pre>
<h2 id="some">some</h2>
<pre><code class="language-javascript">var arr = [1, 2, 3]
var result = arr.some(function(item, index) {
  // 用来判断只要有一个数组元素满足条件
  if (item &lt; 1) {
    return true
  }
})
console.log(result)
</code></pre>
<h2 id="sort">sort</h2>
<pre><code class="language-javascript">var arr = [1, 3, 2, 3, 5]
var arr2 = arr.sort(function(a, b) {
  // 从小到大排序
  return a - b
  // 从大到小排序
  // return b - a
})
console.log(arr)
console.log(arr2)
</code></pre>
<h2 id="map">map</h2>
<pre><code class="language-javascript">var arr = [1, 2, 3, 4]
var arr2 = arr.map(function(item, index) {
  // 将元素重新组装，并返回
  return '&lt;b&gt;' + item + '&lt;/b&gt;'
})
console.log(arr2)
</code></pre>
<h2 id="filter">filter</h2>
<pre><code class="language-javascript">var arr = [1, 2, 3]
var arr2 = arr.filter(function(item, index) {
  // 通过某一个条件过滤数组
  if (item &gt;= 2) {
    return true
  }
})
console.log(arr2)
</code></pre>
<h1 id="对象-api">对象 API</h1>
<pre><code class="language-javascript">var obj = {
  x: 100,
  y: 200,
  z: 300
}
var key
for (key in obj) {
  if (obj.hasOwnProperty(key)) {
    console.log(key, obj[key])
  }
}
</code></pre>
<p><strong>获取随机数，要求是长度一致的字符串格式</strong></p>
<pre><code class="language-javascript">var random = Math.random()
var random = random + '0000000000' // 后面加上10个零
var random = random.slice(0, 10)
console.log(random)
</code></pre>
<p><strong>一个能遍历对象和数组的 forEach 函数</strong></p>
<pre><code class="language-javascript">// 自定义forEach
function forEach(obj, fn) {
  var key
  if (obj instanceof Array) {
    obj.forEach(function(item, index) {
      fn(index, item)
    })
  } else {
    for (key in obj) {
      if (obj.hasOwnProperty(key)) {
        fn(key, obj[key])
      }
    }
  }
}
// 使用forEach
// 遍历数组
var arr = [1, 2, 3]
// 注意,这里参数的位置顺序换了，为了和对象遍历格式一致
forEach(arr, function(index, item) {
  console.log(index, item)
})
// 遍历对象
var obj = { x: 100, y: 200 }
forEach(obj, function(key, value) {
  console.log(key, value)
})
</code></pre>
<h1 id="dom">DOM</h1>
<h2 id="获取-dom-节点">获取 DOM 节点</h2>
<pre><code class="language-javascript">var div1 = document.getElementById('div1') //元素
var divList = document.getElementsByTagName('div') // 集合

var containerList = document.getElementByClassName('.container') // 集合
var pList = document.querySelectorAll('p') // 集合
</code></pre>
<h2 id="property">property</h2>
<pre><code class="language-javascript">var obj = { x: 100, y: 200 }
console.log(obj.x) // 100

var p = document.getElementsByTagName('p')[0]
console.log(p.nodeName) // P
</code></pre>
<h2 id="attribute">Attribute</h2>
<pre><code class="language-javascript">var pList = document.querySelectorAll('p')
var p = pList[0]
p.getAttribute('data-name')
p.setAttribute('data-name', 'imooc')
p.getAttribute('style')
p.setAttribute('style', 'font-size:30px')
</code></pre>
<p>property 只是一个 js 对象的属性的修改</p>
<p>Attribute 是对 HTML 标签属性的修改</p>
<h2 id="新增节点">新增节点</h2>
<pre><code class="language-javascript">var div1 = document.getElementById('div1')
// 添加新节点
var p1 = document.createElement('p')
p1.innerHTML = 'this is p1'
div1.appendChild(p1) // 添加新创建的元素
// 移动已有节点
var p2 = document.getElementById('p2')
div1.appendChild(p2)
</code></pre>
<h2 id="获取父元素和子元素">获取父元素和子元素</h2>
<pre><code class="language-javascript">var div1 = document.getElementById('div1')
var parent = div1.parentElement

var child = div1.childNodes
</code></pre>
<h2 id="删除节点">删除节点</h2>
<pre><code class="language-javascript">var div1 = document.getElementById('div1')
var child = div1.childNodes
div1.removeChild(child[0])
</code></pre>
<h1 id="bom">BOM</h1>
<h2 id="navigator-screen">navigator &amp; screen</h2>
<pre><code class="language-javascript">// navigator
var ua = navigator.userAgent
var isChrome = ua.indexOf('Chrome')
console.log(isChrome)

// screen
console.log(screen.width)
console.log(screen.height)
</code></pre>
<h2 id="location-history">location &amp; history</h2>
<pre><code class="language-javascript">// location
console.log(location.href)
console.log(location.protocol) // 'http:' 'https:'
console.log(location.host) //  域名
console.log(location.pathname) // '/learn/199'
console.log(location.search) // '?a=xxx'
console.log(location.hash) // '#...'

// history
history.back()
history.forward()
</code></pre>
<h1 id="事件">事件</h1>
<h2 id="通用事件绑定">通用事件绑定</h2>
<pre><code class="language-javascript">var btn = document.getElementById('btn1')
btn.addEventListener('click', function(event) {
  console.log('clicked')
})

function bindEvent(elem, type, fn) {
  elem.addEventListener(type, fn)
}
var a = document.getElementById('link1')
bindEvent(a, 'click', function(e) {
  e.preventDefault() //阻止默认行为
  alert('clicked')
})
</code></pre>
<p>关于 IE 低版本的兼容性</p>
<p>IE 低版本使用 attachEvent 绑定事件，和 W3C 标准不一样</p>
<p>IE 低版本使用量已非常少，很多网站都早已不支持</p>
<h2 id="代理">代理</h2>
<pre><code class="language-html">&lt;div id=&quot;div1&quot;&gt;
  &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt;
  &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt;
  &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt;
  &lt;!-- 会随时新增更多a标签 --&gt;
&lt;/div&gt;

&lt;script&gt;
  var div1 = document.getElementById('div1')
  div1.addEventListener('click', function(e) {
    var target = e.target
    if (target.nodeName === 'A') {
      alert(target.innerHTML)
    }
  })
&lt;/script&gt;
</code></pre>
<h2 id="完善通用绑定事件的函数">完善通用绑定事件的函数</h2>
<pre><code class="language-javascript">function bindEvent(elem, type, selector, fn) {
  if (fn == null) {
    fn = selector
    selector = null
  }
  elem.addEventListener(type, function(e) {
    var target
    // 代理
    if (selector) {
      target = e.target
      if (target.matches(selector)) {
        fn.call(target, e)
      }
    } else {
      // 不是代理
      fn(e)
    }
  })
}

// 使用代理
var div1 = document.getElementById('div1')
bindEvent(div1, 'click', 'a', function(e) {
  console.log(this.innerHTML)
})

// 不使用代理
var a = document.getElementById('a1')
bindEvent(div1, 'click', function(e) {
  console.log(a.innerHTML)
})
</code></pre>
<h1 id="ajax">Ajax</h1>
<h2 id="xmlhttprequest">XMLHttpRequest</h2>
<pre><code class="language-javascript">var xhr = new XMLHttpRequest()
Xhr.open('GET', '/api', false) // false指异步
Xhr.onreadystatechange = function() {
  // 这里的函数异步执行
  if (xhr.readyState == 4) {
    if (xhr.status == 200) {
      console.log(xhr.responseText)
    }
  }
}
xhr.send(null)
</code></pre>
<p>IE 低版本使用 ActiveXObject</p>
<h2 id="readystate">readyState</h2>
<p>0 - (未初始化) 还没用调用 send()方法</p>
<p>1 - (载入) 已调用 send()方法，正在发送请求</p>
<p>2 - (载入完成) send()方法执行完成，已经接收到全部响应内容</p>
<p>3 - (交互) 正在解析响应内容</p>
<p>4 - (完成) 响应内容解析完成，可以在客户端调用了</p>
<h2 id="status">status</h2>
<p>2xx - 表示成功处理请求。 如 200</p>
<p>3xx - 需要重定向，浏览器直接跳转</p>
<p>4xx - 客户端请求错误，如 404</p>
<p>5xx - 服务端错误</p>
<h1 id="跨域">跨域</h1>
<p>浏览器有同源策略，不允许 ajax 访问其他域接口</p>
<p>跨域条件：协议、域名、端口，有一个不同就算跨域</p>
<h2 id="允许跨域的三个标签">允许跨域的三个标签</h2>
<p>img</p>
<p>link</p>
<p>script</p>
<p><img> 用于打点统计，统计网站可能是其他域</p>
<link><script> 可以使用CDN,CDN的也是其他域
<script>可以用于JSONP



## 跨域注意事项

所有的跨域请求都必须经过信息提供方允许

如果未经允许即可获取，那是浏览器同源策略出现漏洞



## JSONP实现原理

加载http://coding.m.imooc.com/classindex.html

不一定服务器端存在一个classindex.html文件

服务器跨域根据请求，动态生成一个文件，返回

同理于 <script src="http://coding.m.imooc.com/api.js">



例如你的网站要跨域访问慕课网的一个接口

慕课给你一个地址http://coding.m.imooc.com/api.js

返回内容格式如 callback({x:100,y:200}) (可动态生成)

```javascript
window.callback = function(data) {
    // 这是我们跨域得到的信息
  	console.log(data)
}
<script src="http://coding.m.imooc.com/api.js"></script>
<!-- 以上将返回 callback({x:100,y:200}) -->
<pre><code>


# 存储

描述一下cookie,sessionStorage和localStorage的区别

## cookie

本身用于客户端和服务器端通信

但是它有本地存储的功能，于是就被“借用”

使用document.cookie = … 获取和修改



**cookie用于存储的缺点**

存储量太小，只有4KB

所有http请求都带有，会影响获取资源的效率

API简单，需要封装才能用 document.cookie = ...



## sessionStorage和localStorage的

HTML5专门为存储而设计，最大容量5M

API简答易用

localStorage.setItem(key, value); localStorage.getItem(key)







# 页面加载

## 加载一个资源的过程

浏览器根据DNS服务器得到域名的IP地址

向这个IP的机器发送http(或https)请求

服务器收到、处理并返回http(或https)请求

浏览器得到返回内容

## 浏览器渲染页面的过程

根据HTML结果生成DOM Tree

根据CSS生成CSSOM

将DOM和CSSOM整合成RenderTree

根据RenderTree开始渲染和展示

遇到&lt;script&gt;时，会执行并阻塞渲染



## window.onload 和 DOMContentLoaded

```javascript
window.addEventListener('load',function () {
    // 页面的全部资源加载完才会执行，包括图片、视频等
})
document.addEventListener('DOMContentLoaded', function () {
    // DOM渲染完即可执行，此时图片、视频还可能没有加载完
})
</code></pre>
<h1 id="性能优化">性能优化</h1>
<p><strong>原则</strong></p>
<p>多使用内存、缓存或者其他方法</p>
<p>减少 CPU 计算、减少网络请求</p>
<p><strong>从哪里入手</strong></p>
<p>加载页面和静态资源</p>
<p>页面渲染</p>
<p><strong>加载资源优化</strong></p>
<p>静态资源的压缩合并</p>
<p>静态资源缓存</p>
<p>使用 CDN 让资源加载更快</p>
<p>使用 SSR 后端渲染，数据直接输出到 HTML 中</p>
<p><strong>渲染优化</strong></p>
<p>CSS 放前面、JS 放后面</p>
<p>懒加载(图片懒加载、下拉加载更多)</p>
<p>减少 DOM 查询，对 DOM 查询做缓存</p>
<p>减少 DOM 操作，多个操作尽量合并在一起执行</p>
<p>事件节流</p>
<p>尽早执行操作（如 DOMContentLoaded）</p>
<h2 id="缓存-dom-查询">缓存 DOM 查询</h2>
<pre><code class="language-javascript">// 未缓存DOM查询
var i
for (i = 0; i &lt; document.getElementByTagName('p').length; i++) {
  // todo
}

// 缓存了DOM查询
var pList = document.getElementByTagName('p')
var i
for (i = 0; i &lt; pList.length; i++) {
  //todo
}
</code></pre>
<h2 id="合并-dom-插入">合并 DOM 插入</h2>
<pre><code class="language-javascript">var listNode = document.getElementById('list')

// 要插入 10 个 li 标签
var frag = document.createDocumentFragment()
var x, li
for (x = 0; x &lt; 10; x++) {
  li = document.createElement('li')
  li.innerHTML = 'List item' + x
  frag.appendChild(li)
}
listNode.appendChild(frag)
</code></pre>
<h2 id="事件节流">事件节流</h2>
<pre><code class="language-javascript">var textarea = document.getElementById('text')
var timeoutId
textarea.addEventListener('keyup', function() {
  if (timeoutId) {
    clearTimeout(timeoutId)
  }
  timeoutId = setTimeout(function() {
    // 触发 change 事件
  }, 100)
})
</code></pre>
<h2 id="尽早操作">尽早操作</h2>
<pre><code class="language-javascript">window.addEventListener('load', function() {
  // 页面的全部资源加载完才会执行，包括图片、视频等
})
document.addEventListener('DOMContentLoaded', function() {
  // DOM渲染完即可执行，此时图片、视频还可能没有加载完
})
</code></pre>
<h1 id="安全性">安全性</h1>
<p>XSS 跨站请求攻击</p>
<p>XSRF 跨站请求伪造</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[interview]]></title>
        <id>https://chenggr.github.io/post/interview/</id>
        <link href="https://chenggr.github.io/post/interview/">
        </link>
        <updated>2019-05-22T00:38:57.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>imooc 面试笔记</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>imooc 面试笔记</p>
</blockquote>
<!--more-->
<h1 id="dom-事件">DOM 事件</h1>
<p>基本概念：DOM 事件级别</p>
<p>DOM 事件级别</p>
<p>DOM 事件流</p>
<p>描述 DOM 事件捕获的具体流程</p>
<p>Event 对象的常用应用</p>
<p>自定义事件</p>
<h2 id="dom-事件类-事件级别">DOM 事件类 事件级别</h2>
<p>DOM0 element.onclick=function(){}</p>
<p>DOM2 element.addEventListener('click',function(){},false)</p>
<p>DOM3 element.addEventListener('keyup',function(){},false)</p>
<h2 id="dom-事件模型">DOM 事件模型</h2>
<p>事件模型</p>
<p>​ 捕获 ↓ 冒泡 ↑</p>
<h2 id="dom-事件流">DOM 事件流</h2>
<p>三阶段</p>
<p>捕获-&gt;目标阶段-&gt;冒泡</p>
<h2 id="描述-dom-事件捕获的具体流程">描述 DOM 事件捕获的具体流程</h2>
<p>window-&gt;</p>
<p>​ document-&gt;</p>
<p>​ html-&gt;</p>
<p>​ body-&gt;</p>
<p>​ ….</p>
<p>​ 目标元素</p>
<pre><code class="language-javascript">var ev = document.getElementById('ev')

window.addEventListener(
  'click',
  function(e) {
    console.log('window captrue')
  },
  true
)

document.addEventListener(
  'click',
  function(e) {
    console.log('document captrue')
  },
  true
)

document.documentElement.addEventListener(
  'click',
  function(e) {
    console.log('html captrue')
  },
  true
)

document.body.addEventListener(
  'click',
  function(e) {
    console.log('body captrue')
  },
  true
)

ev.addEventListener(
  'click',
  function(e) {
    console.log('ev captrue')
  },
  true
)
</code></pre>
<h2 id="event-对象的常用应用">Event 对象的常用应用</h2>
<p>event.preventDefault() //阻止默认行为</p>
<p>Event.stopPropagation() //阻止冒泡行为</p>
<p>Event.stopImmediatePropagation()</p>
<p>​ //同一元素绑定两个点击事件 A 和 B 在事件 A 中使用该事件 Event.stopImmediatePropagation()可以阻止事件 B 的触发</p>
<p>Event.currentTarget //当前绑定的事件</p>
<p>Event.target //当前被点击的元素</p>
<h2 id="自定义事件">自定义事件</h2>
<pre><code class="language-Javascript">var eve = new Event('custome');
el.addEventListener('custome',function(){
  console.log('custome');
});
el.dispatchEvent(eve)
</code></pre>
<p>CustomEvent 可以添加参数</p>
<h1 id="http-协议类">HTTP 协议类</h1>
<p>HTTP 协议的主要特点</p>
<p>HTTP 报文的组成部分</p>
<p>HTTP 方法</p>
<p>POST 和 GET 的区别</p>
<p>HTTP 状态码</p>
<p>什么是持久链接</p>
<p>什么是管线化</p>
<h2 id="http-协议的主要特点">HTTP 协议的主要特点</h2>
<h3 id="简单快速">简单快速</h3>
<p>​ 每个资源(URI)都是固定的</p>
<h3 id="灵活">灵活</h3>
<p>​ 通过头部分，一个 HTTP 协议可以完成不同数据类型的传输</p>
<h3 id="无连接">无连接</h3>
<p>​ 连接一次，它就会断掉，不会保持连接</p>
<h3 id="无状态">无状态</h3>
<p>​ 单从 HTTP 协议上，是不能区分两次连接者的身份的</p>
<h2 id="http-报文的组成部分">HTTP 报文的组成部分</h2>
<h3 id="请求报文">请求报文</h3>
<p>​ 请求行</p>
<p>​ http 方法、页面地址、http 协议、版本</p>
<p>​ 请求头</p>
<p>​ 空行</p>
<p>​ 请求体</p>
<h3 id="响应报文">响应报文</h3>
<p>​ 状态行</p>
<p>​ 响应头</p>
<p>​ 空行</p>
<p>​ 响应体</p>
<h2 id="http-协议类-2">HTTP 协议类</h2>
<h3 id="http-方法">HTTP 方法</h3>
<p>​ GET 获取资源</p>
<p>​ POST 传输资源</p>
<p>​ PUT 更新资源</p>
<p>​ DELETE 删除资源</p>
<p>​ HEAD 获得报文首部</p>
<h2 id="post-和-get-的区别">POST 和 GET 的区别</h2>
<ul>
<li>
<p>GET 在浏览器回退时是无害的，而 POST 会再次提交请求</p>
</li>
<li>
<p>GET 产生的 URL 地址可以被收藏，而 POST 不可以</p>
</li>
<li>
<p>GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置</p>
</li>
<li>
<p>GET 请求只能进行 url 编码，而 POST 支持多种编码方式</p>
</li>
<li>
<p>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留</p>
</li>
<li>
<p>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有限制</p>
</li>
<li>
<p>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制</p>
</li>
<li>
<p>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息</p>
</li>
<li>
<p>GET 参数通过 URL 传递，POST 放在 Request body 中</p>
</li>
</ul>
<h2 id="http-状态码">HTTP 状态码</h2>
<p>1xx: 指示信息-表示请求已接受，继续处理</p>
<p>2xx: 成功-表示请求已被成功接受</p>
<p>3xx: 重定向-要完成请求必须进行更进一步的操作</p>
<p>4xx: 客户端错误-请求语法错误或请求无法实现</p>
<p>5xx: 服务器错误-服务器未能实现合法的请求</p>
<p>200 OK : 客户端请求成功</p>
<p>206 Partial Content: 客户发送了一个带有 Range 头的 GET 请求，服务器完成了它</p>
<p>301 Moved Permanently: 所请求的页面已经转移至新的 url</p>
<p>302 Found: 所请求的页面已经临时转移至新的 url</p>
<p>304 Not Modified: 客户端有缓存的文档并发出了一个条件性的请求，服务器告诉客户，原来缓存的文档还可以继续使用</p>
<p>400 Bad Request: 客户端请求有语法错误，不能被服务器所理解</p>
<p>401 Unauthorized: 请求未经许可，这个状态码必须和 WWW-Authenticate 报头域一起使用</p>
<p>403 Forbidden: 对被请求页面的访问被禁止</p>
<p>404 Not Found: 请求资源不存在</p>
<p>500 Internal Server Error: 服务器发生不可预测的错误原来缓存的文档还可以继续使用</p>
<p>503 Server Unavailable: 请求未完成，服务器临时过载或当机，一段时间后可能恢复正常</p>
<h2 id="持久链接">持久链接</h2>
<p>HTTP 协议采用“请求-应答”模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建立一个连接，完成之后立即断开连接（HTTP 协议为无连接的协议）</p>
<p>当使用 Keep-Alive 模式(又称持久连接、连接重用)时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或重新建立连接</p>
<p>1.1 才支持持久连接</p>
<h2 id="管线化">管线化</h2>
<p><strong>在使用持久连接的情况下</strong>，某个连接上消息的传递类似于</p>
<p>请求 1-&gt;响应 1-&gt;请求 2-&gt;响应 2-&gt;请求 3-&gt;响应 3</p>
<p>某个连接上的消息变成了类似这样</p>
<p>请求 1-&gt;请求 2-&gt;请求 3-&gt;响应 1-&gt;响应 2-&gt;响应 3</p>
<ul>
<li>管线化机制通过持久连接完成，仅 HTTP/1.1 支持此技术</li>
<li>只有 GET 和 HEAD 请求可以进行管线化，而 POST 则有所限制</li>
<li>初次创建连接时不应启动管线机制，因为对方(服务器)不一定支持 HTTP/1.1 版本的协议</li>
<li>管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变</li>
<li>HTTP/1.1 要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可</li>
<li>由于上面提到的服务器端的问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理 程序对管线化的支持并不好，因此现代浏览器如 Chrome 和 Firefox 默认并未开启管线化支持</li>
</ul>
<h1 id="原型链类">原型链类</h1>
<p>创建对象有几种方法</p>
<p>原型、构造函数、实例、原型链</p>
<p>instanceof 的原理</p>
<p>new 运算符</p>
<h2 id="创建对象的几种方法">创建对象的几种方法</h2>
<p>// 字面量创建对象</p>
<p>var o1 = {name:'o1'}</p>
<p>var o11 = new Object({name:'o11'})</p>
<p>// 显示构造函数创建对象</p>
<p>var M = function(){this.name = 'o2'}</p>
<p>var o2 = new M();</p>
<p>// 通过 Object.create</p>
<p>var P = {name: 'o3'}</p>
<p>var o3 = Object.create(P)</p>
<h2 id="new-运算符">new 运算符</h2>
<p>一个新对象被创建。它继承自 foo.prototype</p>
<p>​ ↓</p>
<p>构造函数 foo 被执行。执行的时候，相应的传参会被传入，同时上下文（this）会被指定为这个新实例。new foo 等同于 new foo(),只能用在不传递任何参数的情况</p>
<p>​ ↓</p>
<p>如果构造函数返回一个“对象”，那么这个对象会取代整个 new 处理的结果。如果构造函数没有返回对象，那么 new 出来的结果为步骤 1 创建的对象。</p>
<pre><code class="language-javascript">var new2 = function(func) {
  var o = Object.create(func.prototype) //传入一个构造函数的原型对象来创建对象
  var k = func.call(o) //上下文（this）会指定为这个新实例
  if (typeof k === 'object') {
    return k
  } else {
    return o
  }
}
</code></pre>
<h1 id="通信类">通信类</h1>
<p>什么是同源策略及限制</p>
<p>前后端如何通信</p>
<p>如何创建 Ajax</p>
<p>跨域通信的几种方式</p>
<h2 id="什么是同源策略及限制">什么是同源策略及限制</h2>
<p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。</p>
<p>这是一个用于隔离潜在恶意文件的关键的安全机制。</p>
<ul>
<li>
<p>Cookie、LocalStorage 和 IndexDB 无法读取</p>
</li>
<li>
<p>DOM 无法获得</p>
</li>
<li>
<p>AJAX 请求不能发送</p>
<p>​</p>
</li>
</ul>
<h2 id="前后端如何通信">前后端如何通信</h2>
<p>Ajax</p>
<p>WebSocket</p>
<p>CORS</p>
<h2 id="如何创建-ajax">如何创建 Ajax</h2>
<p>XMLHttpRequest 对象的工作流程</p>
<p>兼容性处理</p>
<p>事件的触发条件</p>
<p>事件的触发顺序</p>
<h2 id="跨域通信的几种方式">跨域通信的几种方式</h2>
<p>JSONP</p>
<p>Hash</p>
<p>postMessage</p>
<p>WebSocket</p>
<p>CORS</p>
<h1 id="安全类">安全类</h1>
<h2 id="csrf">CSRF</h2>
<p>CSRF,通常称为跨站请求伪造，英文名 Cross-site request forgery</p>
<h2 id="csrf-防御措施">CSRF 防御措施</h2>
<p>Token 验证</p>
<p>Referer 验证</p>
<p>隐藏令牌</p>
<h2 id="xss">XSS</h2>
<p>XSS（cross-site scripting）跨域脚本攻击</p>
<h1 id="算法类">算法类</h1>
<p>排序</p>
<p>堆栈、队列、链表</p>
<p>递归</p>
<p>波兰式和逆波兰式</p>
<h1 id="渲染机制">渲染机制</h1>
<h2 id="什么是-doctype-及作用">什么是 DOCTYPE 及作用</h2>
<p>DTD(doucument type definition,文档类型定义)是一系列的语法规则，用来定义 XML 或(x)HTML 的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器模式</p>
<p>DOCTYPE 是用来声明文档类型和 DTD 规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出一些差错</p>
<h2 id="浏览器渲染过程">浏览器渲染过程</h2>
<h2 id="重排-reflow">重排 Reflow</h2>
<p><strong>定义</strong></p>
<p>DOM 结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为 reflow</p>
<p><strong>触发 Reflow</strong></p>
<p>当你增加、删除、修改 DOM 节点时，会导致 Reflow 或 Repaint</p>
<p>当你移动 DOM 的位置，或是搞个动画的时候</p>
<p>当你修改 CSS 样式的时候</p>
<p>当你 Resize 窗口的时候（移动端没有这个问题），或是滚动的时候</p>
<p>当你修改网页的默认字体时</p>
<h2 id="重绘-repaint">重绘 Repaint</h2>
<p><strong>定义</strong></p>
<p>当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等确定下来后，浏览器于是便把这些元素都按照各自的特性绘制一遍，于是页面的内容出现了，这个过程称之为 repaint</p>
<p><strong>触发 Repaint</strong></p>
<p>DOM 改动</p>
<p>CSS 改动</p>
<h2 id="布局-layout">布局 Layout</h2>
<h1 id="js-运行机制">JS 运行机制</h1>
<p>异步任务</p>
<p>setTimeout 和 setInterval</p>
<p>DOM 事件</p>
<p>ES6 中的 Promise</p>
<h1 id="页面性能">页面性能</h1>
<p>提升页面性能的方法有哪些？</p>
<p>1、资源压缩合并，减少 HTTP 请求</p>
<p>2、非核心代码异步加载-&gt;异步加载的方式-&gt;异步加载的区别</p>
<p>3、利用浏览器缓存-&gt;缓存的分类-&gt;缓存的原理</p>
<p>4、使用 CDN</p>
<p>5、预解析 DNS</p>
<p>​ <meta http-equiv="x-dns-prefetch-control" content="on"> // https 中 a 链接打开 DNS 预解析</p>
<p>​ <link rel="dns-prefetch" href="//host_name_to_prefetch.com"></p>
<p><strong>异步加载</strong></p>
<p>1、异步加载的方式</p>
<p>​ 1）动态脚本加载 2）defer 3）async</p>
<p>2、异步加载的区别</p>
<p>​ 1）defer 是在 HTML 解析完之后才会执行，如果是多个，按照加载的顺序依次执行</p>
<p>​ 2）async 是在加载之后立即执行，如果是多个，执行顺序和加载顺序无关</p>
<p><strong>浏览器缓存</strong></p>
<p>1、缓存的分类</p>
<p>​ 1）强缓存</p>
<p>​ Expires Expires:Thu,21 Jan 2017 23:39:02 GMT</p>
<p>​ Cache-Control Cache-Control:max-age=3600</p>
<p>​ 2）协商缓存</p>
<p>​ Last-Modified If-Modified-Since Last-Modified:Wed,26 Jan 2017 00:35:11 GMT</p>
<p>​ Etag If-None-Match</p>
<h1 id="错误监控">错误监控</h1>
<p>前端错误的分类</p>
<p>错误的捕获方式</p>
<p>上报错误的基本原理</p>
<p><strong>即时运行错误的捕获方式</strong></p>
<p>1）try…catch 2）window.onerror</p>
<p><strong>资源加载错误</strong></p>
<p>1）object.onerror 2）performance.getEntries() 3）Error 事件捕获</p>
<p><strong>延伸：跨域的 js 运行错误跨域捕获吗，错误提示什么，应该怎么处理？</strong></p>
<p>1、在 script 标签增加 crossorigin 属性</p>
<p>2、设置 js 资源响应头 Access-Control-Allow-Origin:*</p>
<p><strong>上报错误的基本原理</strong></p>
<p>1、采用 Ajax 通信的方式上报</p>
<p>2、利用 Image 对象上报</p>
<h1 id="业务能力">业务能力</h1>
<p>我做过什么业务？</p>
<p>负责的业务有什么业绩？</p>
<p>使用了什么技术方案？</p>
<p>突破了什么技术难点？</p>
<p>遇到了什么问题？</p>
<p>最大的收获是什么？</p>
<h1 id="事物推动能力">事物推动能力</h1>
<p>主动描述</p>
<h1 id="终面">终面</h1>
<p>1、职业竞争力</p>
<p>2、职业规划</p>
<h2 id="职业竞争力">职业竞争力</h2>
<p>1、业务能力</p>
<p>2、思考能力</p>
<p>3、学习能力</p>
<p>4、无上限的付出</p>
<h1 id="职业规划">职业规划</h1>
<p>1、目标是什么</p>
<p>​ 在业务上成为专家，在技术上成为行业大牛</p>
<p>2、近阶段的目标</p>
<p>​ 不断的学习积累各方面的经验，以学习为主</p>
<p>3、长期目标</p>
<p>​ 做几件很有价值的事情，如开源作品、技术框架等</p>
<p>4、方式方法</p>
<p>​ 先完成业务上的主要问题，做到极致、然后逐步向目标靠拢</p>
<h1 id="面试技巧">面试技巧</h1>
<p>1、乐观积极</p>
<p>2、主动沟通</p>
<p>3、逻辑顺畅</p>
<p>4、上进有责任心</p>
<p>5、有主张、做事果断</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://chenggr.github.io/post/hello-gridea/</id>
        <link href="https://chenggr.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>